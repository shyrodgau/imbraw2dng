<html>
<!--

imbraw2dng.html

Convert RAW from I'm back(R)(https://imback.eu) into DNG

Stefan Hegny, 2023

https://github.com/shyrodgau/imbraw2dng

Free software, use at own risk for whatever you like

Use: open in browser and select RAW

-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>ImB RAW to DNG Converter V2.9.9_c82b5e1</title>
<script type="text/javascript" language="javascript">
/* i18 */
const alllangs = [ 'de' , 'en', 'nn' ];
let mylang = 'en';
let xlargs = [];
const texts = {
	main: {
		title: {
			de: 'ImB RAW nach DNG Konverter',
			en: 'ImB RAW to DNG converter',
		},
		file: {
			de: 'Datei',
			en: 'File',
		},
		help: {
			de: '? Hilfe Doku',
			en: '? Help Doc',
		},
		helplink: {
			de: 'https://shyrodgau.github.io/imbraw2dng/README_de',
			en: 'https://shyrodgau.github.io/imbraw2dng/',
		},
		generaladvice: {
			de: 'Kann sein, dass der Browser fragt, ob Sie zulassen wollen, dass mehrere Dateien heruntergeladen werden.<br>Dateien, die nicht oder unbekannte RAW-Dateien sind, werden 1:1 kopiert.',
			en: 'Browser may ask you if you want to allow downloading multiple files.<br>Not or unrecognized RAW Files simply will be copied.',
		},
		drophere: {
			de: 'Datein von ImB hier ablegen: ',
			en: 'Drop Files from ImB here: ',
		},
		selectraw: {
			de: 'Oder diese Datei per WLAN von ImB direkt verwenden<br>Oder <b>.raw</b> Datei(en) auswählen:',
			en: 'Or use this file via Wifi directly from ImB.<br> Or select <b>.raw</b> File(s):',
		},
		stillcounting: {
			de: '... zähle ... ',
			en: '... counting ... ',
		},
		types: {
			rawpics: {
				de: 'RAW Bilder',
				en: 'RAW Pictures',
			},
			jpgpics: {
				de: 'JPEG-Bilder',
				en: 'JPEG Pictures',
			},
			other: {
				de: 'Andere',
				en: 'Other',
			},
			notpic: {
				de: 'Keine Bilder',
				en: 'Not pictures',
			}
		},
		file: {
			jpeg: {
				de: 'Datei $$0 (JPEG)',
				en: 'File $$0 (JPEG)',
			},
			nopreview: {
				de: 'Datei $$0<br>Nicht jpeg oder raw, keine Vorschau...',
				en: 'File $$0<br>Not jpeg or raw, no preview...',
			},
			rawunknown: {
				de: 'Datei $$0<br>Unerkannte RAW Dateigröße $$1, bitte Entwickler kontaktieren! Keine Vorschau...',
				en: 'File $$0<br>Unknown raw size $$1, please contact developer! No preview...'
			},
			de: 'Datei $$0',
			en: 'File $$0',
		},
		sort: {
			de: 'Sortiere',
			en: 'Sort:'
		},
		or: {
			de: 'Oder ',
			en: 'Or '
		},
		reload: {
			de: 'Seite ab und zu neu laden, um Speicher freizugeben.',
			en: 'Reload page from time to time to free memory.'
		},
		log: {
			de: 'Protokoll-Ausgabe:',
			en: 'Message Log:'
		},
		selected: {
			de: 'Ausgewählt',
			en: 'Selected'
		}
	},
	browser: {
		bytype: {
			de: 'nach Typ',
			en: 'by type'
		},
		olderfirst: {
			de: 'Ältere nach oben',
			en: 'Older first'
		},
		selall: {
			tooltip: {
				de: 'Wenn Haken nicht gesetzt, wähle alles aus. Bei Klick wenn angehakt setze Auswahl auf Nichts.',
				en: 'If not selected then select all. If it is selected and clicked then unselect all.'
			},
			de: 'Alle de-/ oder selektieren',
			en: 'De-/select all'
		},
		procall: {
			de: 'Alle ausgewählte kopieren/verarbeiten',
			en: 'Copy/process all selected'
		},
		delall: {
			de: 'Alle ausgewählte löschen',
			en: 'Delete all selected'
		}
	},
	onimback: {
		connected: {
			de: 'ImB Verbunden!! <br>',
			en: 'ImB Connected! <br>'
		},
		dlconvert: {
			de: 'Konvertiere / Lade herunter: ',
			en: 'Download / convert: '
		},
		totalnum: {
			de: 'gesamt:',
			en: 'total:'
		},
		fromtime: {
			de: 'ab Zeitstempel bzw. jünger als ',
			en: 'from timestamp or younger than '
		},
		nullforall: {
			de: '0000 oder leer für "alle"',
			en: '0000 or empty for "all"'
		},
		doit: {
			de: 'Mach es',
			en: 'Do it'
		},
		visual: {
			de: 'Bild-Browser benutzen',
			en: 'Use visual Picture Browser'
		}
	},
	process: {
		singlestep: {
			de: 'Einzelschritt mit Vorschau',
			en: 'Single Step with preview'
		},
		addlink: {
			de: 'Extra Download-Link an jeder Datei',
			en: 'Add separate download link for each file'
		},
		maycostmem: {
			de: 'Dies könnte Speicher kosten und wird daher von Hause aus nicht mehr angeboten. Man kann einfach nochmal die gleiche(n) Datei(en) auswählen.',
			en: 'This may cost memory and is thus no longer by default. Simply select the file(s) again.'
		},
		nothing: {
			de: 'Nichts ausgewählt.. ?',
			en: 'Nothing selected...?'
		},
		erraccess: {
			de: '<b>Fehler beim Zugriff auf $$0. ENTSCHLDIGUNG! </b>',
			en: '<b>Error occured accessing $$0. SORRY! </b>'
		},
		notraw: {
			de: 'Durchleitung weil nicht raw: $$0<br>',
			en: 'Passing through as not raw: $$0<br>'
		},
		selectedn: {
			de: '$$0 Datei(en) wurden ausgewählt.<br>&nbsp;<br>',
			en: 'Got $$0 file(s) selected.<br>&nbsp;<br>'
		},
		copyok: {
			de: '<b style="background-color:#ddffdd;">Fertig! Nach $$0 kopiert (Downloads-Ordner prüfen)</b>&nbsp;',
			en: '<b style="background-color:#ddffdd;">Finished! Copied to $$0 (Check Downloads Folder)</b>&nbsp;'
		},
		dlagain: {
			de: '<a download="$$0\" href=\"$$1">Nochmal händisch herunterladen</a>',
			en: '<a download="$$0\" href=\"$$1">Manually download again</a>'
		},
		dlagaindng: {
			de: '<a type="image/x-adobe-dng" download="$$0dng" href="$$1">Nochmal händisch herunterladen</a>&nbsp;',
			en: '<a type="image/x-adobe-dng" download="$$0dng" href="$$1">Manually download again</a>&nbsp;'
		},
		errorreadingfile: {
			de: '<b style="background-color:#ffdddd;">Fehler beim Lesen der Datei $$0. ENTSCHULDIGUNG! </b><br>&nbsp;<br>',
			en: '<b style="background-color:#ffdddd;">Error occured reading file $$0. SORRY! </b><br>&nbsp;<br>'
		},
		unknownsize: {
			de: '<b style="background-color:#ffdddd;">[$$0] Entschuldigung, die Dateigröße <b>$$1</b> passt zu keinem bekannten Format. Bitte Entwickler kontaktieren!</b><br>',
			en: '<b style="background-color:#ffdddd;">[$$0] Sorry, file Size <b>$$1</b> does not match known formats. Please contact developer!</b><br>'
		},
		processing: {
			de: 'Verarbeite Datei: $$0 <br>',
			en:'Processing file: $$0<br>'
		},
		assuming: {
			de: 'Annahme: $$0 $$1<br>',
			en: 'Assuming $$0 $$1<br>'
		},
		datetime: {
			de: 'Datum/Zeit: $$0<br>',
			en: 'Date/Time: $$0 <br>'
		},
		orientation: {
			de: 'Drehung: ',
			en: 'Orientation: '
		},
		converted: {
			de: '<b style=\"background-color:#ddffdd;\">Fertig! Nach $$0dng konvertiert (Downloads-Ordner prüfen)</b>&nbsp;',
			en: '<b style=\"background-color:#ddffdd;\">Finished! Converted to $$0dng (Check Downloads Folder)</b>&nbsp;'
		},
		droppedn: {
			de: '$$0 Datei(en) wurden abgelegt.',
			en: 'Got $$0 file(s) dropped.'
		},
		frombackn: {
			de: '$$0 Datei(en) vom ImB zu verarbeiten.<br>&nbsp;<br>',
			en: 'Got $$0 file(s) from ImB.<br>&nbsp;<br>'
		},
		frombrowsern: {
			de: '$$0 Datei(en) vom Bild-Browser zu verarbeiten.<br>&nbsp;<br>',
			en: 'Got $$0 file(s) from Visual browser.<br>&nbsp;<br>'
		},
		skipped: {
			remaining: {
				de: 'Verbleibende $$0 Dateien auf Anforderung übersprungen',
				en: 'Skipping remaining $$0 images at your request'
			},
			de: 'Auf Anforderung übersprungen: $$0',
			en: 'Skipped at your request: $$0'
		}
	},
	preview: {
		err: {
			de: 'Fehler bei Vorschau :-(',
			en: 'Error with Preview :-('
		},
		rotcw: {
			de: 'im Uhrzeigersinn drehen',
			en: 'Rotate clockwise',
			tooltip: {
				de: 'Originalbild um 90° im Uhrzeigersinn drehen',
				en: 'Rotate original image by 90&deg; clockwise'
			}
		},
		rotccw: {
			de: 'gegen den Uhrzeigersinn drehen',
			en: 'rotate counterclockwise',
			tooltip: {
				de: 'Originalbild um 90° gegen den Uhrzeigersinn drehen',
				en: 'Rotate original image by 90&deg; counterlockwise'
			}
		},
		rot180: {
			de: 'auf den Kopf',
			en: 'Rotate 180&deg;',
			tooltip: {
				de: 'Originalbild auf den Kopf stellen',
				en: 'Rotate original image by 180&deg; upside down'
			}
		},
		rotreset: {
			de: 'Drehung zurücksetzen',
			en: 'Reset',
			tooltip: {
				de: 'Ursprüngliche Bildausrichtung wiederherstellen',
				en: 'Reset original image orientation'
			}
		},
		process: {
			de: 'Kopieren/Konvertieren',
			en: 'Copy/Convert'
		},
		skip: {
			de: 'Überspringen',
			en: 'Skip'
		},
		/*wait: {
			de: 'w a r t e . . .',
			en: 'w a i t . . .'
		},*/
		forall: {
			de: 'Für alle weiteren das selbe',
			en: 'Do this for all following'
		},
		orients: {
			none: {
				de: 'keine',
				en: 'none'
			},
			upsidedown: {
				de: '180°',
				en: '180°'
			},
			clockwise: {
				de: 'im Uhrzeigersinn',
				en: 'clockwise'
			},
			counterclockwise: {
				de: 'gegen den Uhrzeigersinn',
				en: 'counterclockwise'
			}
		}
	},
	raw: {
		unknownsize: {
			de: 'Unerkannte RAW-Dateigröße, Entwickler kontaktieren',
			en: 'Unrecognized RAW file size, contact developer'
		},
	},
	selection: {
		got: {
			de: '$$0 Dateien wurden ausgewählt.',
			en: 'Got $$0 files selected.'
		},
	},
	delete: {
		question: {
			en: 'Deleting can not be undone! Are you sure you want to continue?',
			de: 'Löschen kann nicht rückgängig gemacht werden. Sicher damit weitermachen?',
			ok: {
				de: 'Ok',
				en: 'Ok'
			},
			cancel: {
				de: 'Abbrechen',
				en: 'Cancel'
			}
		},
		nostatus: {
			de: 'Der Status des Löschens kann nicht sicher geprüft werden. Bitte laden Sie die Seite nach dem Löschen neu.',
			en: 'The status of the delete can not be checked safely. Reload the page after deleting.'
		},
		reload: {
			de: 'Bitte Seite neu laden.',
			en: 'Please reload page.'
		}
	}
};
/* Data for the Imback variants and exif stuff */
const orients = [ '', 'none', '', 'upsidedown', '', '', 'clockwise', '', 'couterclockwise' ];
const types = [ "unknown", "ImB35mm", "MF 6x7 ", "MF6x4.5", "MF 6x6 " ];
const infos = [
	{
		size: 14065920,
		w: 4320,
		h: 3256,
		typ: 0,
		mode: "historic (4320x3256)"
	},
	{
		size: 15925248,
		w: 4608,
		h: 3456,
		typ: 2,
		mode: "(4608x3456)"
	},
	{
		size: 12076120, // guessed
		w: 4012,
		h: 3010,
		typ: 2,
		mode: "Medium-angle (4012x3010)"
	},
	{
		size: 7967440, // guessed
		w: 3260,
		h: 2444,
		typ: 2,
		mode: "Small-angle (3260x2444)"
	},
	{
		size: 12937632,
		w: 4152, h: 3116,
		typ: 3,
		mode: "(4152x3116)"
	},
	{
		size: 9806592,
		w: 3616, h: 2712,
		typ: 3,
		mode: "Medium-angle (2616x2717)"
	},
	{
		size: 6470944,
		w: 2936, h: 2204,
		typ: 3,
		mode: "Small-angle (2936x2204)"
	},
	{
		size: 11943936,
		w: 3456, h: 3456,
		typ: 4,
		mode: "(3456x3456)"
	},
	{
		size: 9060100, // guessed
		w: 3010, h: 3010,
		typ: 4,
		mode: "Medium-angle (3010x3010)"
	},
	{
		size: 5973136, // guessed
		w: 2444, h: 2444,
		typ: 4,
		mode: "Small-angle (2444x2444)"
	},
	{
		size: 15335424,
		w: 4608, h: 3328,
		typ: 1,
		mode: "(4608x3328)"
	},
	{
		size: 11618752,
		w: 4012, h: 2896,
		typ: 1,
		mode: "Medium-angle (4012x2896)"
	},
	{
		size: 7667520,
		w: 3260, h: 2352,
		typ: 1,
		mode: "Small-angle (3260x2352)"
	}
];
/* For processing several files */
let totnum=0, actnum=0;
let allfiles = [];
let addlinkbool = false;
let stepmode = 0; // 0 always save (if not checkbox or "save all" in dialog), 1 always ask (set on checkbox), 2 skip all (if selected in dialog)
// current preview image
let currentrot = 1;
// from the back itself
let imbpics = [], rimbpics = [], imbmovies = [], imbeles = [], typedclasses = [], untypedclasses = [];
let earliestmov = '9999', latestmov='0000', earliestjpg='9999', latestjpg='0000',earliestraw='9999',latestraw='0000';
let todolist = [];
/* debug */
const debugflag = false;
let firstflag = true;
/* helper to append message */
function appendmsg(msg) {
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	msgel.innerHTML += msg;
}
/* helper to append message */
function appendmsgx(msg) {
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	msgel.append(msg);
}
/* helper function to put integer into dng */
function writeinttoout(out, num, off) {
	out[off] = (num % 256);
	out[off + 1] = (num / 256) % 256;
	out[off + 2] = (num / 65536) % 256;
	out[off + 3] = (num / 16777216) % 256;
}
/* handler for file selection input */
function fselected() {
	if (actnum !== allfiles.length) return;
    const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) addlinkbool = addlinkel.checked;
    const stepprev = document.getElementById('steppreview');
    stepmode = 0;
	if (stepprev !== null && stepprev.checked) stepmode = 1;
	const el = document.getElementById('infile');
	totnum = el.files.length;
	actnum = 0;
	allfiles = el.files;
	//if (totnum > 0) {
		mappx('process.selectedn', totnum);
		//appendmsg("Got " + totnum + " files selected.<br>&nbsp;<br>");
	//}
	handleonex();
}
/* continue with the next file */
function handlenext() {
	// if (undefined !== allfiles[actnum]) allfiles[actnum] = undefined;
	if (actnum < allfiles.length - 1) {
		actnum++;
		handleonex();
	} else {
		actnum = 0;
		allfiles = [];
		shownormal();
	}
}
/* as it says */
function showreloadhints() {
	const rl1 = document.getElementById('reloadhint');
	if (null !== rl1) rl1.style['display'] = '';
	const rl2 = document.getElementById('reloadhint2');
	if (null !== rl2) rl2.style['display'] = '';
}
/* switch preview config to jpeg img */
function setjpegpv() {
	document.getElementById('jpegpreview').style['display'] = '';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
}
/* switch preview config to err */
function setpverr() {
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = '';
	document.getElementById('preview').style['display'] = 'none';
}
/* switch preview config to wait */
function setpvwait() {
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='none';
	document.getElementById('previewwait').style['display'] = '';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
}
/* file/filereader like interface for imback http */
function createFx(url, onok, onerr) {
	let fx = {
		imbackextension: true,
		name: url
	};
	xhr = new XMLHttpRequest();
	xhr.responseType = 'arraybuffer';
	xhr.onload = function(evt) {
		fx.data = xhr.response;
		fx.size = xhr.response.byteLength;
		fx.readAsArrayBuffer = function(fy) {
			fy.onload({
				target: {
					result: fy.data
				}
			});
		};
		onok(url, fx);
	};
	xhr.onerror = function(evt) {
		onerr(url);
	};
	xhr.open('GET', url);
	xhr.send();
}
function enablerots(which) {
	for (const rots in [ 'procthiscw', 'procthisccw', 'procthisud', 'procthisrs' ]) {
		if (which === rots)
			document.getElementById(which).disabled = true;
		else
			document.getElementById(which).disabled = false;
	}
}
/* main handler function for one file */
function handleonex() {
	const f = allfiles[actnum];
	document.getElementById('doforall').checked = false;
	currentrot = 1;
	enablerots('procthisrs');
	if (actnum < totnum-1) {
		document.getElementById('forrest').style['display'] = '';
	} else document.getElementById('forrest').style['display'] = 'none';
	let rawname = f.name ? f.name : f;
	while (rawname.indexOf("/") > -1) {
		rawname = rawname.substring(rawname.indexOf("/") + 1);
	}
	if (stepmode === 2) {
		shownormal();
		return handlenext();
	}
	else if (stepmode === 1) {
		// show preview and ask for rotation, skip, save
		// then (in handler) set mode, call handleone (if save) or handlenext (if skip)
		showquestion();
		const f = allfiles[actnum];
		if (undefined === f) {
			return;
		}
		if (totnum > 1) {
			document.getElementById('qhdr').innerHTML = '[' + (1+actnum) + ' / ' + totnum + '] ';
		} else document.getElementById('qhdr').innerHTML = '';
		if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG' ||
			rawname.substring(rawname.length -5).toUpperCase() === '.JPEG') {
			/* jpeg preview */
			qappx('main.file.jpeg', rawname);
			if (f.name) {
				const fr = new FileReader();
				fr.onload = function(evt) {
					let contents = evt.target.result;
					contents = 'data:image/jpeg;' + contents.substring(8);
					document.getElementById('jpegpreview').src = contents;
					/* shown in onload of img */
				}
				fr.onerror = function(evt) {
					setpverr();
				}
				fr.readAsDataURL(f);
			}
			else {
				document.getElementById('jpegpreview').src = f;
			}
		}
		else if (rawname.substring(rawname.length -4).toUpperCase() !== '.RAW') {
			/* no preview */
			qappx('main.file.nopreview', rawname);
			setnopv();
		}
		else {
			const zz = infos.findIndex((v, i, o) => v.size === f.size);
			if (zz === -1 && undefined !== f.size) {
				/* no preview */
				qappx('main.file.rawunknown', rawname, f.size);
				setnopv();
			} else {
				qappx('main.file',rawname);
				buildpreview(f, () => { setrawpv(); }, () => { setpverr(); });
			}
		}
	}
	else { // normal processing without question
		shownormal();
		handleone();
	}
}
/* xl helper */
function genspan(key, arg0, arg1, arg2, arg3) {
	const s = document.createElement('span');
	s.setAttribute('data-myxlkey', key);
	s.setAttribute('data-myxloff', '' + xlargs.length);
	let n=0;
	if (undefined !== arg0) {
		xlargs.push(arg0);
		n++;
		if (undefined !== arg1) {
			xlargs.push(arg1);
			n++;
			if (undefined !== arg2) {
				xlargs.push(arg2);
				n++;
				if (undefined !== arg3) {
					n++;
					xlargs.push(arg3);
				}
			}
		}
	}
	s.setAttribute('data-myxlnnn', '' + n);
	return s;
}

/* translated append to preview header */
function qappx(key, arg0, arg1, arg2, arg3) {
	const s = genspan(key, arg0, arg1, arg2, arg3);
	document.getElementById('qhdr').append(s);
	xlateall();
}
/* translated append to main log */
function mappx(key, arg0, arg1, arg2, arg3) {
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	const s = genspan(key, arg0, arg1, arg2, arg3);
	msgel.append(s);
	xlateall();
}
/* actual processing function for one file */
function handleone(orientation) {
	const f = allfiles[actnum];
	if (undefined === f) {
		mappx('process.nothing');
		appendmsg('<br>&nbsp;<br>');
		return handlenext();
	}
	if (undefined === f.size) {
		createFx(f, (url, fx) => {
				allfiles[actnum] = fx;
				handleone(orientation);
			}, (url) => {
				mappx('process.erraccess', url);
				appendmsg("<br>&nbsp;<br>");
				handlenext();
		});
		return;
	}
	let rawname = f.name;
	while (rawname.indexOf("/") > -1) {
		rawname = rawname.substring(rawname.indexOf("/") + 1);
	}
	if (rawname.substring(rawname.length -4).toUpperCase() !== '.RAW') {
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = function(evt) {
			if (totnum > 1) {
				appendmsg("[" + (1+actnum) + " / " + totnum + "] ");
			}
			mappx('process.notraw',rawname);
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<contents.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			const b = new Blob([ out ], { type: "application/octet-stream"});
			const outel = document.getElementById('result');
			outel.download = rawname;
			const thisurl = URL.createObjectURL(b);
			outel.href = thisurl;
			outel.click();
			mappx('process.copyok', rawname);
			if (addlinkbool) {
				mappx('process.dlagain', rawname, thisurl);
				showreloadhints();
			}
			appendmsg("<br>&nbsp;<br>");
			handlenext();
		}
		reader.onerror = function(evt) {
			mappend('process.errorreadingfile', f.name);
			handlenext();
		}
		reader.readAsArrayBuffer(f);
		return;
	}
	let w, h, mode = "??";
	let typ = 0;
	const zz = infos.findIndex((v, i, o) => v.size === f.size);
	if (zz === -1) {
		if (totnum > 1) {
			appendmsg("[" + (1+actnum) + " / " + totnum + "] ");
		}
		mappx('process.unknownsize', f.name, f.size);
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = function(evt) {
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<contents.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			const b = new Blob([ out ], { type: "application/octet-stream"});
			const outel = document.getElementById('result');
			outel.download = rawname;
			const thisurl = URL.createObjectURL(b);
			outel.href = thisurl;
			outel.click();
			mappx('process.copyok', rawname);
			if (addlinkbool) {
				mappx('process.dlagain', rawname, thisurl);
				showreloadhints();
			}
			appendmsg("<br>&nbsp;<br>");
			handlenext();
		}
		reader.onerror = function(evt) {
			mappend('process.errorreadingfile', f.name);
			handlenext();
		}
		reader.readAsArrayBuffer(f);
		return;
	} else {
		w = infos[zz].w;
		h = infos[zz].h;
		mode = infos[zz].mode;
		typ = infos[zz].typ;
	}
	const rawnamearr = new TextEncoder().encode(rawname);
	let datestr="", dateaddoff = 0, dateok = false;
	// date?
	const yr = Number.parseInt(rawname.substring(0,4));
	if (yr >= 2019 && yr < 3000 && JSON.stringify(yr) === rawname.substring(0,4)) {
		let mon = Number.parseInt(rawname.substring(5,7));
		if (mon > 0 && mon < 13 && (JSON.stringify(mon) === ((mon < 10) ? rawname.substring(6,7) : rawname.substring(5,7)))) {
			let day = Number.parseInt(rawname.substring(7,9));
			if (day > 0 && day < 32 && (JSON.stringify(day) === ((day < 10) ? rawname.substring(8,9) : rawname.substring(7,9)))) {
				let hr = Number.parseInt(rawname.substring(10,12));
				if (hr >= 0 && hr < 25 && (JSON.stringify(hr) === ((hr < 10) ? rawname.substring(11,12) : rawname.substring(10,12)))) {
					let min = Number.parseInt(rawname.substring(12,14));
					if (min >= 0 && min <= 60 && (JSON.stringify(min) === ((min < 10) ? rawname.substring(13,14) : rawname.substring(12,14)))) {
						let sec = Number.parseInt(rawname.substring(14,16));
						if (sec >= 0 && sec <= 60 && (JSON.stringify(sec) === ((sec < 10) ? rawname.substring(15,16) : rawname.substring(14,16)))) { // maybe leap second?
							datestr = "" + yr + ":" + ((mon < 10) ? "0":"") + mon + ":" + ((day < 10) ? "0":"") + day + " "+
							((hr < 10) ? "0":"") + hr + ":" + ((min < 10) ? "0":"") + min + ":" + ((sec < 10) ? "0":"") + sec;
							if (datestr.length === 19) {
								dateaddoff = 24;
								dateok = true;
							}
						}
					}
				}
			}
		}
	}
	const reader = f.imbackextension ? f : new FileReader();
	reader.onload = function(evt) {
		if (totnum > 1) {
			appendmsg("[" + (1+actnum) + " / " + totnum + "] ");
		}
		mappx('process.processing', rawname);
		mappx('process.assuming', types[typ], mode);
		if (dateok) {
			mappx('process.datetime', datestr);
		}
		if (orientation !== undefined && orientation !== 1) {
			mappx('process.orientation');
			appendmsgx(genspan('preview.orients.' + orients[orientation]));
			appendmsg('<br>');
		}
		/* Here comes the actual building of the DNG */
		const contents = evt.target.result;
		const view = new DataView(contents);
		const out = new Uint8Array(f.size + (dateok ? 466: 422));
		out[0] = 0x49;
		out[1] = 0x49;
		out[2] = 0x2a;
		out[3] = 0;
		writeinttoout(out, 8 + f.size, 4);
		let k = 8;
		for (let j=0; j<contents.byteLength; j++) {
			out[k++] = view.getUint8(j);
		}
		if (dateok)
			out[k++] = 0x19;
		else
			out[k++] = 0x17;
		const rest0 = [
			0x00, 0xfe, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00
		]; /* followed by 4b width */
		out.set(rest0, k);
		k += rest0.length;
		writeinttoout(out, w, k);
		k += 4;

		const rest1 = [
			0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00
		]; /* followed by 4b height */
		out.set(rest1, k);
		k += rest1.length;
		writeinttoout(out, h, k);
		k += 4;

		const rest2 = [ 0x02, 0x01,
			0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x23, 0x80,
			0x00, 0x00, 0x0f, 0x01, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00 ];
		out.set(rest2, k);
		k += rest2.length;
		writeinttoout(out, f.size + (dateaddoff + 290), k);
		k += 4;

		const rest3 = [ 0x10, 0x01, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00 ];
		out.set(rest3, k);
		k += rest3.length;
		writeinttoout(out, f.size + (dateaddoff + 298), k);
		k += 4;

		const rest4 = [ 0x11, 0x01, 0x04, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x12, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00 ];
		out.set(rest4, k);
		k += rest4.length;
		if (undefined === orientation) {
			writeinttoout(out, 1, k);
		} else writeinttoout(out, orientation, k);
		k += 4;
		const rest4b = [ 0x15, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x17, 0x01,
			0x04, 0x00, 0x01, 0x00, 0x00, 0x00 ];
		out.set(rest4b, k);
		k += rest4b.length;
		writeinttoout(out, f.size, k);
		k += 4;

		const rest5 = [ 0x1c, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x31, 0x01, 0x02, 0x00, 0x0b, 0x00, 0x00, 0x00 ];
		out.set(rest5, k);
		k += rest5.length;
		writeinttoout(out, f.size + (dateaddoff + 306), k);
		k += 4;

		if (dateok) { // one datetime tag
			const rest5a = [ 0x32, 0x01, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00 ];
			out.set(rest5a, k);
			k += rest5a.length;
			writeinttoout(out, f.size + 446, k);
			k += 4;
		}

		const rest6 = [ 0x8d, 0x82, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x8e, 0x82, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00 ];
		out.set(rest6, k);
		k += rest6.length;
		const cfa35 = [ 0x01, 0x00, 0x02, 0x01 ];
		const cfamf = [ 0x02, 0x01, 0x01, 0x00 ]
		if (typ > 1) // color filter array depends on type
			out.set(cfamf, k);
		else
			out.set(cfa35, k);
		k += cfa35.length; // both have same length

		if (dateok) { // other datetime tag
			const rest6a = [ 0x03, 0x90, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00 ];
			out.set(rest6a, k);
			k += rest6a.length;
			writeinttoout(out, f.size + 446, k);
			k += 4;
		}
		const rest6b = [ 0x12, 0xc6, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x13, 0xc6, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x14, 0xc6, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00 ];
		out.set(rest6b, k);
		k += rest6b.length;
		writeinttoout(out, (dateaddoff + 318) + f.size, k);
		k += 4;

		const rest7 = [ 0x1d, 0xc6, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x21, 0xc6, 0x0a, 0x00, 0x09, 0x00, 0x00, 0x00 ];
		out.set(rest7, k);
		k += rest7.length;
		writeinttoout(out, (dateaddoff + 326) + f.size, k);
		k += 4;

		const rest8 = [ 0x28, 0xc6, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00 ];
		out.set(rest8, k);
		k += rest8.length;
		writeinttoout(out, (dateaddoff + 398) + f.size, k);
		k += 4;

		const rest8b = [ 0x8b, 0xc6, 0x01, 0x00 ];
		out.set(rest8b, k);
		k += rest8b.length;
		writeinttoout(out, rawnamearr.length, k);
		k += 4;
		writeinttoout(out, (dateok ? 466: 422) + f.size, k);
		k += 4;

		const rest9 = [ 0x00, 0x00, 0x00, 0x00, 0x49, 0x6d, 0x42, 0x61, 0x63, 0x6b, 0x00, 0x00 ];
		out.set(rest9, k);
		k += rest9.length;
		out.set(new TextEncoder().encode(types[typ]), k);
		k += 7;

		const rest10a = [ 0x00, 0x69, 0x6d, 0x62, 0x72, 0x61, 0x77, 0x32, 0x64, 0x6e, 0x67,
			0x00, 0x00, 0x49, 0x6d, 0x42, 0x61, 0x63, 0x6b, 0x00, 0x00 ];
		out.set(rest10a, k);
		k += rest10a.length;

		const rest10b = [ 0xff, 0xff, 0xff, 0x7f, 0xf4, 0xb6,
			0x6d, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0xf4, 0xb6,
			0x6d, 0x5b ];
		out.set(rest10b, k);
		k += rest10b.length;

		const rest10c = [ 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff ];
		out.set(rest10c, k);
		k += rest10c.length;

		if (dateok) { // datetime value
			const datearr = new TextEncoder().encode(datestr);
			out.set(datearr, f.size + 446);
			out[f.size + 465] = 0;
		}
		const b = new Blob([ out, rawnamearr ], { type: "image/x-adobe-dng"});
		const outel = document.getElementById('result');
		outel.download = rawname.substring(0, rawname.length - 3) + 'dng';
		const thisurl = URL.createObjectURL(b);
		outel.href = thisurl;
		outel.click();
		mappx('process.converted', rawname.substring(0, rawname.length - 3));
		if (addlinkbool) {
			mappx('process.dlagaindng', rawname.substring(0, rawname.length - 3), thisurl);
			showreloadhints();
		}
		appendmsg("<br>&nbsp;<br>");
		handlenext();
	};
	reader.onerror = function(evt) {
		mappend('process.errorreadingfile', f.name);
		handlenext();
	};
	reader.readAsArrayBuffer(f);
}
/* handler function for dropping OS files into the rect */
function drophandler(ev) {
	if (actnum !== allfiles.length) return;
	const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) addlinkbool = addlinkel.checked;
    const stepprev = document.getElementById('steppreview');
    stepmode = 0;
	if (stepprev !== null && stepprev.checked) stepmode = 1;
	ev.preventDefault();
	allfiles = [];
	actnum = 0;
	if (ev.dataTransfer.items) {
		//appendmsg("Got " + [...ev.dataTransfer.items].length + " files dropped.<br>&nbsp;<br>");
		totnum = [...ev.dataTransfer.items].length;
		mappx('process.droppedn', totnum);
		[...ev.dataTransfer.items].forEach((item, i) => {
			if (item.kind === "file") {
				const file = item.getAsFile();
				allfiles.push(item.getAsFile());
			}
		});
	} else {
		//appendmsg("Got " + [...ev.dataTransfer.files].length + " files dropped.<br>&nbsp;<br>");
		totnum = [...ev.dataTransfer.files].length;
		mappx('process.droppedn', totnum);
		[...ev.dataTransfer.files].forEach((file, i) => {
			allfiles.push(file);
		});
	}
	appendmsg("<br>&nbsp;<br>");
	handleonex();
}
/* some handler on the drop rectangle */
function prevdef(ev) {
	ev.preventDefault();
}
/* get one downsampled median image value [ r g b ] */
function getPix(x, y, w, view, typ) {
	let outrgb = [];
	let reds = [];
	if (typ > 1) {
		reds.push(view.getUint8((y+1)*w + x + 1));
		reds.push(view.getUint8((y+1)*w + x + 3));
		reds.push(view.getUint8((y+1)*w + x + 2*w + 1));
		reds.push(view.getUint8((y+1)*w + x + 2*w + 3));
	} else {
		reds.push(view.getUint8(y*w + x + 1));
		reds.push(view.getUint8(y*w + x + 3));
		reds.push(view.getUint8(y*w + x + 2*w + 1));
		reds.push(view.getUint8(y*w + x + 2*w + 3));
	}
	reds.sort(function(a,b) { return a - b; });
	// median of red pixels
	outrgb.push((reds[1] + reds[2]) / 2.0);
	let greens = [];
	if (typ > 1) {
		greens.push(view.getUint8(y*w + x + 1));
		greens.push(view.getUint8(y*w + x + w));
		greens.push(view.getUint8(y*w + x + 3));
		greens.push(view.getUint8(y*w + x + 2 + w));
		greens.push(view.getUint8(y*w + x + 2*w + 1));
		greens.push(view.getUint8(y*w + x + 3*w));
		greens.push(view.getUint8(y*w + x + 2*w + 3));
		greens.push(view.getUint8(y*w + x + 3*w + 2));
	} else {
		greens.push(view.getUint8(y*w + x));
		greens.push(view.getUint8(y*w + x + w + 1));
		greens.push(view.getUint8(y*w + x + 2));
		greens.push(view.getUint8(y*w + x + 3 + w));
		greens.push(view.getUint8(y*w + x + 2*w));
		greens.push(view.getUint8(y*w + x + 3*w +1));
		greens.push(view.getUint8(y*w + x + 2*w + 2));
		greens.push(view.getUint8(y*w + x + 3*w + 3));
	}
	greens.sort(function(a,b) { return a - b; });
	outrgb.push((greens[3] + greens[4]) / 2.0);
	let blues = [];
	if (typ > 1) {
		blues.push(view.getUint8(y*w + x));
		blues.push(view.getUint8(y*w + x + 2));
		blues.push(view.getUint8(y*w + x + 2*w));
		blues.push(view.getUint8(y*w + x + 2*w + 2));
	} else {
		blues.push(view.getUint8((y+1)*w + x));
		blues.push(view.getUint8((y+1)*w + x + 2));
		blues.push(view.getUint8((y+1)*w + x + 2*w));
		blues.push(view.getUint8((y+1)*w + x + 2*w + 2));
	}
	blues.sort(function(a,b) { return a - b; });
	outrgb.push((blues[1] + blues[2]) / 2.0);
	return outrgb;
}
/* put preview into canvas */
// orientation: 1: norm, 3: rot 180, 6 rot 90 CW, 8: rot 270 CCW
function buildpreview(f, onok, onerr, orientation, targ, afterload) {
	let w, h, typ;
	if (undefined === f.size) {
		createFx(f, (url, fx) => {
				buildpreview(fx, onok, onerr, orientation, targ, afterload);
			}, (url) => {
				onerr(f);
		});
		return;
	}
	const zz = infos.findIndex((v, i, o) => v.size === f.size);
	if (zz === -1) {
		console.log('preview: unsupported size ' + f.size + ' of ' + f.name);
		onerr(f);
		return;
	} else {
		w = infos[zz].w;
		typ = infos[zz].typ;
		h = infos[zz].h;
	}
	let canv;
	if (undefined !== targ)
		canv = targ;
	else
		canv = document.getElementById('preview');
	const w8 = Math.floor((w+7)/8) - 1;
	const h8 = Math.floor((h+7)/8) - 1;
	canv.width = w8;
	canv.height = h8;
	if (orientation === 6 || orientation === 8) {
		canv.width = h8;
		canv.height = w8;
	}
	const ctx = canv.getContext('2d', { alpha: false });
	if (undefined !== targ) {
		const sc = 120 / canv.height;
		//ctx.scale(sc, sc);
		//canv.height = 100;
		//canv.width *= sc;
		canv.style['width'] = '' + (sc*canv.width) + 'px';
	}
	const reader = f.imbackextension ? f : new FileReader();
	reader.onload = function(evt) {
		if (undefined !== afterload) afterload();
		const contents = evt.target.result;
		const view = new DataView(contents);
		let minred=255, minblue = 255, mingreen = 255, maxred = 0, maxblue = 0, maxgreen = 0, allmin = 255, allmax = 0;
		let outpix = [];
		let rowiterstart, rowiterend;
		let coliterstart, coliterend;
		let transpose = false;
		if (orientation === 3) {
			rowiterstart = -1*(h8 -1);
			rowiterend = 1;
			coliterstart = -1*(w8 - 1);
			coliterend = 1;
		} else if (orientation === 6) {
			transpose = true;
			rowiterstart = 0;
			rowiterend = w8;
			coliterstart = -1*(h8 - 1);
			coliterend = 1;
		} else if (orientation === 8) {
			transpose = true;
			rowiterstart = -1*(w8 -1);
			rowiterend = 1;
			coliterstart = 0;
			coliterend = h8;
		} else {
			rowiterstart = 0;
			rowiterend = h8;
			coliterstart = 0;
			coliterend = w8;
		}
		for (let i = rowiterstart; i < rowiterend; i +=1) {
			for (let j = coliterstart; j < coliterend; j+=1) {
				let a = getPix(Math.abs(transpose ? i :j)*8, Math.abs(transpose ? j :i)*8, w, view, typ);
				outpix.push(a[0]);
				if (a[0] > maxred) maxred = a[0];
				if (a[0] < minred) minred = a[0];
				if (a[0] > allmax) allmax = a[0];
				if (a[0] < allmin) allmin = a[0];
				outpix.push(a[1]);
				if (a[1] > maxgreen) maxgreen = a[1];
				if (a[1] < mingreen) mingreen = a[1];
				if (0.6*a[1] > allmax) allmax = a[1] * 0.6;
				if (0.6*a[1] < allmin) allmin = a[1] * 0.6;
				outpix.push(a[2]);
				if (a[2] > maxblue) maxblue = a[2];
				if (a[2] < minblue) minblue = a[2];
				if (a[2] > allmax) allmax = a[2];
				if (a[2] < allmin) allmin = a[2];
				outpix.push(255);
			}
		}
		const fact = 255 / (allmax - allmin);
		for (let i = 0; i < h8; i++) {
			for (let j=0; j< w8; j++) {
				if ((outpix[4*((i * w8) + j)] > 250) &&
					(outpix[4*((i * w8) + j) + 2] > 250) &&
					(outpix[4*((i * w8) + j) + 1] > 0.6 * 250))
				{
					outpix[4*((i*w8) + j) + 1] = 255;
				} else {
					// maybe some brightening gamma?
					const r = (fact * (outpix[4 * ((i*w8) + j)] - allmin));
					outpix[4 * ((i*w8) + j)] = 255-Math.round(255*((255-r)/255)*((255-r)/255));
					const g = (fact * 0.6 * (outpix[4 * ((i*w8) + j) + 1] - allmin* 0.6));
					outpix[4 * ((i*w8) + j) + 1] = 255-Math.round(255*((255-g)/255)*((255-g)/255));
					const b = (fact * (outpix[4 * ((i*w8) + j) + 2] - allmin));
					outpix[4 * ((i*w8) + j) + 2] = 255-Math.round(255*((255-b)/255)*((255-b)/255));
				}
			}
		}
		ctx.putImageData(new ImageData(new Uint8ClampedArray(outpix), transpose ? h8: w8, transpose? w8 :h8), 0, 0);
		onok(f);
	};
	reader.onerror = function(evt) {
		console.log('preview: error reading ' + f.name);
		onerr();
	};
	reader.readAsArrayBuffer(f);
}
/* raw preview okay */
function setrawpv() {
	document.getElementById('preview').style['display'] = '';
	document.getElementById('rotations').style['display'] = '';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = 'none';
}
/* no preview in question */
function setnopv() {
	document.getElementById('preview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = 'none';
}
/* as it says */
function showquestion() {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	quest.style['display'] = '';
	norm.style['display'] = 'none';
	setpvwait();
	document.getElementById('qhdr').innerHTML = '';
	document.getElementById('browser').style['display'] = 'none';
}
/* as it says */
function shownormal() {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	document.getElementById('browser').style['display'] = 'none';
	quest.style['display'] = 'none';
	norm.style['display'] = '';
}
/* as it says */
function showbrowser() {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	document.getElementById('browser').style['display'] = '';
	quest.style['display'] = 'none';
	norm.style['display'] = 'none';
}
/* skip handler in the step preview */
function skipthis() {
	if (document.getElementById('doforall').checked) stepmode = 2;
	if (totnum > 1) {
		appendmsg("[" + (1+actnum) + " / " + totnum + "] ");
	}
	if (document.getElementById('doforall').checked) {
		mappx('process.skipped.remaining', totnum - actnum);
	} else {
		let rawname = allfiles[actnum].name ? allfiles[actnum].name : allfiles[actnum];
		while (rawname.indexOf("/") > -1) 
			rawname = rawname.substring(rawname.indexOf("/") + 1);
		mappx('process.skipped', rawname);
		appendmsg("<br>&nbsp;<br>");
	}
	shownormal();
	handlenext();
}
/* process handler in the step preview */
function procthis() {
	if (document.getElementById('doforall').checked) {
		stepmode = 0;
		shownormal();
	}
	setpvwait();
	handleone(currentrot);
}
/* handler for clockwise rotation */
function rotcw() {
	if (6 === currentrot) return;
	enablerots('procthiscw');
	setpvwait();
	currentrot = 6;
	buildpreview(allfiles[actnum], () => { setrawpv(); }, () => { setpverr(); }, 6);
}
/* handler for counterclockwise rotation */
function rotccw() {
	if (8 === currentrot) return;
	enablerots('procthisccw');
	setpvwait();
	currentrot = 8;
	buildpreview(allfiles[actnum], () => { setrawpv(); }, () => { setpverr(); }, 8);
}
/* handler for upside down rotation */
function rot180() {
	if (3 === currentrot) return;
	enablerots('procthisud');
	setpvwait();
	currentrot = 3;
	buildpreview(allfiles[actnum], () => { setrawpv(); }, () => { setpverr(); }, 3);
}
/* handler for reset rotation */
function rot0() {
	if (1 === currentrot) return;
	enablerots('procthisrs');
	setpvwait();
	currentrot = 1;
	buildpreview(allfiles[actnum], () => { setrawpv(); }, () => { setpverr(); }, 1);
}
/* prepare the browser display, group the stuff */
function aftercheck() {
	if (untypedclasses[0].title) return;
	for (const x of untypedclasses) {
		const cl = {
			title: x,
			level: 5,
			fmembers: []
		};
		cl.entry = document.createElement('div');
		cl.entry.id = 'gg_' + x + '_X';
		cl.entry.classList.add('gg');
		cl.entry.classList.add('ggclosed');
		cl.entry.classList.add('gl5');
		//buildtitle(cl);
		for (const y of imbeles) {
			if (x === y.raw.substring(0,12))
			{
				// todo: sort
				cl.fmembers.push(y);
				y.inuntyped = true;
			}
		}
		untypedclasses.splice(untypedclasses.findIndex((v,i,o) => v === x), 1, cl);
	}
	for (const x of typedclasses) {
		const cl = {
			title: x,
			level: 5,
			fmembers: []
		};
		cl.entry = document.createElement('div');
		cl.entry.id = 'gg_' + x + '_X';
		cl.entry.classList.add('gg');
		cl.entry.classList.add('ggclosed');
		cl.entry.classList.add('gl5');
		//buildtitle(cl);
		for (const y of imbeles) {
			if (x === y.type + y.raw.substring(0,12))
			{
				// todo: sort
				cl.fmembers.push(y);
				y.intyped = true;
			}
		}
		typedclasses.splice(typedclasses.findIndex((v,i,o) => v === x), 1, cl);
	}
	higherclasses(untypedclasses, 9, 5);
	higherclasses(typedclasses, 12, 5);
	// top type classes here
	for (const u of typedclasses.filter((o) => o.level === 2)) {
		if (u.ischild) continue;
		if (typedclasses.filter((o) => u.title.substring(0,3) === o.title.substring(0,3)).length === 1) {
			u.level --;
			u.entry.classList.add('gl' + u.level);
			u.entry.classList.remove('gl' + (u.level + 1));
		} else if (typedclasses.findIndex((o) => o.title === u.title.substring(0,3)) === -1) {
			const cl = {
				title: u.title.substring(0,3),
				level: 1,
				smembers: []
			};
			cl.entry = document.createElement('div');
			cl.entry.id = 'gg_' + u.title.substring(0,3) + '_X';
			cl.entry.classList.add('gg');
			cl.entry.classList.add('ggclosed');
			cl.entry.classList.add('gl1');
			//buildtitle(cl);
			for (const x of typedclasses.filter((o) => u.title.substring(0,3) === o.title.substring(0,3))) {
				x.ischild = true;
				// todo: sort
				cl.smembers.push(x);
				cl.haschildren = true;
				typedclasses.splice(typedclasses.findIndex((o) => o.title === x.title),1);
				//cl.entry.append(x.entry);
			}
			typedclasses.push(cl);
		}
	}
	// non-typed upgraded to gl1, unless only one
	if (untypedclasses.filter((o) => o.level === 2).length === 1 && untypedclasses.filter((o) => o.level === 2)[0].smembers) {
		const t = untypedclasses.filter((o) => o.level === 2)[0];
		untypedclasses.splice(0,1);
		for (const s of t.smembers) {
			s.entry.classList.add('gl1');
			s.level = 2;
			untypedclasses.push(s);
		}
	} else
		for (const s of untypedclasses.filter((o) => o.level === 2)) s.entry.classList.add('gl1');
	// build title elemenes
	for (const s of untypedclasses) buildtitlerec(s);
	for (const s of typedclasses) buildtitlerec(s);
	document.getElementById('brnsel').innerHTML = '0';
	document.getElementById('brntot').innerHTML = '' + imbeles.length;
				/* debug */
				if (debugflag) {
				for (const s of untypedclasses.filter((o) => o.level === 2)) prgr(s,1);
				for (const s of typedclasses.filter((o) => o.level === 1)) prgr(s,1);
				}
}
/* build ordered lists */
function buildtree() {
	let list, toplevel;
	if (document.getElementById('sbytype').checked) {
		list = typedclasses;
		toplevel = 1;
	}
	else {
		list = untypedclasses;
		toplevel = 2;
	}

	// first, make everything empty
	for (const e of untypedclasses) {
		e.entry.remove();
		doclose(e, true);
	}
	for (const e of typedclasses) {
		e.entry.remove();
		doclose(e, true);
	}
	for (const d of imbeles) {
		if (undefined !== d.entry && null !== d.entry)
			d.entry.remove();
	}

	// now, sort and add
	for (const e of list.filter((o) => o.level === toplevel).sort((a,b) => mysort(a, b))) {
		document.getElementById('browser').append(e.entry);
		addsorted(e);
	}
	xlateall();
}
/* sort helper */
function mysort(a, b) {
	const fact = document.getElementById('solder').checked ? 1 : -1
	if (a.title > b.title) return fact;
	else if (a.title < b.title) return -1 * fact;
	else return 0;
}
/* add images sorted  */
function addimgsorted(el) {
	if (el.fmembers !== null && el.fmembers !== undefined) {
		for (const e of el.fmembers.sort((a,b) => mysort(a, b))) {
			if (null === e.entry || undefined === e.entry) displaydiv(e);
			el.entry.querySelector('.igtype').append(e.entry);
		}
	}
}
/* add sorted recursively */
function addsorted(el) {
	if (el.smembers === null || el.smembers ===  undefined) return;
	for (const e of el.smembers.sort((a,b) => mysort(a, b))) {
		addsorted(e);
		el.entry.append(e.entry);
	}
}
/* recursive texts */
function buildtitlerec(el) {
	buildtitle(el);
	if (el.smembers === null || el.smembers ===  undefined) return;
	for (const e of el.smembers) {
		buildtitlerec(e);
	}
}
/* recursive fold close */
function doclose(gr, recurse) {
	gr.entry.querySelector('.ggtt').classList.add('ggttclosed');
	gr.entry.querySelector('.ggtt').classList.remove('ggttopen');
	gr.entry.classList.add('ggclosed');
	gr.entry.classList.remove('ggopen');
	if (recurse && gr.smembers)
		for (const e of gr.smembers) doclose(e, recurse);
}
/* recursive fold open */
function doopen(gr, recurse) {
	gr.entry.querySelector('.ggtt').classList.remove('ggttclosed');
	gr.entry.querySelector('.ggtt').classList.add('ggttopen');
	gr.entry.classList.remove('ggclosed');
	gr.entry.classList.add('ggopen');
	if (recurse && gr.smembers)
		for (const e of gr.smembers) doopen(e, recurse);
	if (gr.fmembers && !gr.entry.querySelector('.ee'))
		addimgsorted(gr);
}
/* select all from top */
function topreccheck() {
	reccheck(document.getElementById('selall').checked);
}
/* select all */
function reccheck(to, root) {
	if (undefined === root) {
		for (const e of typedclasses) reccheck(to, e);
		for (const e of untypedclasses) reccheck(to, e);
		return;
	} else {
		root.entry.querySelector('.selcb').checked = to;
		if (root.fmembers) {
			for (const e of root.fmembers) {
				e.selected = to;
				if (e.entry) e.entry.querySelector('.selcb').checked = to;
			}
		}
		if (root.smembers)
			for (const e of root.smembers) reccheck(to, e);
	}
	updateselections();
}
/* text on a group */
function buildtitle(gr) {
	let t = '', s = gr.title;
	const d = document.createElement('div');
	d.classList.add('ggtt');
	d.classList.add('ggttclosed');
	const pluss = document.createElement('span');
	pluss.classList.add('ggttplus');
	pluss.append('[+]');
	pluss.onclick = () => {
		doopen(gr, false);
	};
	d.append(pluss);
	const pluspluss = document.createElement('span');
	pluspluss.classList.add('ggttplus');
	if (gr.haschildren) {
		pluspluss.append('[++]');
		pluspluss.onclick = () => {
			doopen(gr, true);
		};
	}
	else
		pluspluss.append(' ');
	d.append(pluspluss);
	const minuss = document.createElement('span');
	minuss.classList.add('ggttminus');
	minuss.append('[‒]');
	minuss.onclick = () => {
		d.classList.remove('ggttopen');
		d.classList.add('ggttclosed');
		d.parentElement.classList.remove('ggopen');
		d.parentElement.classList.add('ggclosed');
	};
	d.append(minuss);
	const nixs = document.createElement('span');
	nixs.classList.add('ggttminus');
	nixs.append(' ');
	d.append(nixs);
	if (s.startsWith('JPG') || s.startsWith('RAW')) {
		const sp = document.createElement('span');
		sp.classList.add('gtype');
		sp.append(' ' + s.substring(0,3) + ': ');
		sp.style['display'] = 'none';
		d.append(sp);
		s = s.substring(3);
	} else if (s.startsWith('oth')) {
		const sp = document.createElement('span');
		sp.classList.add('gtype');
		sp.setAttribute('data-myxlkey', 'main.types.notpic');
		sp.style['display'] = 'none';
		d.append(sp);
		s = s.substring(3);
	}
	if (s.length > 0) t += (' ' + s);
	const tit = document.createElement('span');
	tit.classList.add('grtit');
	tit.append(t);
	d.append(tit);
	d.append(' - ');
	d.append(genspan('main.selected'));
	d.append(': ');
	const selno = document.createElement('span');
	selno.id = 'SEL_' + gr.title;
	selno.classList.add('selnumber');
	selno.append('0');
	d.append(selno);
	d.append(' / ');
	const totno = document.createElement('span');
	totno.id = 'TOT_' + gr.title;
	totno.append('' + countfiles(gr));
	d.append(totno);
	d.append(' - ');
	const texttit = document.createElement('label');
	const cb = document.createElement('input');
	cb.type = 'checkbox';
	cb.checked = false;
	cb.classList.add('selcb');
	cb.id = 'SELC_' + gr.title;
	cb.classList.add('selcb');
	texttit.htmlFor = cb.id;
	texttit.append(cb);
	texttit.append(genspan('browser.selall'));
	//texttit.append(' Select all');
	cb.onclick = (ev) => {
		if (cb.checked) reccheck(true, gr);
		else reccheck(false, gr);
	};
	d.append(texttit);

	gr.entry.append(d);
	if (!gr.haschildren) {
		const ig = document.createElement('div');
		ig.classList.add('igtype');
		gr.entry.append(ig);
	}
}
/* add classes upwards */
function higherclasses(arr, len, curlevel) {
	for (const u of arr.filter((o) => o.level === curlevel)) {
		if (u.ischild) continue;
		if (arr.filter((o) => u.title.substring(0,len) === o.title.substring(0,len)).length === 1) {
			u.level --;
			u.entry.classList.add('gl' + u.level);
			u.entry.classList.remove('gl' + (u.level + 1));
		} else if (arr.findIndex((o) => o.title === u.title.substring(0,len)) === -1) {
			const cl = {
				title: u.title.substring(0,len),
				level: curlevel - 1,
				smembers: []
			};
			cl.entry = document.createElement('div');
			cl.entry.id = 'gg_' + u.title.substring(0,len) + '_X';
			cl.entry.classList.add('gg');
			cl.entry.classList.add('ggclosed');
			cl.entry.classList.add('gl' + (curlevel - 1));
			//buildtitle(cl);
			for (const x of arr.filter((o) => u.title.substring(0,len) === o.title.substring(0,len))) {
				x.ischild = true;
				// todo: sort
				cl.smembers.push(x);
				cl.haschildren = true;
				arr.splice(arr.findIndex((o) => o.title === x.title),1);
				//cl.entry.append(x.entry);
			}
			arr.push(cl);
		}
	}
	if (curlevel === 5)
		higherclasses(arr, len - 2, 4);
	else if (curlevel === 4)
		higherclasses(arr, len - 3, 3);
}
/* debug */
function prgr(gr, indent) {
	const str = '                ';
	if (undefined === gr.title) return;
	console.log(str.substring(0,2*indent), gr.title, '   ', countfiles(gr));
	if (undefined === gr.smembers) return;
	for (const s of gr.smembers) {
		prgr(s, indent + 1);
	}
}
/* return count of files in class */
function countfiles(cla) {
	let res = 0;
	if (undefined !== cla.fmembers) res += cla.fmembers.length;
	if (undefined !== cla.smembers)
		for (const s of cla.smembers)
			res += countfiles(s);
	return res;
}
/* check if we are directly on a back */
function checkimb() {
	if (debugflag) document.getElementById('dbgfsel').style['display'] = '';
	if (!window.location.origin.startsWith('http://192.168.1.254')) return;
	const xhr0 = new XMLHttpRequest();
	xhr0.onloadend = (event) => {
		if (xhr0.status === 200) {
			let foundph = false, foundmov = false;
			const sel = xhr0.responseXML.querySelectorAll('a');
			for (const r of sel) {
				if (r.href.indexOf('/IMBACK/PHOTO') != -1)
					foundph = true;
				if (r.href.indexOf('/IMBACK/MOVIE') != -1)
					foundmov = true;
			}
			if (!foundph && !foundmov) return;
			document.getElementById('onimback').style['display'] = '';
			const xhr = new XMLHttpRequest();
			xhr.onloadend = (event) => {
				//console.log('OLE ' + JSON.stringify(event) + ' XHR ' + JSON.stringify(xhr));
				if (xhr.status === 200) {
					const sel2 = xhr.responseXML.querySelectorAll('a');
					for (const r of sel2) {
						if (r) {
							let rawname = r.href;
							if (rawname.indexOf('del=') != -1) continue;
							while (rawname.indexOf("/") > -1)
								rawname = rawname.substring(rawname.indexOf("/") + 1);
							if (rawname.substring(rawname.length -4).toUpperCase() === '.RAW') {
								if (rawname < earliestraw) earliestraw = rawname;
								if (rawname > latestraw) latestraw = rawname;
								rimbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
								imbeles.push({
										type: 'RAW',
										url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									untypedclasses.push(cl);
								if (typedclasses.findIndex((v, i, o) => v === ('RAW' + cl)) === -1)
									typedclasses.push('RAW' + cl);
							}
							else if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG') {
								if (rawname < earliestjpg) earliestjpg = rawname;
								if (rawname > latestjpg) latestjpg = rawname;
								imbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
								imbeles.push({
										type: 'JPG',
										url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									untypedclasses.push(cl);
								if (typedclasses.findIndex((v, i, o) => v === ('JPG' + cl)) === -1)
									typedclasses.push('JPG' + cl);
							}
							else {
								if (rawname < earliestmov) earliestmov = rawname;
								if (rawname > latestmov) latestmov = rawname;
								imbmovies.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
								imbeles.push({
										type: 'oth',
										url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									untypedclasses.push(cl);
								if (typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
									typedclasses.push('oth' + cl);
							}
						}
					}
					document.getElementById('piccnt').innerHTML = '' + imbpics.length + ' (';
					if (earliestjpg.length > 4) document.getElementById('piccnt').innerHTML += earliestjpg.substring(0,16);
					document.getElementById('piccnt').innerHTML += ' - ';
					if (latestjpg.length > 4) document.getElementById('piccnt').innerHTML += latestjpg.substring(0,16);
					document.getElementById('piccnt').innerHTML += ')';
					document.getElementById('piccnt').removeAttribute('data-myxlkey');
					document.getElementById('rpiccnt').innerHTML = '' + rimbpics.length + ' (';
					if (earliestraw.length > 4) document.getElementById('rpiccnt').innerHTML += earliestraw.substring(0,16);
					document.getElementById('rpiccnt').innerHTML += ' - ';
					if (latestraw.length > 4) document.getElementById('rpiccnt').innerHTML += latestraw.substring(0,16);
					document.getElementById('rpiccnt').innerHTML += ')';
					document.getElementById('rpiccnt').removeAttribute('data-myxlkey');
					const xhrm = new XMLHttpRequest();
					xhrm.onloadend = (event) => {
						//console.log('OLE ' + JSON.stringify(event) + ' XHR ' + JSON.stringify(xhr));
						if (xhrm.status === 200) {
							const sel3 = xhrm.responseXML.querySelectorAll('a');
							for (const r of sel3) {
								if (r) {
									let rawname = r.href;
									while (rawname.indexOf("/") > -1)
										rawname = rawname.substring(rawname.indexOf("/") + 1);
									if (rawname.indexOf('del=') != -1) continue;
									if (rawname < earliestmov) earliestmov = rawname;
									if (rawname > latestmov) latestmov = rawname;
									imbmovies.push('http://192.168.1.254/IMBACK/MOVIE/' + rawname);
									imbeles.push({
										type: 'oth',
										url: 'http://192.168.1.254/IMBACK/MOVIE/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
									});
									const cl = rawname.substring(0,12);
									if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
										untypedclasses.push(cl);
									if (typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
										typedclasses.push('oth' + cl);
								}
							}
							document.getElementById('movcnt').innerHTML = '' + imbmovies.length + ' (';
							if (earliestmov.length > 4) document.getElementById('movcnt').innerHTML += earliestmov.substring(0,16);
							document.getElementById('movcnt').innerHTML += ' - ';
							if (latestmov.length > 4) document.getElementById('movcnt').innerHTML += latestmov.substring(0,16);
							document.getElementById('movcnt').innerHTML += ')';
							document.getElementById('movcnt').removeAttribute('data-myxlkey');
							document.getElementById('imbdoit').disabled = false;
							document.getElementById('imbvisbrows').disabled = false;
						}
					};
					xhrm.onerror = (event) => {
						document.getElementById('movcnt').innerHTML = '0';
						document.getElementById('movcnt').removeAttribute('data-myxlkey');
						document.getElementById('imbdoit').disabled = false;
						document.getElementById('imbvisbrows').disabled = false;
					};
					xhrm.open('GET', '/IMBACK/MOVIE/');
					xhrm.responseType = 'document';
					xhrm.send();
				}
			};
			xhr.onerror = (event) => {
				document.getElementById('piccnt').innerHTML = '0';
				document.getElementById('rpiccnt').innerHTML = '0';
				const xhrm = new XMLHttpRequest();
				xhrm.onloadend = (event) => {
					//console.log('OLE ' + JSON.stringify(event) + ' XHR ' + JSON.stringify(xhr));
					if (xhrm.status === 200) {
						const sel3 = xhrm.responseXML.querySelectorAll('a');
						for (const r of sel3) {
							if (r) {
								let rawname = r.href;
								while (rawname.indexOf("/") > -1)
									rawname = rawname.substring(rawname.indexOf("/") + 1);
								if (rawname.indexOf('del=') != -1) continue;
								if (rawname < earliestmov) earliestmov = rawname;
								if (rawname > latestmov) latestmov = rawname;
								imbmovies.push('http://192.168.1.254/IMBACK/MOVIE/' + rawname);
								imbeles.push({
										type: 'oth',
										url: 'http://192.168.1.254/IMBACK/MOVIE/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									untypedclasses.push(cl);
								if (typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
									typedclasses.push('oth' + cl);
							}
						}
						document.getElementById('movcnt').innerHTML = '' + imbmovies.length + ' (';
						if (earliestmov.length > 4) document.getElementById('movcnt').innerHTML += earliestmov.substring(0,16);
						document.getElementById('movcnt').innerHTML += ' - ';
						if (latestmov.length > 4) document.getElementById('movcnt').innerHTML += latestmov.substring(0,16);
						document.getElementById('movcnt').innerHTML += ')';
						document.getElementById('movcnt').removeAttribute('data-myxlkey');
						document.getElementById('imbdoit').disabled = false;
						document.getElementById('imbvisbrows').disabled = false;
					}
				};
				xhrm.onerror = (event) => {
					document.getElementById('movcnt').innerHTML = '0';
					document.getElementById('movcnt').removeAttribute('data-myxlkey');
					document.getElementById('imbdoit').disabled = false;
					document.getElementById('imbvisbrows').disabled = false;
				};
				xhrm.open('GET', '/IMBACK/MOVIE/');
				xhrm.responseType = 'document';
				xhrm.send();
			};
			xhr.open('GET', '/IMBACK/PHOTO/');
			xhr.responseType = 'document';
			xhr.send();
		}
	};
	xhr0.open('GET', '/IMBACK/');
	xhr0.responseType = 'document';
	xhr0.send();
}
/* open visual browser */
function visbrows() {
	aftercheck();
	showbrowser();
	buildtree();
}
/* handle the normal selection from imback */
function imbdoit() {
	if (actnum !== allfiles.length) return;
	let selecteds = [];
	let compval = '0000';
	if (document.getElementById('imbstartts').value != undefined && document.getElementById('imbstartts').value.length > 0) {
		compval = document.getElementById('imbstartts').value;
	}
	if (document.getElementById('picfromimb').checked) {
		for (const e of imbpics) {
			let rawname = e;
			while (rawname.indexOf("/") > -1)
				rawname = rawname.substring(rawname.indexOf("/") + 1);
			if (rawname.substring(0, compval.length) >= compval)
				selecteds.push(e);
		}
	}
	if (document.getElementById('rpicfromimb').checked) {
		for (const e of rimbpics) {
			let rawname = e;
			while (rawname.indexOf("/") > -1)
				rawname = rawname.substring(rawname.indexOf("/") + 1);
			if (rawname.substring(0, compval.length) >= compval)
				selecteds.push(e);
		}
	}
	if (document.getElementById('movfromimb').checked) {
		for (const e of imbmovies) {
			let rawname = e;
			while (rawname.indexOf("/") > -1)
				rawname = rawname.substring(rawname.indexOf("/") + 1);
			if (rawname.substring(0, compval.length) >= compval)
				selecteds.push(e);
		}
	}
	selecteds.sort((a, b) => {
		let ra = a;
		let rb = b;
		while (ra.indexOf("/") > -1)
			ra = ra.substring(ra.indexOf("/") + 1);
		while (rb.indexOf("/") > -1)
			rb = rb.substring(rb.indexOf("/") + 1);
		if (ra < rb) return -1;
		else if (ra === rb) return 0;
		else return 1;
	});
    const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) addlinkbool = addlinkel.checked;
    const stepprev = document.getElementById('steppreview');
    stepmode = 0;
	if (stepprev !== null && stepprev.checked) stepmode = 1;
	totnum = selecteds.length;
	actnum = 0;
	allfiles = selecteds;
	if (totnum > 0) {
		mappx('process.frombackn', totnum);
		//appendmsg("Got " + totnum + " files from Imback.<br>&nbsp;<br>");
	}
	handleonex();
}
/* create the wait dots */
function createwait(el) {
	const errdiv = document.createElement('div');
	errdiv.classList.add('eepvw');
	const d1 = document.createElement('span');
	d1.classList.add('blink');
	d1.append('.');
	errdiv.append(d1);
	const d2 = document.createElement('span');
	d2.classList.add('blink2');
	d2.append('.');
	errdiv.append(d2);
	const d3 = document.createElement('span');
	d3.classList.add('blink3');
	d3.append('.');
	errdiv.append(d3);
	el.entry.append(errdiv);
}
/* recursive count selection */
function countsel(gr) {
	let res = 0;
	if (gr.fmembers) {
		res += gr.fmembers.filter((o) => o.selected).length;
	}
	if (gr.smembers) {
		for (const g of gr.smembers)
			res += countsel(g);
	}
	gr.entry.querySelector('.selnumber').innerHTML = '' + res;
	gr.entry.querySelector('.selcb').checked = (res === countfiles(gr));
	gr.sels = res;
	return res;
}
/* update all selected values */
function updateselections() {
	for (const s of typedclasses) countsel(s);
	for (const s of untypedclasses) countsel(s);
	let res = 0, sum = 0;
	for (const s of typedclasses) {
		res += s.sels;
		sum += countfiles(s);
	}
	document.getElementById('brnsel').innerHTML = '' + res;
	document.getElementById('selall').checked = (res === sum);
}
/* fill a html div into an imbele */
function displaydiv(e) {
	e.entry = document.createElement('div');
	e.entry.id = 'div_' + e.raw + '_X';
	e.entry.classList.add('ee');
	e.entry.classList.add(e.type);
	let rawname = e.url;
	while (rawname.indexOf("/") > -1)
		rawname = rawname.substring(rawname.indexOf("/") + 1);
	e.entry.classList.add('ET_' + e.type + rawname.substring(0,12));
	e.entry.classList.add('EY_' + rawname.substring(0,12));
	const texttit = document.createElement('label');
	texttit.classList.add('etit');
	const check = document.createElement('input');
	check.type = 'checkbox';
	check.name = 'cb_sel_' + e.raw + '_X';
	check.id = 'cb_sel_' + e.raw + '_X';
	check.classList.add('selcb');
	check.checked = e.selected;
	check.onclick = () => {
		e.selected = check.checked;
		updateselections();
	};
	texttit.htmlFor = check.id;
	texttit.append(check);
	texttit.append(rawname);
	e.entry.append(texttit);

	const errdiv = document.createElement('div');
	errdiv.classList.add('errimg');
	errdiv.append('X');
	errdiv.style['display'] = 'none';
	e.entry.append(errdiv);
	if (e.type === 'RAW') {
		e.preview = document.createElement('canvas');
		e.preview.classList.add('eeraw');
		e.preview.classList.add('eewait');
		e.preview.style['display'] = 'none';
		e.preview.style['height'] = '120px';
		e.entry.append(e.preview);
		createwait(e);
		startloadurl(e.url, e.type, e);
	} else if (e.type === 'JPG') {
		e.preview = document.createElement('img');
		e.preview.classList.add('eeimg');
		e.preview.classList.add('eewait');
		e.preview.style['display'] = 'none';
		e.preview.style['height'] = '120px';
		e.entry.append(e.preview);
		createwait(e);
		startloadurl(e.url, e.type, e);
	} else {
		e.preview = document.createElement('div');
		e.preview.classList.add('eepvx');
		e.preview.append('?');
		e.entry.append(e.preview);
	}
}
/* image loader call */
function loadimg(url, type, to) {
	if (to.entry.querySelector('.eepvw').style['display'] === 'none') {
		if (todolist[0] && todolist[0].url === url)
			todolist.splice(0,1);
		loadnextimg();
		return;
	}
	if (type === 'JPG') {
		to.preview.onload = (ev) => {
			to.entry.querySelector('.eepvw').style['display'] = 'none';
			to.preview.style['display'] = '';
			to.preview.style['width'] = to.preview.woidth * (120 / to.preview.height);
			if (todolist[0] && todolist[0].url === url) {
				todolist.splice(0,1);
				loadnextimg();
			}
		};
		to.preview.onerror = (ev) => {
			to.entry.querySelector('.eepvw').style['display'] = 'none';
			to.entry.querySelector('.errimg').style['display'] = '';
			if (todolist[0] && todolist[0].url === url) {
				todolist.splice(0,1);
				loadnextimg();
			}
		};
		to.preview.src = url;
	}
	else if (type === 'RAW') {
		buildpreview(url, () => {
				to.entry.querySelector('.eepvw').style['display'] = 'none';
				to.preview.style['display'] = '';
			}, () => {
				to.entry.querySelector('.eepvw').style['display'] = 'none';
				to.entry.querySelector('.errimg').style['display'] = '';
				if (todolist[0] && todolist[0].url === url) {
					todolist.splice(0,1);
					loadnextimg();
				} // else the afterload had already been called
			}, 1, to.preview, () => {
				if (todolist[0] && todolist[0].url === url) {
					todolist.splice(0,1);
					loadnextimg();
				}
		});
	}
}
/* next from todo list */
function loadnextimg() {
	if (todolist.length === 0) return;
	setTimeout(() => {
		if (todolist.length === 0) return;
		const next = todolist[0];
		loadimg(next.url, next.type, next.to);
	});
}
/* start loading */
function startloadurl(url, type, to) {
	todolist.push({
			url: url, type: type, to: to
	});
	if (todolist.length === 1)
		loadnextimg();
}
/* deleete browser selected */
function browserdelete() {
	document.getElementById('delq').style['display'] = '';
	document.getElementById('browser').style['display'] = 'none';
	document.getElementById('delokbut').disabled = false;
	document.getElementById('delcancelbut').disabled = false;
}
/* do delete */
let deletephase = 0;
let deletephs = [ '|' , '/', '-', '\\' ];
function dodelete(list) {
	if (list === undefined && imbeles.filter((o) => o.selected).length === 0) {
		delcancel();
		return;
	}
	else if (list === undefined) {
		document.getElementById('delokbut').disabled = true;
		document.getElementById('delcancelbut').disabled = true;
		dodelete(imbeles.filter((o) => o.selected));
		deletephase=0;
		document.getElementById('delprogmsg').innerHTML = deletephs[deletephase];
		return;
	} else if (list.length > 0) {
		let xhr = new XMLHttpRequest();
		xhr.onload = xhr.onerror = () => {
			deletephase ++;
			document.getElementById('delprogmsg').innerHTML = deletephs[deletephase % deletephs.length];
			list.splice(0,1);
			dodelete(list);
		};
		xhr.open('GET',list[0].url + '?del=1');
		xhr.send();
	} else {
		alert(xl('delete.reload'));
		delcancel();
	}
}
function delcancel() {
	document.getElementById('delq').style['display'] = 'none';
	document.getElementById('browser').style['display'] = '';
}
/* process browser selected */
function browserprocess() {
	if (actnum !== allfiles.length) return;
	let selecteds = [];
	for (const i of imbeles) {
		if (i.selected) selecteds.push(i.url);
	}
	selecteds.sort((a, b) => {
		let ra = a;
		let rb = b;
		while (ra.indexOf("/") > -1)
			ra = ra.substring(ra.indexOf("/") + 1);
		while (rb.indexOf("/") > -1)
			rb = rb.substring(rb.indexOf("/") + 1);
		if (ra < rb) return -1;
		else if (ra === rb) return 0;
		else return 1;
	});
    const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) addlinkbool = addlinkel.checked;
    stepmode = 0;
	totnum = selecteds.length;
	actnum = 0;
	allfiles = selecteds;
	if (totnum > 0) {
		mappx('process.frombrowsern', totnum);
		//appendmsg("Got " + totnum + " files from Visual browser.<br>&nbsp;<br>");
		handleonex();
	} else {
		shownormal();
	}
}
/* translate one string with parameters */
function xl(str, base, arg0, arg1, arg2, arg3) {
	if (undefined === base) base = texts;
	if (mylang === 'nn') {
		let res = '[' + str;
		if (undefined !== arg0) {
			res += ',' + arg0;
			if (undefined !== arg1) {
				res += ',' + arg1;
				if (undefined !== arg2) {
					res += ',' + arg2;
					if (undefined !== arg3) {
						res += ',' + arg3;
					}
				}
			}
		}
		return (res + ']');
	}
	const i = str.indexOf('.');
	if (i === -1) {
		let r = base[str][mylang];
		if (r.indexOf('$$0') !== -1 && arg0 !== undefined) {
			r = r.substring(0, r.indexOf('$$0')) + arg0 + r.substring(r.indexOf('$$0') + 3);
			if (r.indexOf('$$1') !== -1 && arg1 !== undefined) {
				r = r.substring(0, r.indexOf('$$1')) + arg1 + r.substring(r.indexOf('$$1') + 3);
				if (r.indexOf('$$2') !== -1 && arg2 !== undefined) {
					r = r.substring(0, r.indexOf('$$2')) + arg2 + r.substring(r.indexOf('$$2') + 3);
					if (r.indexOf('$$3') !== -1 && arg3 !== undefined) {
						r = r.substring(0, r.indexOf('$$3')) + arg3 + r.substring(r.indexOf('$$3') + 3);
					}
				}
			}
		}
		return r;
	}
	else {
		const e = base[str.substring(0,i)];
		return xl(str.substring(i+1),e, arg0, arg1, arg2, arg3);
	}
}
/* print translations */
function prxl(key, el) {
	if (el['de'] && el['en']) {
		let out = key + ';';
		out += '\'' + el['de']  + '\';';
		out += '\'' + el['en']  + '\';';
		console.log(out);
	}
	for (const ne of Object.keys(el).filter((k) => ((k !== 'en') && (k !== 'de')))) {
		prxl(key + '.' + ne, el[ne]);
	}
}
/* translate everything */
function xlateall() {
	const k = document.querySelectorAll('*[data-myxlkey]');
	for (const e of k) {
		const o = e.attributes.getNamedItem('data-myxloff')?.value;
		const nn = e.attributes.getNamedItem('data-myxlnnn')?.value;
		if (o !== undefined && o !== null && o !== '' && nn !== undefined) {
			e.innerHTML = xl(e.attributes.getNamedItem('data-myxlkey').value, undefined,  (nn > 0) ? xlargs[Number.parseInt(o,10)]:undefined, (nn > 1) ? xlargs[Number.parseInt(o,10)+1]:undefined, (nn > 2) ? xlargs[Number.parseInt(o,10)+2]:undefined, (nn > 3) ? xlargs[Number.parseInt(o,10)+3]:undefined );
		} else {
			e.innerHTML = xl(e.attributes.getNamedItem('data-myxlkey').value);
		}
	}
	const l = document.querySelectorAll('*[data-myvalxlkey]');
	for (const e of l) {
		e.value = xl(e.attributes.getNamedItem('data-myvalxlkey').value);
	}
	const m = document.querySelectorAll('*[data-mytitlexlkey]');
	for (const e of m) {
		e.title = xl(e.attributes.getNamedItem('data-mytitlexlkey').value);
	}
	document.getElementById('helplink').href = xl('main.helplink');
	if (debugflag && firstflag) {
		for (const el of Object.keys(texts))
			prxl(el, texts[el]);
	}
	firstflag = false;
}
/* translate for new language */
function setlang() {
	mylang = document.getElementById('langsel').value;
	xlateall();
}
/* find language from filename */
function querylang() {
	let found = 0;
	for (const l of alllangs) {
		if (window.location.pathname.substring(window.location.pathname.length - 8).toUpperCase().startsWith('_' + l.toUpperCase())) {
			mylang = l;
			document.getElementById('langsel').value = l;
			found = 1;
		}
	}
	if (!found) {
		mylang = 'en';
		document.getElementById('langsel').value = 'en';
	}
	// followed by xlall anyway
}
/* only debug */
function dodebug() {
	const fr = new FileReader();
	fr.onload = (res) => {
		const dp = new DOMParser();
		const doc = dp.parseFromString(res.target.result,'text/html');
		const sel2 = doc.querySelectorAll('a');
		for (const r of sel2) {
			if (r) {
				let rawname = r.href;
				if (rawname.indexOf('del=') != -1) continue;
				while (rawname.indexOf("/") > -1)
					rawname = rawname.substring(rawname.indexOf("/") + 1);
				if (rawname.substring(rawname.length -4).toUpperCase() === '.RAW') {
					if (rawname < earliestraw) earliestraw = rawname;
					if (rawname > latestraw) latestraw = rawname;
					rimbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
					imbeles.push({
							type: 'RAW',
							url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
							raw: rawname,
							selected: false,
							preview: null,
							entry: null,
							waiting: false,
							error: false,
							processed: false
					});
					const cl = rawname.substring(0,12);
					if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
						untypedclasses.push(cl);
					if (typedclasses.findIndex((v, i, o) => v === ('RAW' + cl)) === -1)
						typedclasses.push('RAW' + cl);
				}
				else if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG') {
					if (rawname < earliestjpg) earliestjpg = rawname;
					if (rawname > latestjpg) latestjpg = rawname;
					imbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
					imbeles.push({
							type: 'JPG',
							url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
							raw: rawname,
							selected: false,
							preview: null,
							entry: null,
							waiting: false,
							error: false,
							processed: false
					});
					const cl = rawname.substring(0,12);
					if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
						untypedclasses.push(cl);
					if (typedclasses.findIndex((v, i, o) => v === ('JPG' + cl)) === -1)
						typedclasses.push('JPG' + cl);
				}
				else {
					if (rawname < earliestmov) earliestmov = rawname;
					if (rawname > latestmov) latestmov = rawname;
					imbmovies.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
					imbeles.push({
							type: 'oth',
							url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
							raw: rawname,
							selected: false,
							preview: null,
							entry: null,
							waiting: false,
							error: false,
							processed: false
					});
					const cl = rawname.substring(0,12);
					if (untypedclasses.findIndex((v, i, o) => v === cl) === -1)
						untypedclasses.push(cl);
					if (typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
						typedclasses.push('oth' + cl);
				}
			}
		}
		document.getElementById('piccnt').innerHTML = '' + imbpics.length + ' (';
		if (earliestjpg.length > 4) document.getElementById('piccnt').innerHTML += earliestjpg.substring(0,16);
		document.getElementById('piccnt').innerHTML += ' - ';
		if (latestjpg.length > 4) document.getElementById('piccnt').innerHTML += latestjpg.substring(0,16);
		document.getElementById('piccnt').innerHTML += ')';
		document.getElementById('piccnt').removeAttribute('data-myxlkey');
		document.getElementById('rpiccnt').innerHTML = '' + rimbpics.length + ' (';
		if (earliestraw.length > 4) document.getElementById('rpiccnt').innerHTML += earliestraw.substring(0,16);
		document.getElementById('rpiccnt').innerHTML += ' - ';
		if (latestraw.length > 4) document.getElementById('rpiccnt').innerHTML += latestraw.substring(0,16);
		document.getElementById('rpiccnt').innerHTML += ')';
		document.getElementById('rpiccnt').removeAttribute('data-myxlkey');
		document.getElementById('movcnt').innerHTML = '' + imbmovies.length + ' (';
		if (earliestmov.length > 4) document.getElementById('movcnt').innerHTML += earliestmov.substring(0,16);
		document.getElementById('movcnt').innerHTML += ' - ';
		if (latestmov.length > 4) document.getElementById('movcnt').innerHTML += latestmov.substring(0,16);
		document.getElementById('movcnt').innerHTML += ')';
		document.getElementById('movcnt').removeAttribute('data-myxlkey');
		document.getElementById('imbdoit').disabled = false;
		document.getElementById('imbvisbrows').disabled = false;
		document.getElementById('onimback').style['display'] = '';
	};
	fr.readAsText(document.getElementById('dbgfsel').files[0]);
}
</script>
<style type="text/css">
.blink {
  animation: blinker 1s linear infinite;
}
.blink2 {
  animation: blinker 1s linear infinite;
  animation-delay: 0.33s;
}
.blink3 {
  animation: blinker 1s linear infinite;
  animation-delay: 0.66s;
}
.blink, .blink2, .blink3 {
	font-size: 600%;
	font-weight: bold;
	line-height: 5px;
	height: 250px;
	display: inline-block;
}

@keyframes blinker {
  50% {
    opacity: 0;
  }
}
.gg {
	display: block;
}
.gg .grtit { font-weight: bold; font-size: 125%; }
.gg:not(.gl1) {
	margin-left: 1em;
}
.ggtt {
	border: 2px solid white;
	border-radius: 5px;
	margin:0.2em;
}
.gl1 > .ggtt span.gtype { display: inline !important; }
.ggttopen > .ggttplus { display: none; }
.ggttclosed > .ggttminus { display: none; }
.ggttclosed > div > .ggtt { display: none; }
.ggclosed > .gg, .ggclosed .igtype { display: none !important; }
.ggttminus, .ggttplus { cursor: pointer; display: inline-block; width: 1.9em; font-weight:normal !important; }
.igtype { border: 2px solid yellow; border-radius: 5px; display: flex; flex-flow: wrap; }
.ee { border: 2px solid gray; border-radius: 5px; margin: 2px; width: fit-content; display: flex; flex-direction: column; padding: 0.3em;}
.eepvx { color: #777777; font-size: 100px; align-self: center; font-weight: bold; }
.errimg { color: red; font-size: 100px; align-self: center; font-weight: bold; }
.eepvw { color: #444444; font-size: 100px; align-self: center; font-weight: bold; }
.eeraw, .eeimg { align-self: center; }
</style>
</head>
<!-- here comes the html itself -->
<body style="font-family: Helvetica, Arial, sans-serif;" onload="querylang();xlateall(); checkimb();">
<div style="font-weight:bold;"><span data-myxlkey='main.title'> </span> <span translate="no">V2.9.9_c82b5e1</span> - <a target="_new" id="helplink" href="https://shyrodgau.github.io/imbraw2dng/" data-myxlkey='main.help'></a> <select id="langsel" onchange="setlang()"><option value="de" onclick="setlang()">DE</option><option value="en" onclick="setlang()">EN</option></select></div>
<div id="normal" style="margin-top: 0.5em;">
<!-- the normal display -->
<div><input type="checkbox" id="steppreview" checked><label for="steppreview" data-myxlkey="process.singlestep"></label></div>
<div><input type="checkbox" id="addlink"><label for="addlink" data-mytitlexlkey="process.maycostmem" title="T" data-myxlkey="process.addlink"></label></div>
<div  style="margin-top: 0.5em;" data-myxlkey="main.generaladvice"></div>
<!-- connected ! -->
<div id="onimback" style="background-color:#ffffbb;border: 5px solid #ffff88;border-radius: 10px;width:fit-content;padding:1em;display:none;"><div style="font-size:133%;" data-myxlkey="onimback.connected"></div>
<span data-myxlkey="onimback.dlconvert"></span><br>
<input checked type="checkbox" id="rpicfromimb"><label for="rpicfromimb" data-myxlkey="main.types.rawpics"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="rpiccnt" data-myxlkey="main.stillcounting"></span>
<br><input checked type="checkbox" id="picfromimb"><label for="picfromimb" data-myxlkey="main.types.jpgpics"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="piccnt" data-myxlkey="main.stillcounting"></span> 
<br><input checked type="checkbox" id="movfromimb"><label for="movfromimb" data-myxlkey="main.types.other"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="movcnt" data-myxlkey="main.stillcounting"></span><br>
<span data-myxlkey="onimback.fromtime"></span> <input type="text" maxlength="16" id="imbstartts" inlength="0" placeholder="YYYY_MMDD_hhmmss" pattern="[0-9][0-9][0-9][0-9](_[0-9][0-9][0-9][0-9]_([0-9][0-9]([0-9]([0-9][0-9][0-9])*)*)*)*"> (<span data-myxlkey="onimback.nullforall"></span>) <br>
<input onclick="imbdoit()" type="button" data-myvalxlkey="onimback.doit" id="imbdoit" disabled><br>
<span data-myxlkey="main.or"></span> <input type="button" data-myvalxlkey="onimback.visual" id="imbvisbrows" onclick="visbrows()" disabled>.
</div>
<!-- end of connected -->
<div style="font-size:133%;margin-top: 0.5em;" data-myxlkey="main.drophere"></div>
<div id="droptarget" ondrop="drophandler(event);" ondragenter="prevdef(event);" ondragover="prevdef(event);" style="border: 5px solid blue;border-radius: 10px;width:300px; height:70px;background-color: rgba(0,0,255,0.2);"></div><br>
<div  style="font-size:133%;margin-top: 0.5em;"><span data-myxlkey="main.selectraw"></span> <input type="file" accept=".raw,.RAW" id="infile" name="infile" multiple onchange="fselected()"></div><br>
&nbsp;<br>
<div id="reloadhint" style="display:none;" data-myxlkey="main.reload"><br>&nbsp;</div>
<div id="xmsg" style="display: none; width: fit-content;white-space: pre;"><span style="font-weight:bold;" data-myxlkey="main.log"></span><br>
<div id="outmsg"></div></div>
<div id="reloadhint2" style="display:none;" data-myxlkey="main.reload"><br>&nbsp;</div>
</div>
<!-- this is only shown on step with preview -->
<div id="question" style="display:none;background-color:#ddffaa;border: 5px solid #33ff33; border-radius: 10px;width: fit-content;padding:2em;">
<div style="font-weight:bold;" id="qhdr">&nbsp;</div>
<canvas id="preview"></canvas><img style="display:none;max-width:550px; max-height:550px;" id="jpegpreview" onload="setjpegpv()" onerror="setpverr()"><div id="previewerr" data-myxlkey="preview.err"></div><div id="previewwait"><span class="blink">.</span><span class="blink2">.</span><span class="blink3">.</span></div><br>
<div id="rotations"><input type="button" id="procthiscw" data-myvalxlkey="preview.rotcw" data-mytitlexlkey="preview.rotcw.tooltip" onclick="rotcw()" style="padding:0.5em; margin:0.5em;margin-left:2.5em;">
<input type="button" id="procthisccw" data-mytitlexlkey="preview.rotccw.tooltip" data-myvalxlkey="preview.rotccw" onclick="rotccw()" style="padding:0.5em; margin:0.5em;">
<input type="button" id="procthisud" data-myvalxlkey="preview.rot180" data-mytitlexlkey="preview.rot180.tooltip" onclick="rot180()" style="padding:0.5em; margin:0.5em;" >
<input type="button" id="procthisrs"data-myvalxlkey="preview.rotreset" data-mytitlexlkey="preview.rotreset.tooltip" value="Reset" onclick="rot0()" style="padding:0.5em; margin:0.5em;"></div>
<div id="continues"><input type="button" id="procthis" data-myvalxlkey="preview.process" onclick="procthis()" style="padding:0.5em; margin:0.5em;">
<input type="button" id="skipthis" data-myvalxlkey="preview.skip" value="Skip" onclick="skipthis()" style="padding:0.5em; margin:0.5em;">&nbsp;
<span id="forrest"><input type="checkbox" id="doforall" style="padding-left:0.5em; margin-left:0.5em;"><label for="doforall" data-myxlkey="preview.forall"></label></span></div>
</div>
<!-- this is the picture browser -->
<div id="browser" style="background-color:#ffccbb;border: 5px solid #ff8833; border-radius: 10px;width: 90%;padding-left:2em;padding-right:2em;padding-top:1em; padding-bottom:1em;display:none;flex-direction:column;">
<div style="margin-bottom:1em;"><span data-myxlkey="main.sort"></span>: <label for="sbytype"><input type="checkbox" id="sbytype" onclick="buildtree()"><span data-myxlkey="browser.bytype"></span></label> - <label for="solder"><input type="checkbox" id="solder" onclick="buildtree()"><span data-myxlkey="browser.olderfirst"></span></label>
 - <span data-myxlkey="main.selected"></span>: <span id="brnsel">?</span> / <span id="brntot">?</span> - <label for="selall" data-mytitlexlkey="browser.selall.tooltip"><input onclick="topreccheck()" type="checkbox" id="selall"><span data-myxlkey="browser.selall"></span></label> - <input type="button" data-myvalxlkey="browser.procall" onclick="browserprocess()"> - <input type="button" data-myvalxlkey="browser.delall" onclick="browserdelete()"></div>
</div>
<!-- this is the delete question/progress -->
<div id="delq" style="border: 2px solid red; border-radius: 20px; padding: 20px;display:none;width:fit-content;">
<span data-myxlkey="delete.question"></span><br>
<input id="delcancelbut" type="button" data-myvalxlkey="delete.question.cancel" onclick="delcancel()"> - <input id="delokbut" type="button" data-myvalxlkey="delete.question.ok" onclick="dodelete()"><br>
<span data-myxlkey="delete.nostatus"></span><br>
<div id="delprogmsg"></div>
</div>
<!--

TTT   YYYY   MM    DD    hh

TTT   YYYY++     DD+  hh+

TTT   YYYY+   MM++   hh+

TTT   YYYY+   MM+  DD++

Sort   [ ] by Type   [ ] older first   (n/nn)  [ Process all->selected ] [ Delete all->selected ]
----
  XXXX_mmdd_hh      [+] (n)  [++] (n/nn)        [ Select All ]
  ----
     XXXX_MMdd_hh   [+] (n)  [++] (n/nn)        [ Select All ]
     
     
     

ele: {
		typ: 'JPG' | 'RAW' | 'oth',
		url: string,
		selected: boolean,
		preview: canvas | img | null, // oth: n,n,f,f => n,d,f,f // jpg: n,n,f,f => i,d,t,f => i,d,f,f or i,d,f,t // raw: n,n,f,f => c,d,t,f => c,d,f,f or c,d,f,t
		entry: div | null,
		waiting: boolean,
		error: boolean,
		processed: boolean
}
		
group: {
			title: string,
			level: number, // 5 hr, 4 d, 3 mo, 2 yr, 1 typ
			subgroups: group[],
			eles: ele[],
			openentry: div,
			closedentry: div
}

-->
<!-- this is invisible -->
<input type="file" onchange="dodebug()" accept=".html,.htm" id="dbgfsel" style="display:none;">
<a style="display: none;" id="result">x</a>
</body>
</html>
