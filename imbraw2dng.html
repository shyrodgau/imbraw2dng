<html>
<!--
***************************************************** 

imbraw2dng.html

Convert RAW from I'm back(R)(https://imback.eu) into DNG

Based on work by Michele Asciutti.

https://github.com/shyrodgau/imbraw2dng

Usage: open in browser and select RAW

***************************************************** 

Copyright (C) 2023,2024 by Stefan Hegny, stefan@hegny.de

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. 
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

// SPDX-License-Identifier: 0BSD

***************************************************** 
-->
<head>
<meta name="viewport" content="width=200, initial-scale=1" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAICAAAAEACACoCAAAFgAAACgAAAAgAAAAQAAAAAEACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAcAAAAAAQEAAQEBAAAHBwAACgoAAAsLAAAMDAAADQ0AAA8PAAASEgAAFRUAABcXAAAaGgAAHBwAACAgAAEjIgANIicAAiQlAAwpKwAHKisAACwsAAItLQAALy8AADExAAEyMgAAAP8ADDw9AAA/PwAAQUEAAEVFAABGRgABSEgAAEpKAAJOTgAAUVEAAlJSAAZSUgAAU1MAAFRUABJTVAAIVFUAAFhYAAxYWQAAXV0AEFxdAANgYAAAYWEACWRlAABnZwAHaGgAAG9vAAlvcAAAcHAADXJyABZ4eQAAe3sAAH19AAp+fwAEf38AAoGBABOBggAAhIQAFIOEAAOHhwAYjY8AAo+PAAOPjwANkZEADJGSAAOUlAAClZUAApiYAACamgAAm5sADZqbAAabmwAGm5wACpucAAmdnQAAnp4ADaCgAA6goAAAoqIAAqKiAAulpQACpqYAAKenAA2mpwAAqqoAAKysAKOjowAJra0AAK6uAA2trgACrq4AA66uABGvsAAxrbEAArGxAA2xsQAOsbIADbKyAACzswAAtrYABLe3ABa2ugAAubkABLm5AAy8vAAAvb0ADb6+AADAwAAovb8ABcDAAADBwQAFwsIAAMPDAADExAATw8QAAMXFAADGxgAAx8cAAMjIAAPJyQAAy8sADcvMAADR0QAG0tIAANPTAA3U1AAC1dUAAdnZAADa2gAC2toAAtvbAALc3AAT29sABtzcAADd3QAN3N0AAN7eAB3c3QAC3t4ADd/fAADi4gAA4+MAAeTkAADl5QAE5eUAAObmAATm5gAA6ekACerqAALr6wAE6+wAAOzsAALt7QAR7O0AG+ztAALu7gAG8PAAAPHxAAvx8gAA8vIAAPPzAAD09AAL9PQACfT1AA309AAA9fUAAPb2AAX29gAK9vYAAvf3AAT39wAB+PgAAvj4AAT4+AAA+fkABPn5AAL6+gAJ+voAAPv7AAD8/AAB/PwACPz8AAD9/QAO/f0AAP7+AAL+/gAI/v4AC/7+AAD//wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcwsLCXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFzCwsJcXFxcXFxcXFxcXFxcXFxcXBsbGxsbGxsbGxsbXMLCwlxcXFxcXFxcXFxcXFxcXFxcGxsbGxsbGxsbGxtcwsLCXFxcXFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFzCwsJcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXMLCwlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcwsLCXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFzCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCa3GHwsLCwppxap/CvE1OgcLCdU9duXZeSkpedJe8wsISAEbCwsLCjQAAhMK8IwBMwsJtAAGqOgAAAAAAADKZwjwALL/CwsKvEwBqwsJHADDCwoEAAJBbAB6CgFEIAC2rYgAAncLCwsAqAEjCwm4AB6LCnAEAc3sADqvCwnwAAH6DAAB/wsLCwlIAJr3CigAAiMK7FwBVjgAAk8LCkgAAep4GAGXCwsLCcAABlsKhAwBpwsI3AD6jEAB5vqVLAAaTwhQAQ8LCwsKJAABXwrkDACWuwkEAKcEkAAkNCgALaMLCPQAxv8LCwqQAAANWZAAAADt9HwAVtUoAADQrACh3uMJZAASoLkC6txwAQhYAAABQLwAAAD/CcQAPp76VIABYwnsAAIt4AF/CcmOPm2E1Z7G0bElgm8KGAACMwsJUAB3CkQAAZrIhGpjCwsLCwsLCwsLCwsLCwqYAAG+0nTYAGMK2EQBFwlMARMLCwsLCwsLCwsLCwsLCvCIABRkMAABawsI4AjPChQABlMLCwsLCwsLCwsLCwsLCVC0nLSc5e77CwrOtsMK+rKmgwsLCwsLCwsLCwsLCwsLCwr7CvMLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" type="image/x-icon">
<title>ImB RAW to DNG Converter V???</title>
<style type="text/css">
@media (max-width: 600px) {
div#xmsg {
	white-space: pre-wrap !important;
}
}
#rpiclbl, #piclbl, #movlbl, #rpiccnt, #piccnt, #movcnt { font-weight: bold; }
#imbvisbrows {
	padding: 0.4em;
	margin: 0.4em;
}
.blink {
  animation: blinker 1s linear infinite;
}
.blink2 {
  animation: blinker 1s linear infinite;
  animation-delay: 0.33s;
}
.blink3 {
  animation: blinker 1s linear infinite;
  animation-delay: 0.66s;
}
.blink, .blink2, .blink3 {
	font-size: 200%;
	font-weight: bold;
	line-height: 5px;
	height: 100px;
	display: inline-block;
	z-index: 10;
}
/*div[data-state='load'] { background-color: black;}*/
@keyframes blinker {
  50% {
    opacity: 0;
  }
}
.gg {
	display: block;
}
.gg .grtit { font-weight: bold; font-size: 125%; }
.gg:not(.gl1) {
	margin-left: 1em;
}
.ggtt {
	border: 2px solid white;
	border-radius: 5px;
	margin:0.2em;
}
.gl1 > .ggtt span.gtype { display: inline !important; }
.ggttopen { border-bottom: 0 !important; }
.ggopen {  border: 2px solid white; border-radius: 5px; border-top: 0;border-left: 0; border-right:0;}
.ggttopen > .ggttplus { display: none; }
.ggttclosed > .ggttminus { display: none; }
.ggttclosed > div > .ggtt { display: none; }
.ggclosed > .gg, .ggclosed .igtype { display: none !important; }
.ggttminus, .ggttplus { cursor: pointer; display: inline-block; width: 1.9em; font-weight:normal !important; }
.biggiebtn:not(.disabled), .dlbtn:not(.disabled) { cursor: pointer; }
.dlbtn.biggiebtn { left: 1.5em; margin-top: -0.1em; }
.biggiebtn.disabled { display: none; }
.dlbtn:not(.biggiebtn) { vertical-align: bottom; font-weight: bold; }
.igtype { border: 2px solid yellow; border-radius: 5px; display: flex; flex-flow: wrap;background-color: #ffe6da;border-top: 0; padding:0.5em;}
.onepic { border: 2px solid gray; border-radius: 5px; margin: 2px; width: fit-content; display: flex; flex-direction: column; padding: 0.3em;position: relative; }
.eepvx { color: #777777; font-size: 100px; align-self: center; font-weight: bold; }
.errimg { color: red; font-size: 100px; align-self: center; font-weight: bold; }
.waitdiv { color: #444444; font-size: 100px; align-self: center; font-weight: bold; }
.eeraw, .eejpg { align-self: center; }
.onepic > :nth-child(1) { margin-top: -0.2em; margin-bottom: 0.1em;}
#previewwait {
	scale: 500%;
	margin-left: 250px;
	margin-top: 200px;
	line-height: 5px;
	height: 50px;
}
.selnumber {
	display: inline-block;
	width: 2em;
	text-align: end;
}
.btnsrow { position: absolute; top: 1.5em; left: 0.1em; height: 1em; width: 4em; background-color: rgba(200,200,180,0.4); }
.oth_CL .btnsrow, div[data-state='load'] .btnsrow, div[data-state='wait'] .btnsrow, div[data-state='err'] .btnsrow { display: none; }
.JPG_CL .btnsrow { width: 3em; }
.JPG_CL .rotbtn { display: none; }
.JPG_CL .eepvx, .JPG_CL .eeraw, .oth_CL .eeraw, .oth_CL .eejpg, .RAW_CL .eepvx, .RAW_CL .eejpg { display: none; }
.biggiebtn { position: absolute; top: -0.2em; font-weight:bold; font-size:120%; text-shadow: 0.1em 0.07em 0 white; z-index: 900;}
.picbig { scale: 3; position: absolute; z-index: 999; border: 3px solid white; left: 66%;}
.pictitle { z-index: 90; font-size: 80%; }
.picdeleted:before {
	content: '\1f6c7';
	position: relative;
	font-size: 50px;
	z-index: 99;
	color: rgba(255,0,0,0.6);
	text-shadow: 6px 4px white;
	padding-left: 0.1em;
	padding-top: 0.1em;
}
.picprocd:before {
	content: '\2713';
	position: absolute;
	font-size: 50px;
	z-index: 99;
	color: rgba(0,255,0,0.6);
	text-shadow: 6px 4px white;
	padding-left: 0.1em;
	padding-top: 0.1em;
}
</style>
<!-- javascript code identical to imbraw2dng.js  for the classes IFDOut, TIFFOut, ImBCBase, ImBCBackw. -->
<script type="text/javascript" language="javascript">
"use strict;"
/* *************************************** IFDOut *************************************** */
/* Tiff IFD helper class */
class IFDOut {
/* Indentation out */
camprofptr = -1; // first of the pointers, they are sequential, accessed by TIFFOut
exifdataptr = -1; // the exif ifd, pointers therein must be adjusted
// rest is private:
#entrys = [];
#currentoff = 0;
// imgdata can be view or array
#imgdata = null;
#imglen = 0;
#dyndata = [] ; //new Uint8Array(20000);
/* IFDOut: add image data to ifd */
addImageStrip(typ, view, width, height) {
	this.#imgdata = view;
	this.#imglen = view.byteLength ? ((this.#imgdata.byteLength + 3) & 0xFFFFFFFC) : (view.length + 3) & 0xFFFFFFFC;
	this.addEntry(254 , 'LONG', [ typ ]); /* SubFileType */
	this.addEntry(256 , 'SHORT', [ width ]); /* width */
	this.addEntry(257 , 'SHORT', [ height ]); /* height */
	this.addEntry(273 , 'LONG', [ 0xFFFFFFFF ]); /* StipOffsets , special */
	this.addEntry(279 , 'LONG', [ this.#imgdata.byteLength ? this.#imgdata.byteLength : view.length ]); /* StripByte count */
	this.addEntry(278 , 'LONG', [ height ]); /* Rows per strip */
}
/* IFDOut: add entry to ifd */
addEntry(tag, type, value) {
	let x = TIFFOut.tToNum(type);
	let l = value.length;
	if (type === 'ASCII') l++;
	else if (type === 'RATIONAL' || type === 'SRATIONAL') l /= 2;
	if (tag === 273 || tag === 330 || tag === 34665) { /* special cases */
		let e = {
			tag: tag,
			type: x.t,
			count: l,
			ptr: value[0]
		};
		this.#entrys.push(e);
	} else if (l * x.l <= 4) { /* fits into data */
		let e = {
			tag: tag,
			type: x.t,
			count: l,
			value: [ 0, 0, 0, 0 ]
		};
		if (type === 'BYTE' || type === 'SBYTE' || type === 'UNDEFINED') {
			for (let k=0; k<l; k++) e.value[k] = value[k];
		} else if (type === 'ASCII') {
			for (let k=0; k<l-1; k++) e.value[k] = value.charCodeAt(k) % 256;
		} else if (type === 'LONG') {
			TIFFOut.writeinttoout(e.value, value[0], 0);
		} else if (type === 'SLONG') {
			TIFFOut.writeinttoout(e.value, (65536*65536)+value[0], 0);
		} else if (type === 'SHORT') {
			TIFFOut.writeshorttoout(e.value, value[0], 0);
			if (l === 2) TIFFOut.writeshorttoout(e.value, value[1], 2);
		} else if (type === 'SSHORT') {
			if (value[0] < 0) TIFFOut.writeshorttoout(e.value, 65536+value[0], 0);
			else TIFFOut.writeshorttoout(e.value, value[0], 0);
			if (l === 2) {
				if (value[1] < 0) TIFFOut.writeshorttoout(e.value, 65536+value[1], 2);
				else TIFFOut.writeshorttoout(e.value, value[1], 2);
			}
		}
		this.#entrys.push(e);
	}
	else { /* data accessed via pointer */
		let e = {
			tag: tag,
			type: x.t,
			count: l,
			ptr: this.#currentoff
		};
		if (type === 'BYTE' || type === 'SBYTE' || type === 'UNDEFINED') {
			for (let k=0; k<l; k++) this.#dyndata.push(value[k]);
			this.#currentoff += l;
			if (this.#currentoff % 2) { // alignment
				this.#dyndata.push(0); this.#currentoff++;
			}
		} else if (type === 'ASCII') {
			for (let k=0; k<l-1; k++) this.#dyndata.push(value.charCodeAt(k) % 256);
			this.#dyndata.push(0);
			this.#currentoff += l;
			if (this.#currentoff % 2) { // alignment
				this.#dyndata.push(0); this.#currentoff++;
			}
		} else if (type === 'LONG') {
			for (let k = 0; k < l; k++) {
				TIFFOut.writeinttoout(this.#dyndata, value[k], this.#currentoff);
				this.#currentoff += 4;
			}
		} else if (type === 'SLONG') {
			for (let k = 0; k < l; k++) {
				if (value[k] < 0) TIFFOut.writeinttoout(this.#dyndata, (65536*65536)+value[k], this.#currentoff);
				else TIFFOut.writeinttoout(this.#dyndata, value[k], this.#currentoff);
				this.#currentoff += 4;
			}
		} else if (type === 'SHORT') {
			for (let k = 0; k < l; k++) {
				TIFFOut.writeshorttoout(this.#dyndata, value[k], this.#currentoff);
				this.#currentoff += 2;
			}
		} else if (type === 'SSHORT') {
			for (let k = 0; k < l; k++) {
				if (value[k] < 0) TIFFOut.writeinttoout(this.#dyndata, 65536 + value[k], this.#currentoff);
				else TIFFOut.writeshorttoout(this.#dyndata, value[k], this.#currentoff);
				this.#currentoff += 2;
			}
		} else if (type === 'RATIONAL') {
			for (let k = 0; k < l; k++) {
				TIFFOut.writeinttoout(this.#dyndata, value[2*k], this.#currentoff);
				TIFFOut.writeinttoout(this.#dyndata, value[2*k + 1], this.#currentoff + 4);
				this.#currentoff += 8;
			}
		} else if (type === 'SRATIONAL') {
			for (let k = 0; k < l; k++) {
				if (value[2*k] < 0) TIFFOut.writeinttoout(this.#dyndata, (65536*65536)+value[2*k], this.#currentoff);
				else TIFFOut.writeinttoout(this.#dyndata, value[2*k], this.#currentoff);
				if (value[2*k + 1] < 0) TIFFOut.writeinttoout(this.#dyndata, (65536*65536)+value[2*k + 1], this.#currentoff + 4);
				else TIFFOut.writeinttoout(this.#dyndata, value[2*k + 1], this.#currentoff + 4);
				this.#currentoff += 8;
			}
		}
		else console.log('IFD trying to write unknown typ ' + type);
		this.#entrys.push(e);
	}
}
/* IFDOut: get data for this ifd, shifted to actual offset in file */
getData(offset) {
	let ioff = 0, data = new Uint8Array(this.#imglen + (12 * this.#entrys.length) + this.#currentoff + 16);
	if (this.#imgdata?.byteLength) {
		for (let z=0; z<this.#imgdata.byteLength; z++)
			data[ioff++] = this.#imgdata.getUint8(z);
	} else if (this.#imgdata) {
		for (let z=0; z<this.#imgdata.length; z++)
			data[ioff++] = this.#imgdata[z];
	}
	while (ioff < this.#imglen)
		data[ioff++] = 0;
	TIFFOut.writeshorttoout(data, this.#entrys.length, ioff);
	ioff += 2;
	for (const i of this.#entrys.sort((a,b) => a.tag - b.tag )) {
		let parr = [ 0, 0, 0, 0 ];
		TIFFOut.writeshorttoout(parr, i.tag, 0);
		data.set(parr, ioff);
		TIFFOut.writeshorttoout(parr, i.type, 0);
		data.set(parr, ioff+2);
		TIFFOut.writeinttoout(parr, i.count, 0);
		data.set(parr, ioff+4);
		if (i.tag === 273) { /* strip offsets is set here, subifd (-2), exififd and private stuff outside */
			let parr = [ 0, 0, 0, 0 ];
			TIFFOut.writeinttoout(parr, offset, 0);
			data.set(parr, ioff + 8);
		} else if (i.tag === 34665) { /* exififd */
			this.exifdataptr = offset + ioff + 8;
		} else if (i.tag === 50933) { // camera profiles
			if (undefined !== i.value) // only one, profile ptr fits into value
				this.camprofptr = offset + ioff + 8;
			else {			// more than one, dereference
				let parr = [ 0, 0, 0, 0 ];
				TIFFOut.writeinttoout(parr, i.ptr + offset + this.#imglen + 6 + (12 * this.#entrys.length), 0);
				data.set(parr, ioff + 8);
				this.camprofptr = offset + this.#imglen + i.ptr + 6 + (12 * this.#entrys.length);
			}
		} else if (undefined !== i.value) {
			data.set(i.value, ioff + 8);
		} else {
			let parr = [ 0, 0, 0, 0 ];
			TIFFOut.writeinttoout(parr, i.ptr + offset + this.#imglen + 6 + (12 * this.#entrys.length), 0);
			data.set(parr, ioff + 8);
		}
		ioff += 12;
	}
	let oarr = [ 0, 0, 0, 0 ];
	// next ifd - stays zero if has sub ifd
	data.set(oarr, ioff);
	ioff += 4;
	data.set(this.#dyndata, ioff);
	return data.slice(0, ioff + this.#currentoff);
}
/* IFDOut: tiff directory is placed after image data */
getOffset() {
	return this.#imglen;
}
/* IFDOut: if has sub ifd, then return that */
getNextIfdPosOffset() {
	if (this.hassub) {
		const i = this.#entrys.findIndex(v => v.tag === 330);
		return this.#imglen + 2 + (12 * i) + 8;
	} else {
		return this.#imglen + 2 + (12 * this.#entrys.length);
	}
}
/* Indentation in - end of class IFD */
};
/* *************************************** IFDOut E N D *************************************** */
/* *************************************** TIFFOut *************************************** */
/* main TIFF class */
class TIFFOut {
/* Indentation out */
#ifds = [];
#cameraprofiles = [];
#currentifd = null;
#exifdata = null;
/* TIFFOut: add an ifd  (will set this as current IFD) */
addIfd(issub) {
	if (null !== this.#currentifd) {
		this.#ifds.push(this.#currentifd);
	}
	this.#currentifd = new IFDOut();
	if (issub) this.#currentifd.issub = true;
}
/* TIFFOut: add sub ifd  (will set this as current IFD) */
addSubIfd() {
	if (null !== this.#currentifd) {
		this.#currentifd.hassub = true;
		this.#currentifd.addEntry(330, 'LONG', [ 0xFFFFFFFE ]); /* subifd, special */
	}
	this.addIfd(true);
}
/* TIFFOut: add exif ifd */
addExifIfd(data) {
	this.#currentifd.addEntry(34665, 'LONG', [ 0 ]); /* Exif ifd */
	this.#exifdata = data;
}
/* TIFFOut: add image data to current ifd */
addImageStrip(typ, view, width, height) {
	this.#currentifd.addImageStrip(typ, view, width, height);
}
/* TIFFOut: add an entry to current ifd */
addEntry(tag, type, data) {
	if (this.#cameraprofiles.length > 0) {
		this.#cameraprofiles[this.#cameraprofiles.length - 1].addEntry(tag, type, data);
	} else
		this.#currentifd.addEntry(tag, type, data);
}
/* TIFFOut: map string type to tiff id */
static types = [
	{ n: 'BYTE', t: 1, l: 1 },
	{ n: 'ASCII', t: 2, l: 1 },
	{ n: 'SHORT', t: 3, l: 2 },
	{ n: 'LONG', t: 4, l: 4 },
	{ n: 'RATIONAL', t: 5, l: 8 },
	{ n: 'SBYTE', t: 6, l: 1 },
	{ n: 'UNDEFINED', t: 7, l: 1 },
	{ n: 'SSHORT', t: 8, l: 2 },
	{ n: 'SLONG', t: 9, l: 4 },
	{ n: 'SRATIONAL', t: 10, l: 8 },
	// currently only for parsing exif:
	{ n: 'FLOAT', t: 11, l: 4 },
	{ n: 'DOUBLE', t: 12, l: 8 },
];
/* TIFFOut: map string type to tiff id */
static tToNum(type) {
	return (TIFFOut.types.filter(v =>  v.n === type )[0]);
}
/* TIFFOut: helper function to put integer into dng */
static writeinttoout(out, num, off) {
	TIFFOut.writeshorttoout(out, num % 65536, off);
	TIFFOut.writeshorttoout(out, (Math.floor(num / 65536)) % 65536, off+2);
}
/* TIFFOut: helper function to put short integer into dng */
static writeshorttoout(out, num, off) {
	out[off] = (num % 256);
	out[off + 1] = Math.floor(num / 256) % 256;
}
/* TIFFOut: return the tiff binary data */
getData() {
	let data = new Uint8Array(20000000);
	if (null !== this.#currentifd) {
		this.#ifds.push(this.#currentifd);
	}
	if (this.#cameraprofiles.length > 0) {
		let camprofarr = [];
		for (let j=0; j<this.#cameraprofiles.length; j++) camprofarr.push(1);
		this.#ifds[0].addEntry(50933, 'LONG', camprofarr); /* camera profiles pointer */
	}
	TIFFOut.writeshorttoout(data, 0x4949, 0); // magics
	TIFFOut.writeshorttoout(data, 42, 2);
	let lastoffpos = 4;
	let lastlen = 8;
	for (const i of this.#ifds) {
		TIFFOut.writeinttoout(data, i.getOffset() + lastlen, lastoffpos);
		let d = i.getData(lastlen);
		data.set(d, lastlen);
		lastoffpos = i.getNextIfdPosOffset() + lastlen;
		lastlen += d.length;
	}
	TIFFOut.writeinttoout(data, 0, lastoffpos);
	if (-1 !== this.#ifds[0].camprofptr && this.#cameraprofiles.length > 0) {
		for (let l=0; l<this.#cameraprofiles.length; l++) {
			TIFFOut.writeinttoout(data, lastlen, this.#ifds[0].camprofptr + (4*l));
			let cpd = this.#getCamProfData(this.#cameraprofiles[l]);
			data.set(cpd, lastlen);
			lastlen += cpd.length;
		}
	}
	if (-1 !== this.#ifds[0].exifdataptr && this.#exifdata !== null) {
		TIFFOut.writeinttoout(data, lastlen, this.#ifds[0].exifdataptr);
		let lastbase = lastlen, aoff = 2;
		let nent = TIFFOut.readshorta(this.#exifdata,0);
		TIFFOut.writeshorttoout(data, nent, lastlen);
		lastlen += 2;
		for (let j = 0; j < nent; j++) {
			let tag = TIFFOut.readshorta(this.#exifdata, aoff+0);
			let typ = TIFFOut.readshorta(this.#exifdata, aoff+2);
			let num = TIFFOut.readinta(this.#exifdata, aoff+4);
			let addr = TIFFOut.readinta(this.#exifdata, aoff+8);
			aoff += 12;
			let ee = TIFFOut.types.find(e => e.t === typ);
			if (undefined === ee) {
				console.log('EXIFOUT: TYP NOT FOUND ' + typ);
				continue;
			}
			TIFFOut.writeshorttoout(data, tag, lastlen);
			lastlen += 2;
			TIFFOut.writeshorttoout(data, typ, lastlen);
			lastlen += 2;
			TIFFOut.writeinttoout(data, num, lastlen);
			lastlen += 4;
			if (ee.l * num <= 4) {
				TIFFOut.writeinttoout(data, addr, lastlen);
			}
			else {
				// correct the addresse
				TIFFOut.writeinttoout(data, addr + lastbase, lastlen);
			}
			lastlen += 4;
		}
		for (let k = aoff; k<this.#exifdata.length; k++)
			data[lastlen++] = this.#exifdata[k];
	}
	return data.slice(0, lastlen);
}
// TIFFOut: add extra camera profile (will set this as current IFD), must go behind all other IFDs
createCamProf(name) {
	this.#cameraprofiles.push(new IFDOut());
	this.#cameraprofiles[this.#cameraprofiles.length - 1].addEntry(50936, 'ASCII', name); /* profile name */
}
/* TIFFOut: get camera profile data analog to ifd */
#getCamProfData(p) {
	let d = p.getData(8);
	let camprofbuf = new Uint8Array(d.length + 8);
	TIFFOut.writeshorttoout(camprofbuf, 0x4949, 0); // magics
	TIFFOut.writeshorttoout(camprofbuf, 0x4352, 2);
	TIFFOut.writeinttoout(camprofbuf, 8, 4);
	camprofbuf.set(d, 8);
	return camprofbuf.slice(0, 8 + d.length);
}
/* TIFFOut: helper to read dng or exif */
static readshort(view, off) {
	let res = view.getUint8(off);
	res += (256 * view.getUint8(off+1));
	return res;
}
/* TIFFOut: helper to read dng or exif */
static readint(view, off) {
	let res = TIFFOut.readshort(view, off);
	res += (65536 * TIFFOut.readshort(view,off+2));
	return res;
}
/* TIFFOut: helper to read dng or exif */
static readshorta(arr, off) {
	let res = arr[off];
	res += (256 * arr[off+1]);
	return res;
}
/* TIFFOut: helper to read dng or exif */
static readinta(arr, off) {
	let res = TIFFOut.readshorta(arr, off);
	res += (65536 * TIFFOut.readshorta(arr,off+2));
	return res;
}
/* Indentation in - end of class TIFFOut */
}
/* *************************************** TIFFOut E N D *************************************** */
/* *************************************** Backward helper class *************************************** */
class ImBCBackw {
/* Indentation out */
constructor (imbcout) {
	this.imbc = imbcout;
}
/* ImBCBackw: backward: handle dng like raw */
static parseDng(f, onok, onerr) {
	// blindly assumes that it is one of our own DNG
	if (undefined === f.data) {
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = (evt) => {
			f.data = evt.target.result;
			ImBCBackw.parseDng(f, onok, onerr);
		}
		reader.onerror = () => { onerr(f.name); };
		reader.readAsArrayBuffer(f);
		return;
	}
	const v = new DataView(f.data);
	const ifd = TIFFOut.readint(v, 4);
	const zz = ImBCBase.infos.findIndex(v => v.size === ifd - 8);
	const nent = TIFFOut.readshort(v, ifd);
	let subifdstart = -1, rawstripstart = -1, datalen = -1;
	let off = ifd+2;
	if (TIFFOut.readshort(v, 2) !== 42 || TIFFOut.readshort(v,0) !== 18761 /* 0x4949 */ || zz === -1) {
		// seek sub ifd then therein the stripoffsets
		for (let k=0; k<((nent<50)? nent: 0); k++) {
			let tag = TIFFOut.readshort(v, off);
			if (tag === 330) {
				subifdstart = TIFFOut.readint(v, off+8);
				break;
			}
			off += 12;
		}
		if (-1 !== subifdstart) {
			let subnent = TIFFOut.readshort(v, subifdstart);
			off = subifdstart + 2;
			for (let j=0; j<((subnent < 50)? subnent: 0); j++) {
				let stag = TIFFOut.readshort(v, off);
				if (stag === 273) {
					rawstripstart = TIFFOut.readint(v, off+8);
					break;
				}
				off += 12;
			}
			if (-1 !== rawstripstart) {
				datalen = subifdstart - rawstripstart;
				const zzz = ImBCBase.infos.findIndex(v => v.size === datalen);
				if (-1 === zzz) {
					this.imbc.appmsg('Works only for originally created DNGs.', true);
					return onerr(f.name);
				}
			}
			else {
				this.imbc.appmsg('Works only for originally created DNGs.', true);
				return onerr(f.name);
			}
		}
		else {
			this.imbc.appmsg('Works only for originally created DNGs.', true);
			return onerr(f.name);
		}
	}
	else {
		rawstripstart = 8;
		datalen = ifd - 8;
	}
	let fx = {
		imbackextension: true,
		name: f.name.substring(0, f.name.length - 4) + '.raw',
		size: datalen,
		data: f.data.slice(rawstripstart, datalen + rawstripstart)
	};
	/*off = ifd+2;
	for (let k=0; k<((nent<50)? nent: 0); k++) {
		let tag = ImBCBackw.readshort(v, off);
		if (tag === 274)
			fx.rot = ImBCBackw.readshort(v, off+8); // rotation handling has problems
		else if (tag === 306) {
			fx.datestr = '';
			let xoff = ImBCBackw.readint(v, off+8);
			const len = ImBCBackw.readshort(v, off+4)-1;
			for (let j=0; j<len;j++)
				fx.datestr += String.fromCharCode(v.getUint8(xoff++));
		}
		off += 12;
	}*/
	fx.readAsArrayBuffer = (fy) => {
		fy.onload({
				target: { result: fy.data }
		});
	};
	setTimeout(() => {
			onok(f.name, fx, fx.rot);
	});
}
/* ImBCBackw: backward: actual processing function for one file */
handleone(fx) {
	const f = (fx !== undefined) ? fx : this.imbc.allfiles[this.imbc.actnum];
	if (undefined === f) {
		this.imbc.appmsgxl(true, 'process.nothing');
		return this.imbc.handlenext();
	}
	if (undefined === f.size) {
		setTimeout(() => {
		  this.imbc.resolver(f, (url, fx) => {
				this.imbc.allfiles[this.imbc.actnum] = fx;
				this.handleone(fx);
			}, (url) => {
				this.imbc.mappx(false, 'words.sorryerr');
				this.imbc.appmsgxl(true, 'process.erraccess', url);
				this.imbc.stats.error ++;
				this.imbc.handlenext();
		  });
		});
		return;
	}
	let rawname = ImBCBase.basename(f.name);
	if (rawname.substring(rawname.length -4).toUpperCase() === '.DNG') {
		ImBCBackw.parseDng(f,
			(name, fx) => {
				this.handleone(fx);
			},
			() => {
				this.imbc.appmsg('Error reading DNG: ' + f.name);
				this.imbc.handlenext();
				this.imbc.stats.error++;
			});
		return;
	}
	else if (rawname.substring(rawname.length -4).toUpperCase() !== '.RAW') {
		this.imbc.appmsg("[" + (1 + this.imbc.actnum) + " / " + this.imbc.totnum + "] ", false);
		this.imbc.appmsg('Seems not to be DNG: ' + f.name, true);
		this.imbc.stats.error++;
		return this.imbc.handlenext();
	}
	const zz = ImBCBase.infos.findIndex(v => v.size === f.size);
	if (zz !== -1) {
		this.imbc.appmsg("[" + (1 + this.imbc.actnum) + " / " + this.imbc.totnum + "] ");
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = (evt) => {
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<view.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			this.imbc.writefile(rawname, 'application/octet-stream', 'process.converted', out);
		}
		reader.onerror = (evt) => {
			console.log('Unk-RAW process reader error for ' + f.name + ' ' + JSON.stringify(evt));
			this.imbc.appmsg('Error processing or reading file ' +  f.name, true);
			this.imbc.stats.error++;
			this.imbc.handlenext();
		}
		reader.readAsArrayBuffer(f);
	} else {
		this.imbc.appmsg("[" + (1 + this.imbc.actnum) + " / " + this.imbc.totnum + "] ", false);
		this.imbc.appmsg('Size of raw data of ' + f.name + ' seems not to match known formats, ignoring...', true);
		this.imbc.stats.error++;
		this.imbc.handlenext();
	}
}
/* Indentation in - end of class ImBCBackw */
}
/* *************************************** Backward helper class E N D *************************************** */
/* *************************************** Main class *************************************** */
class ImBCBase {
/* Indentation out */
static version = "V3.7.6_dev"; // actually const
static alllangs = [ 'de' , 'en', 'fr', 'ru', 'ja', '00' ]; // actually const
static texts = { // actually const
	langs: { de: 'DE', en: 'EN', fr: 'FR' , ru: 'RU', ja: 'JA' },
	words: {
		error: {
			de: '\u001b[31m\u001b[1mFEHLER:\u001b[0m ',
			en: '\u001b[31m\u001b[1mERROR:\u001b[0m ',
			fr: '\u001b[31m\u001b[1mERREUR:\u001b[0m ',
			ja: '\u001b[31m\u001b[1mã‚¨ãƒ©ãƒ¼:\u001b[0m ',
			htmlstyle: [ [ 'background-color','#ffdddd' ], [ 'font-weight', 'bold' ] ]
		},
		warning: {
			de: '\u001b[31mWarnung:\u001b[0m ',
			en: '\u001b[31mWarning:\u001b[0m ',
			fr: '\u001b[31mAvertissement:\u001b[0m ',
			ja: '\u001b[31mè­¦å‘Š:\u001b[0m',
			htmlstyle: [ [ 'background-color','#ffdddd' ] ]
		},
		finished: {
			de: '\u001b[32m\u001b[1mFertig!\u001b[0m ',
			en: '\u001b[32m\u001b[1mFinished!\u001b[0m ',
			fr: '\u001b[32m\u001b[1mFini!\u001b[0m ',
			ja: '\u001b[32m\u001b[1mçµ‚äº†!\u001b[0m ',
			htmlstyle: [ [ 'background-color','#ddffdd' ], [ 'font-weight', 'bold' ] ]
		},
		sorryerr: {
			de: '\u001b[31m\u001b[1mENTSCHULDIGUNG! FEHLER:\u001b[0m ',
			en: '\u001b[31m\u001b[1mSORRY! ERROR:\u001b[0m  ',
			fr: '\u001b[31m\u001b[1mDÃ‰SOLÃ‰E! ERREUR:\u001b[0m ',
			ja: '\u001b[31m\u001b[1mç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“! ã‚¨ãƒ©ãƒ¼:\u001b[0m  ',
			htmlstyle: [ [ 'background-color','#ffdddd' ], [ 'font-weight', 'bold' ] ]
		},
		sorry: {
			de: '\u001b[31mENTSCHULDIGUNG!\u001b[0m ',
			en: '\u001b[31mSORRY!\u001b[0m  ',
			fr: '\u001b[31mDÃ‰SOLÃ‰E!\u001b[0m ',
			ja: '\u001b[31mç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“!\u001b[0m  ',
			htmlstyle: [ [ 'background-color','#ffdddd' ], [ 'font-weight', 'bold' ] ]
		}
	},
	main: {
		coloursyourrisk: {
			de: 'Bei Farben bin ich raus! Eigenes Risiko, fraach mich net!',
			en: 'About colurs, I am out! Own risk, do not ask me!',
			fr: 'About colurs, I am out! Own risk, do not ask me!',
			ja: 'è‰²ã«ã¤ã„ã¦ã¯ã€ã‚¢ã‚¦ãƒˆã§ã™ï¼ è‡ªå·±è²¬ä»»ã§ã™ã®ã§ã€ç§ã«å°‹ã­ãªã„ã§ãã ã•ã„ã€‚'
		},
		title: {
			de: 'ImB RAW nach DNG Konverter',
			en: 'ImB RAW to DNG converter',
			fr: 'Convertisseur ImB RAW a DNG',
			ru: 'ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚ĞµÑ€ ImB RAW Ğ² DNG',
			ja: 'ImB RAW ã‚’ DNG ã«å¤‰æ›'
		},
	    backw: {
			   title:  { en: 'ImB DNG to RAW back converter' },
			   generaladvice: { en: 'Only works for the exact original converted DNG.' },
			   selectdng: { en: 'Select orig. DNG' },
			   drophere: { en: 'Drop DNGs here' }
	    },
		help: {
			de: '? Hilfe Doku',
			en: '? Help Doc',
			fr: '? Aide Doc',
			ru: '? ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ Ğ”Ğ¾Ğº',
			ja: '? ãƒ˜ãƒ«ãƒ—è³‡æ–™'
		},
		helplink: {
			de: 'https://shyrodgau.github.io/imbraw2dng/README_de',
			en: 'https://shyrodgau.github.io/imbraw2dng/',
			fr: 'https://shyrodgau.github.io/imbraw2dng/',
			ja: 'https://shyrodgau.github.io/imbraw2dng/README_ja'
		},
		generaladvice: {
			de: 'Daten werden nur im Browser verarbeitet, nicht im \'Internet\'.<br>Kann sein, dass der Browser fragt, ob Sie zulassen wollen, dass mehrere Dateien heruntergeladen werden.<br>Dateien, die nicht oder unbekannte RAW-Dateien sind, werden 1:1 kopiert.',
			en: 'Data processing is entirely in the browser, not in \'the internet\'<br>Browser may ask you if you want to allow downloading multiple files.<br>Not or unrecognized RAW Files simply will be copied.',
			fr: 'L\'information est entiÃ¨rement traitÃ©e dans le navigateur et non sur \'Internet\'<br>Le navigateur peux questionner que vous acceptez le tÃ©lÃ©chargement de beaucoup de fiches.<br>Fiches pas-RAW ou RAW inconnue sont copiÃ©e 1:1.',
			ru: 'Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ² Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ, Ğ° Ğ½Ğµ Ğ² \'Ğ˜Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ğµ\'.<br>Ğ‘Ñ€Ğ°ÑƒĞ·ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ, Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ»Ğ¸ Ğ²Ñ‹ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ².<br>Ğ¤Ğ°Ğ¹Ğ»Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ Ğ¸Ğ»Ğ¸ Ğ½ĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¼Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°Ğ¼Ğ¸ RAW, ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒÑÑ‚ÑÑ 1:1.',
			ja: 'ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã¯å®Œå…¨ã«ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§è¡Œã‚ã‚Œã€\'ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ\'ã§ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚<br>ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã‚Šè¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’è¨±å¯ã™ã‚‹ã‹ã‚’å°‹ã­ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚<br>RAW ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã€ã¾ãŸã¯èªè­˜ã•ã‚Œãªã„å ´åˆã¯ã€å˜ç´”ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚'
		},
		drophere: {
			de: 'Dateien von ImB hier ablegen: ',
			en: 'Drop Files from ImB here: ',
			fr: 'Posez fiches de ImB ici: ',
			ru: 'Ğ¥Ñ€Ğ°Ğ½Ğ¸Ñ‚Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¸Ğ· ImB Ğ·Ğ´ĞµÑÑŒ: ',
			ja: 'ã“ã“ã« ImB ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¾ã™ã€‚: '
		},
		selectraw: {
			de: 'Oder diese Seite per WLAN <a href=\'https://github.com/shyrodgau/imbraw2dng/blob/master/moredoc_de.md#gucken-auf-imback-selbst\'>direkt von ImB</a> verwenden.<br>Oder <tt>.RAW</tt> Datei(en) auswÃ¤hlen:',
			en: 'Or use this page via Wifi <a href=\'https://github.com/shyrodgau/imbraw2dng/blob/master/moredoc.md#browsing-on-the-imback\'>directly from ImB</a>.<br>Or select <tt>.RAW</tt> File(s):',
			fr: 'Ou utiliez cette page <a href=\'https://github.com/shyrodgau/imbraw2dng/blob/master/moredoc.md#browsing-on-the-imback\'>via Wifi sur ImB</a>.<br>Ou selectez <tt>.RAW</tt> fiche(s):',
			ru: 'Ğ˜Ğ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑÑ‚Ñƒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ Ñ‡ĞµÑ€ĞµĞ· Wi-Fi <a href=\'https://github.com/shyrodgau/imbraw2dng/blob/master/moredoc.md#browsing-on-the-imback\'>Ğ¿Ñ€ÑĞ¼Ğ¾ Ğ¸Ğ· ImB</a>.<br>Ğ˜Ğ»Ğ¸ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ„Ğ°Ğ¹Ğ»(Ñ‹) <tt>RAW</tt>:',
			ja: 'ã¾ãŸã¯ã€Wifi çµŒç”±ã§ <a href=\'https://github.com/shyrodgau/imbraw2dng/blob/master/moredoc_ja.md#imback-ã§ã®é–²è¦§\'>ImB ã‹ã‚‰ç›´æ¥</a>ã“ã®ãƒšãƒ¼ã‚¸ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚<br> ã¾ãŸã¯ã€ <tt>.RAW</tt> ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¾ã™ã€‚:'
		},
		stillcounting: {
			de: '... zÃ¤hle ... ',
			en: '... counting ... ',
			fr: '... compter ...',
			ru: '... Ğ¿Ğ¾Ğ´ÑÑ‡ĞµÑ‚ ...',
			ja: '... ã‚«ã‚¦ãƒ³ãƒˆä¸­ ... '
		},
		types: {
			rawpics: {
				de: 'RAW Bilder',
				en: 'RAW Pictures',
				fr: 'RAW images',
				ja: 'RAW ç”»åƒ'
			},
			jpgpics: {
				de: 'JPEG-Bilder',
				en: 'JPEG Pictures',
				fr: 'JPEG images',
				ja: 'JPEG ç”»åƒ'
			},
			other: {
				de: 'Andere',
				en: 'Other',
				fr: 'Autre',
				ja: 'ãã®ä»–'
			},
			notpic: {
				de: 'Keine Bilder',
				en: 'Not pictures',
				fr: 'Pas images',
				ja: 'ç”»åƒã§ã¯ãªã„'
			}
		},
		file: {
			jpeg: {
				de: 'Datei $$0 (JPEG)',
				en: 'File $$0 (JPEG)',
				fr: 'Fiche $$0 (JPEG)',
				ja: 'ãƒ•ã‚¡ã‚¤ãƒ« $$0 (JPEG)'
			},
			nopreview: {
				de: 'Datei $$0<br>Nicht jpeg oder raw, keine Vorschau...',
				en: 'File $$0<br>Not jpeg or raw, no preview...',
				fr: 'Fiche $$0<br>Ni jpeg ni raw, pas de aperÃ§u...',
				ja: 'ãƒ•ã‚¡ã‚¤ãƒ« $$0<br>jpeg ã¾ãŸã¯ã€raw ä»¥å¤–ã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãªã—...'
			},
			rawunknown: {
				de: 'Datei $$0<br>Unerkannte RAW DateigrÃ¶ÃŸe $$1, bitte Entwickler kontaktieren! Keine Vorschau...',
				en: 'File $$0<br>Unknown raw size $$1, please contact developer! No preview...',
				fr: 'Fiche $$0<br>taille de fiche $$1 non reconnue, contacter le dÃ©veloppeur, pas de aperÃ§u...',
				ja: 'File $$0<br>ä¸æ˜ãª raw ã‚µã‚¤ã‚º $$1, é–‹ç™ºè€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„! ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãªã—...'
			},
			dngimpnote: {
				de: 'Import eines DNG geht nur, wenn diese genau das hiermit erzeugte Original ist.',
				en: 'Re-import of a DNG is only possible if this is exactly the original that was created here.',
				fr: 'La rÃ©importation d\'un DNG n\'est possible que s\'il s\'agit exactement de l\'original crÃ©Ã© ici.',
				ja: 'DNG ã®å†ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¯ã€ã“ã‚ŒãŒã“ã“ã§ä½œæˆã•ã‚ŒãŸã‚ªãƒªã‚¸ãƒŠãƒ«ã§ã‚ã‚‹å ´åˆã«ã®ã¿å¯èƒ½ã§ã™ã€‚'
			},
			de: 'Datei $$0',
			en: 'File $$0',
			fr: 'Fiche $$0',
			ja: 'ãƒ•ã‚¡ã‚¤ãƒ« $$0'
		},
		sort: {
			de: 'Sortiere',
			en: 'Sort:',
			fr: 'Trier:',
			ja: 'ã‚½ãƒ¼ãƒˆ:'
		},
		or: {
			de: 'Oder ',
			en: 'Or ',
			fr: 'Ou ',
			ja: 'ã¾ãŸã¯ '
		},
		log: {
			de: 'Protokoll-Ausgabe:',
			en: 'Message Log:',
			fr: 'Journal des messages',
			ja: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ãƒ­ã‚°:'
		},
		selected: {
			de: 'AusgewÃ¤hlt',
			en: 'Selected',
			fr: 'SÃ©lectionnÃ©(s)',
			ja: 'é¸æŠæ¸ˆã¿'
		},
		fakelong: {
			en: 'Fake long exposure by adding up all (<a href="https://shyrodgau.github.io/imbraw2dng/moredoc#a-lot-more-tricks-and-details">read more</a>)',
			de: 'Langzeitbelichtung durch Addieren simulieren (<a href="https://shyrodgau.github.io/imbraw2dng/moredoc_de#mehr-tricks-und-details">mehr lesen</a>)',
			scale: {
				en: 'Scale values down',
				de: 'Werte dabei herunterskalieren'
			},
			added: {
				en: 'Added picture $$0',
				de: 'Bild $$0 hinzugefÃ¼gt'
			}
		},
		usezip: {
			de: 'Nicht mehrere Dateien einzeln, sondern in einem ZIP Archiv herunteladen. Ziel kann ausgewÃ¤hlt werden.',
			en: 'Do not use several single downloads, but all in one ZIP archive. Destination can be chosen.'
		}
	},
	browser: {
		bytype: {
			de: 'nach Typ',
			en: 'by type',
			fr: 'par type',
			ja: 'ç¨®é¡åˆ¥'
		},
		olderfirst: {
			de: 'Ã„ltere nach oben',
			en: 'Older first',
			fr: 'Plus anciens ci-dessus',
			ja: 'å¤ã„é †'
		},
		selall: {
			tooltip: {
				de: 'Wenn Haken nicht gesetzt, wÃ¤hle alles aus. Bei Klick wenn angehakt setze Auswahl auf Nichts.',
				en: 'If not selected then select all. If it is selected and clicked then unselect all.',
				fr: 'S\'il n\'est pas sÃ©lectionner, sÃ©lectionner tout. Au clic si sÃ©lectionnÃ©, vider la sÃ©lection',
				ja: 'é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã™ã¹ã¦ã‚’é¸æŠã—ã¾ã™ã€‚ é¸æŠã—ã¦ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ã€ã™ã¹ã¦ã®é¸æŠã‚’è§£é™¤ã—ã¾ã™ã€‚'
			},
			de: 'Alle de-/ oder selektieren',
			en: 'De-/select all',
			fr: 'De-/sÃ©lectionner tout',
			ja: 'ã™ã¹ã¦ã®é¸æŠã‚’è§£é™¤'
		},
		procall: {
			de: 'Alle ausgewÃ¤hlte kopieren/verarbeiten',
			en: 'Copy/process all selected',
			fr: 'Traiter les sÃ©lectionnÃ©s',
			ja: 'é¸æŠã—ãŸã‚‚ã®ã‚’ã™ã¹ã¦ã‚³ãƒ”ãƒ¼/å‡¦ç†'
		},
		delall: {
			de: 'Alle ausgewÃ¤hlte lÃ¶schen',
			en: 'Delete all selected',
			fr: 'Supprimer les sÃ©lectionnÃ©s',
			ja: 'é¸æŠã—ãŸã‚‚ã®ã‚’ã™ã¹ã¦å‰Šé™¤'
		},
		settingsset: {
			en: 'Preferences are set for source $$0',
			de: 'Voreinstellungen fÃ¼r $$0 gespeichert'
		},
		prefnotfile: {
			en: 'Preferences not possible for file:// URLs',
			de: 'Voreinstellungen fÃ¼r file:// URLs nicht mÃ¶glich'
		},
		setfrom: {
			en: 'Set new prefereneces ',
			de: 'Voreinstellungen setzen '
		},
		forurl: {
			en: ' for URL $$0',
			de: ' fÃ¼r URL $$0'
		}
	},
	onimback: {
		connected: {
			de: 'ImB Verbunden! ',
			en: 'ImB Connected! ',
			fr: 'ImB ConnectÃ©! ',
			ja: 'ImB æ¥ç¶šæ¸ˆã¿! '
		},
		dlconvert: {
			de: 'Konvertiere / Lade herunter: ',
			en: 'Download / convert: ',
			fr: 'Telecharger / convertir',
			ja: 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ / å¤‰æ›: '
		},
		totalnum: {
			de: 'gesamt:',
			en: 'total:',
			fr: 'total:',
			ja: 'åˆè¨ˆ:'
		},
		fromtime: {
			de: 'ab Zeitstempel bzw. jÃ¼nger als ',
			en: 'from timestamp or younger than ',
			fr: 'Ã  partir de l\'horodatage ou plus jeune que ',
			ja: 'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»¥é™ã¾ãŸã¯ãã‚Œã‚ˆã‚Šå¤ã„ '
		},
		nullforall: {
			de: '0000 oder leer fÃ¼r \'alle\'',
			en: '0000 or empty for \'all\'',
			fr: '0000 ou dÃ©poser pour \'tout\'',
			ja: '0000 ã¾ãŸã¯ã€ \'ã™ã¹ã¦\' ç©º '
		},
		doit: {
			de: 'Mach es',
			en: 'Do it',
			fr: 'Fais-le',
			ja: 'å®Ÿè¡Œ'
		},
		visual: {
			de: 'Bild-Browser benutzen',
			en: 'Use visual Picture Browser',
			fr: 'Ou outilizer navigateur visuel des images',
			ja: 'ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãªç”»åƒãƒ–ãƒ©ã‚¦ã‚¶ã‚’ä½¿ç”¨ã™ã‚‹'
		},
		errconnect: {
			de: '\u001b[31mFEHLER\u001b[0m bei der Verbindung zu ImB auf $$0! Im ImB WLAN?',
			en: '\u001b[31mERROR\u001b[0m connecting to ImB on $$0! In the ImB WiFi?',
			fr: '\u001b[31mERREUR\u001b[0m lors de la connexion Ã  imback. Dans le Wifi ImB?',
			ja: '\u001b[31mã‚¨ãƒ©ãƒ¼\u001b[0m $$0 ã§ImB ã«æ¥ç¶šã—ã¦ã„ã¾ã™! ImB WiFi ã§ã™ã‹?'
		},
		nomatch: {
			de: 'Keine passenden Dateien gefunden. Kann vorÃ¼bergehend sein.',
			en: 'No matching files found. Might be temporary.',
			fr: 'Aucun fiche correspondant trouvÃ©. Peut-etre temporaire.',
			ja: 'ä¸€è‡´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ ä¸€æ™‚çš„ãªã‚‚ã®ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚'
		},
		strangename: {
			de: 'Komischer Dateiname: $$0',
			en: 'Strange file name: $$0',
			fr: 'Nom de fiche inhabituel: $$0',
			ja: 'ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å: $$0'
		},
		invaltime: {
			de: 'UngÃ¼ltiger Zeitstempel: $$0',
			en: 'Invalid timestamp: $$0',
			fr: 'Horodatage invalide: $$0',
			ja: 'ç„¡åŠ¹ãªã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—: $$0'
		},
	},
	process: {
		singlestep: {
			de: 'Einzelschritt mit Vorschau',
			en: 'Single Step with preview',
			fr: 'Seule Ã©tape avec aperÃ§u',
			ja: 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚ã‚Šã§ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ†ãƒƒãƒ—'
		},
		addcopyright: {
			en: 'Add copyright',
			de: 'Copyright hinzufÃ¼gen'
		},
		nothing: {
			de: 'Nichts ausgewÃ¤hlt.. ?',
			en: 'Nothing selected...?',
			fr: 'Rien de sÃ©lectionnÃ©',
			ja: 'ä½•ã‚‚é¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“...?'
		},
		erraccess: {
			de: 'beim Zugriff auf $$0.',
			en: 'occured accessing $$0.',
			fr: 'lors de l\'accÃ¨s Ã  $$0.',
			ja: '>ã‚¢ã‚¯ã‚»ã‚¹ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ $$0.'
		},
		notraw: {
			de: 'Durchleitung weil nicht raw: $$0',
			en: 'Passing through as not raw: $$0',
			fr: 'Passage comme non RAW: $$0',
			ja: 'RAW ã§ã¯ãªã„ã®ã§ã‚¹ãƒ«ãƒ¼: $$0'
		},
		selectedn: {
			de: '$$0 Datei(en) wurden ausgewÃ¤hlt.',
			en: 'Got $$0 file(s) selected.',
			fr: '$$0 fiche(s) sÃ©lectionnÃ©(s)',
			ja: '$$0 ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚'
		},
		copyokcheckdl: {
			de: 'Nach $$0 kopiert (Downloads-Ordner prÃ¼fen)</b>&nbsp;',
			en: 'Copied to $$0 (Check Downloads Folder)</b>&nbsp;',
			fr: 'CopiÃ© sur $$0 (VÃ©rifier le dossier de tÃ©lÃ©chargements/Downloads)</b>&nbsp;',
			ja: '$$0 ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸ (ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’ç¢ºèª)</b>&nbsp;'
		},
		copyok: {
			de: 'Nach $$0 kopiert',
			en: 'Copied to $$0',
			fr: 'CopiÃ© sur $$0',
			ja: '$$0 ã«ã‚³ãƒ”ãƒ¼'
		},
		errorreadingfile: {
			de: 'beim Lesen der Datei $$0',
			en: 'occured reading file $$0',
			fr: 'de lecture du fiche $$0',
			ja: 'ãƒ•ã‚¡ã‚¤ãƒ« $$0 ã®èª­ã¿å–ã‚Šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ '
		},
		unknownsize: {
			de: 'Die DateigrÃ¶ÃŸe <b>$$1</b> passt zu keinem bekannten Format. Bitte Entwickler kontaktieren!',
			en: 'File Size <b>$$1</b> does not match known formats. Please contact developer!',
			fr: 'La taille du fiche $$1 ne correspond pas au format connu. Veuillez contacter le dÃ©veloppeur',
			ja: 'ãŒã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º <b>$$1</b> ã¯æ—¢çŸ¥ã®å½¢å¼ã¨ä¸€è‡´ã—ã¾ã›ã‚“ã€‚é–‹ç™ºè€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚'
		},
		processing: {
			de: 'Verarbeite Datei: $$0 ',
			en: 'Processing file: $$0',
			fr: 'Je suis en train de traiter le fiche $$0',
			ja: 'å‡¦ç†ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«: $$0'
		},
		assuming: {
			de: 'Annahme: $$0 $$1',
			en: 'Assuming $$0 $$1',
			fr: 'HypothÃ¨se: $$0 $$1',
			ja: 'èªè­˜ $$0 $$1'
		},
		datetime: {
			de: 'Datum/Zeit: $$0',
			en: 'Date/Time: $$0 ',
			fr: 'Date/heure: $$0',
			ja: 'æ—¥ä»˜/æ™‚åˆ»: $$0 '
		},
		orientation: {
			de: 'Drehung: $$0',
			en: 'Orientation: $$0',
			fr: 'Rotation: $$0',
			ja: 'å‘ã: $$0'
		},
		convertedcheckdl: {
			de: 'Nach $$0 konvertiert (Downloads-Ordner prÃ¼fen)',
			en: 'Converted to $$0 (Check Downloads Folder)',
			fr: 'Converti en $$0 (VÃ©rifier le dossier de tÃ©lÃ©chargements/Downloads)',
			ja: '$$0 ã«å¤‰æ›ã•ã‚Œã¾ã—ãŸ (ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„)'
		},
		converted: {
			de: 'Nach $$0 konvertiert',
			en: 'Converted to $$0',
			fr: 'Converti en $$0',
			ja: '$$0 ã«å¤‰æ›'
		},
		errsave: {
			de: 'Konnte Datei $$0 nicht speichern.',
			en: 'Could not write file $$0',
			fr: 'Impossible d\'Ã©crire le fiche $$0.',
			ja: 'ãƒ•ã‚¡ã‚¤ãƒ« $$0 ã«æ›¸ãè¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ'
		},
		droppedn: {
			de: '$$0 Datei(en) wurden abgelegt.',
			en: 'Got $$0 file(s) dropped.',
			fr: '$$0 fiche(s) ont Ã©tÃ© stockÃ©s',
			ja: '$$0 å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚'
		},
		frombackn: {
			de: '$$0 Datei(en) vom ImB zu verarbeiten.',
			en: 'Got $$0 file(s) from ImB.',
			fr: 'J\'ai reÃ§u $$0 fiche(s) d\'ImB',
			ja: 'ImB ã‹ã‚‰ $$0 ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã—ãŸã€‚'
		},
		frombrowsern: {
			de: '$$0 Datei(en) vom Bild-Browser zu verarbeiten.',
			en: 'Got $$0 file(s) from Visual browser.',
			fr: 'J\'ai obtenu $$ fiche(s) du navigateur visuel',
			ja: 'ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ« ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰ $$0 ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã—ãŸã€‚'
		},
		skipped: {
			remaining: {
				de: 'Verbleibende $$0 Dateien auf Anforderung Ã¼bersprungen',
				en: 'Skipping remaining $$0 images at your request',
				fr: '$$0 fiches restants ignorÃ©s sur demande',
				ja: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¿œã˜ã¦ã‚¹ã‚­ãƒƒãƒ—: $$0'
			},
			de: 'Auf Anforderung Ã¼bersprungen: $$0',
			en: 'Skipped at your request: $$0',
			fr: 'IgnorÃ© Ã  votre demande: $$0',
			ja: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¿œã˜ã¦æ®‹ã‚Šã® $$0 ç”»åƒã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™'
		},
		totals: {
			en: 'Total: $$0, ok: $$1, skipped: $$2, Errors: $$3',
			de: 'Total: $$0, ok $$1, Ã¼bersprungen: $$2, Fehler: $$3',
			fr: 'Total: $$0, ok: $$1, IgnorÃ©: $$2, Erreur: $$3',
			ja: 'åˆè¨ˆ $$0ã€OK $$1ã€ã‚¹ã‚­ãƒƒãƒ— $$2ã€ã‚¨ãƒ©ãƒ¼ $$3'
		},
		addpreview: {
			en: 'Add preview thumbnail to DNG',
			de: 'Kleines Vorschaubild im DNG',
			fr: 'Petite image d\'aperÃ§u en DNG'
		},
		addexif: {
			en: 'Add EXIF data from $$0',
			de: 'Gebe EXIF Daten von $$0 dazu'
		}
	},
	preview: {
		err: {
			de: 'Fehler bei Vorschau :-(',
			en: 'Error with Preview :-(',
			fr: 'Erreur dans l\'aperÃ§u :-(',
			ja: 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã®ã‚¨ãƒ©ãƒ¼ :-('
		},
		rotcw: {
			de: 'im Uhrzeigersinn drehen',
			en: 'Rotate clockwise',
			fr: 'tourner dans le sens des aiguilles d\'une montre',
			ja: 'æ™‚è¨ˆå›ã‚Šã«å›è»¢'
		},
		rotccw: {
			de: 'gegen den Uhrzeigersinn drehen',
			en: 'rotate counterclockwise',
			fr: 'tourner dans le sens inverse des aiguilles d\'une montre',
			ja: 'åæ™‚è¨ˆå›ã‚Šã«å›è»¢'
		},
		rot180: {
			de: 'auf den Kopf',
			en: 'Rotate 180Â°',
			fr: 'retournÃ©',
			ja: '180Â°å›è»¢'
		},
		rotreset: {
			de: 'Drehung zurÃ¼cksetzen',
			en: 'Reset',
			fr: 'RÃ©initialiser la rotation',
			ja: 'ãƒªã‚»ãƒƒãƒˆ',
			tooltip: {
				de: 'UrsprÃ¼ngliche Bildausrichtung wiederherstellen',
				en: 'Reset original image orientation',
				fr: 'Restaurer l\'orientation originale de l\'image',
				ja: 'å…ƒã®ç”»åƒã®å‘ãã«ãƒªã‚»ãƒƒãƒˆ'
			}
		},
		process: {
			de: 'Kopieren/Konvertieren',
			en: 'Copy/Convert',
			fr: 'Copie/Convertir',
			ja: 'å…ƒã®ç”»åƒã®å‘ãã«ãƒªã‚»ãƒƒãƒˆ'
		},
		skip: {
			de: 'Ãœberspringen',
			en: 'Skip',
			fr: 'Sauter',
			ja: 'ã‚³ãƒ”ãƒ¼/å¤‰æ›'
		},
		forall: {
			de: 'FÃ¼r alle weiteren das selbe',
			en: 'Do this for all following',
			fr: 'Faites ceci pour tous les suivants',
			ja: 'ä»¥ä¸‹ã®ã™ã¹ã¦ã«å¯¾ã—ã¦ã“ã‚Œã‚’å®Ÿè¡Œã—ã¾ã™'
		},
		orients: {
			none: {
				de: 'keine',
				en: 'none',
				fr: 'aucune',
				ja: 'ãªã—'
			},
			upsidedown: {
				de: '180Â°',
				en: '180Â°',
				ja: '180Â°',
				fr: '180Â°'
			},
			clockwise: {
				de: 'im Uhrzeigersinn',
				en: 'clockwise',
				fr: 'dans le sens des aiguilles d\'une montre',
				ja: 'æ™‚è¨ˆå›ã‚Š'
			},
			counterclockwise: {
				de: 'gegen den Uhrzeigersinn',
				en: 'counterclockwise',
				fr: 'dans le sens inverse des aiguilles d\'une montre',
				ja: 'åæ™‚è¨ˆå›ã‚Š'
			}
		}
	},
	raw: {
		unknownsize: {
			de: 'Unerkannte RAW-DateigrÃ¶ÃŸe, Entwickler kontaktieren',
			en: 'Unrecognized RAW file size, contact developer',
			fr: 'La taille du fiche RAW ne correspond pas au format connu. Veuillez contacter le dÃ©veloppeur',
			ja: 'åæ™‚è¨ˆå›ã‚Š'
		},
	},
	selection: {
		got: {
			de: '$$0 Dateien wurden ausgewÃ¤hlt.',
			en: 'Got $$0 files selected.',
			fr: '$$0 dossiers ont Ã©tÃ© sÃ©lectionnÃ©s.',
			ja: '$$0 ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚'
		},
	},
	del: {
		question: {
			en: 'Deleting $$0 file(s) can not be undone! Are you sure you want to continue?',
			de: 'LÃ¶schen von $$0 Datei(en) kann nicht rÃ¼ckgÃ¤ngig gemacht werden. Sicher damit weitermachen?',
			fr: 'La suppression de $$0 fiche(s) est irrÃ©versible. Es-tu sur de vouloir continuer?',
			ja: '$$0 ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã™ã‚‹ã¨ã€å…ƒã«æˆ»ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ ç¶šè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹?',
			ok: {
				de: 'Ok',
				en: 'Ok',
				fr: 'Ok',
				ja: 'ã¯ã„'
			},
			cancel: {
				de: 'Abbrechen',
				en: 'Cancel',
				fr: 'Annuler',
				ja: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«'
			}
		},
		nostatus: {
			de: 'Der Status des LÃ¶schens kann nicht sicher geprÃ¼ft werden. Bitte laden Sie die Seite nach dem LÃ¶schen neu.',
			en: 'The status of the delete can not be checked safely. Reload the page after deleting.',
			fr: 'Le statut de la suppression ne peut pas Ãªtre vÃ©rifiÃ© avec certitude. Veuillez recharger la page aprÃ¨s la suppression.',
			ja: 'å‰Šé™¤ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å®‰å…¨ã«ç¢ºèªã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ å‰Šé™¤å¾Œã¯ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚'
		},
		reload: {
			de: 'Bitte Seite neu laden.',
			en: 'Please reload page.',
			fr: 'Veuillez recharger la page.',
			ja: 'ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚'
		}
	},
	node: {
	    backw: {
			   help: {
					   en: [ 'Welcome to imbdng2raw $$0 (BACKWARD!) !', 'Usage: node $$0 [-l lang] [-d dir] [ [--] <files>* ]',
					   'Options:',
					   ' -h - show this help',
					   ' -l XX - where XX is a valid language code (currently: DE, EN, FR, JA)',
					   '         Language can also be set by changing filename to imbdng2raw_XX.js .',
					   ' -d dir - put output files into dir',
					   ' -----',
					   ' -- - treat rest of parameters as local files or dirs',
					   ' <files> - process local files' ],
					   de: [ 'Willkommen bei imbdng2raw $$0 (RÃœCKWÃ„RTS!) !', 'Aufruf: node $$0 [-l sprache] [-d ordner] [ [--] <dateien>* ]',
					   'Optionen:',
						' -h - diesen Hilfetext zeigen',
						' -l XX - wo XX ein gÃ¼ltiger Sprachcode ist (derzeit: DE, EN, FR, JA)',
						'         Die Sprache kann auch durch Umbenennen in imbdng2raw_XX.js geÃ¤ndert werden.',
						' -d ordner - Ausgabedateien in diesen Ordner ablegen',
						' -----',
						' -- - weitere Parameter als lokale Dateien oder Ordner betrachten',
						' <dateien> - lokale Dateien verarbeiten',],
			   }
	    },
		help: {
			en: [ `\u001b[1mWelcome to imbraw2dng\u001b[0m $$0 !', 'Usage: node $$0 \u001b[1m[\u001b[0m-l lang\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-f\u001b[1m | \u001b[0m-r\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-d dir\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-nc \u001b[1m|\u001b[0m -co\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-np\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-cr copyright\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-R\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-J\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-O\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-n yyyy_mm_dd-hh_mm_ss\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-fla \u001b[1m|\u001b[0m -flx\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m
\u001b[1m[\u001b[0m--\u001b[1m]\u001b[0m \u001b[1m<\u001b[0mfiles-or-dirs\u001b[1m>*\u001b[0m \u001b[1m]\u001b[0m`,
				'Options:',
				' \u001b[1m-h\u001b[0m - show this help',
				' \u001b[1m-nc\u001b[0m - do not use coloured text',
				' \u001b[1m-co\u001b[0m - force coloured text',
				' \u001b[1m-l XX\u001b[0m - where XX is a valid language code (currently: DE, EN, FR, JA)',
				'         Language can also be set by changing filename to imbraw2dng_XX.js .',
				' \u001b[1m-d dir\u001b[0m - put output files into dir',
				' \u001b[1m-f\u001b[0m - overwrite existing files',
				' \u001b[1m-r\u001b[0m - rename output file, if already exists',
				' \u001b[1m-np\u001b[0m - Do not add preview thumbnail to DNG',
				' \u001b[1m-cr \'copyright...\'\u001b[0m - add copyright to DNG',
				' \u001b[1m-fla\u001b[0m, \u001b[1m-flx\u001b[0m - add multiple images to fake long exposure, flx scales down',
				' \u001b[1m-R\u001b[0m - get RAW from ImB connected via Wifi or from given directories',
				' \u001b[1m-J\u001b[0m - get JPEG from ImB connected via Wifi or from given directories',
				' \u001b[1m-O\u001b[0m - get non-RAW/non-JPEG from ImB connected via Wifi or from given directories',
				' \u001b[1m-n yyyy_mm_dd-hh_mm_ss\u001b[0m (or prefix of any length) - select only newer than this timestamp from ImB or from given directories',
				' -----',
				' \u001b[1m--\u001b[0m - treat rest of parameters as local files or dirs',
				' <files-or-dirs> - process local files or directories recursively, e.g. on MicroSD from ImB',],
			fr: [ `\u001b[1mBienvenu a imbraw2dng\u001b[0m $$0 !', 'Operation: node $$0 \u001b[1m[\u001b[0m-l lang\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-f\u001b[1m | \u001b[0m-r\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-d repertoire\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-nc \u001b[1m|\u001b[0m -co\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-np\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-cr copyright\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-R\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-J\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-O\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-n yyyy_mm_dd-hh_mm_ss\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-fla \u001b[1m|\u001b[0m -flx\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m
\u001b[1m[\u001b[0m \u001b[1m[\u001b[0m--\u001b[1m]\u001b[0m \u001b[1m<\u001b[0mfiches-ou-repertoires\u001b[1m>*\u001b[0m \u001b[1m]\u001b[0m`,
				'Choix:',
				' \u001b[1m-h\u001b[0m - montrer cette aide',
				' \u001b[1m-nc\u001b[0m - n\'utilisez pas de texte en couleur',
				' \u001b[1m-co\u001b[0m - utilisez de texte en couleur',
				' \u001b[1m-l XX\u001b[0m - quand XX est une code du langue valide (actuellement: DE, EN, FR, JA)',
				'         La langue peut Ã©galement Ãªtre dÃ©finie en changeant le nom du fiche en imbraw2dng_XX.js .',
				' \u001b[1m-d repertoire\u001b[0m - mettre les fiches de sortie dans le rÃ©pertoire',
				' \u001b[1m-f\u001b[0m - Ã©craser les fiches existants',
				' \u001b[1m-r\u001b[0m - quand fiche existe, renommer le rÃ©sultat',
				' \u001b[1m-np\u001b[0m - Pas petite image d\'aperÃ§u en DNG',
				' \u001b[1m-cr \'copyright...\'\u001b[0m - add copyright to DNG',
				' \u001b[1m-fla\u001b[0m, \u001b[1m-flx\u001b[0m - add multiple images to fake long exposure, flx scales down',
				' \u001b[1m-R\u001b[0m - obtenez RAW d\'ImB connectÃ© via Wifi ou repertoires donnÃ©s',
				' \u001b[1m-J\u001b[0m - obtenez JPEG d\'ImB connectÃ© via Wifi ou repertoires donnÃ©s',
				' \u001b[1m-O\u001b[0m - obtenez du non-RAW/non-JPEG d\'ImB connectÃ© via Wifi ou repertoires donnÃ©s',
				' \u001b[1m-n yyyy_mm_dd-hh_mm_ss\u001b[0m (ou prÃ©fixe de n\'importe quelle longueur) - sÃ©lectionnez uniquement plus rÃ©cent que cet horodatage d\'ImB ou repertoires donnÃ©s',
				' -----',
				' \u001b[1m--\u001b[0m - traiter le reste des paramÃ¨tres comme des fiches ou des rÃ©pertoires locaux',
			' <fiches-ou-repertoires> - traiter des fiches ou des rÃ©pertoires locaux de maniÃ¨re rÃ©cursive, par exemple sur MicroSD d\'ImB',],
			de: [ `\u001b[1mWillkommen bei imbraw2dng\u001b[0m $$0 !', 'Aufruf: node $$0 \u001b[1m[\u001b[0m-l sprache\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-f\u001b[1m | \u001b[0m-r\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-d ordner\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-nc \u001b[1m|\u001b[0m -co\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-np\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-cr copyright\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-R\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-J\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-O\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-n yyyy_mm_dd-hh_mm_ss\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-fla \u001b[1m|\u001b[0m -flx\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m
\u001b[1m[\u001b[0m \u001b[1m[\u001b[0m--\u001b[1m]\u001b[0m \u001b[1m<\u001b[0mdateien-oder-ordner\u001b[1m>*\u001b[0m \u001b[1m]\u001b[0m`,
				'Optionen:',
				' \u001b[1m-h\u001b[0m - diesen Hilfetext zeigen',
				' \u001b[1m-nc\u001b[0m - keinen farbigen Text zeigen',
				' \u001b[1m-co\u001b[0m - farbigen Text zeigen',
				' \u001b[1m-l XX\u001b[0m - wo XX ein gÃ¼ltiger Sprachcode ist (derzeit: DE, EN, FR, JA)',
				'         Die Sprache kann auch durch Umbenennen in imbraw2dng_XX.js geÃ¤ndert werden.',
				' \u001b[1m-d ordner\u001b[0m - Ausgabedateien in diesen Ordner ablegen',
				' \u001b[1m-f\u001b[0m - existierende Dateien Ã¼berschreiben',
				' \u001b[1m-r\u001b[0m - Ausgabedatei umbenennen, falls schon existiert',
				' \u001b[1m-np\u001b[0m - Kein kleines Vorschaubild im DNG',
				' \u001b[1m-cr \'copyright...\'\u001b[0m - copyright dem DNG hinzufÃ¼gen',
				' \u001b[1m-fla\u001b[0m, \u001b[1m-flx\u001b[0m - mehrere Bilder als Langzeitbelichtung aufaddieren, flx skaliert dabei herunter',
				' \u001b[1m-R\u001b[0m - RAW von per WLAN verbundener ImB oder Ã¼bergebenen Verzeichnissen konvertieren',
				' \u001b[1m-J\u001b[0m - JPEG von per WLAN verbundener ImB oder Ã¼bergebenen Verzeichnissen kopieren',
				' \u001b[1m-O\u001b[0m - Nicht-JPEG/Nicht-RAW von per WLAN verbundener ImB oder Ã¼bergebenen Verzeichnissen kopieren',
				' \u001b[1m-n yyyy_mm_dd-hh_mm_ss\u001b[0m (oder beliebig langer Anfang davon) - nur Dateien neuer als dieser Zeitstempel von ImB oder Ã¼bergebenen Verzeichnissen holen',
				' -----',
				' \u001b[1m--\u001b[0m - weitere Parameter als lokale Dateien oder Ordner betrachten',
				' <dateien-oder-ordner> - lokale Dateien oder Ordner rekursiv (z.B. von der MicroSD Karte aus ImB) verarbeiten',],
			ja: [
				`\u001b[1mimbraw2dng ã¸ã‚ˆã†ã“ã\u001b[0m $$0 !', 'Usage: node $$0 \u001b[1m[\u001b[0m-l lang\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-f\u001b[1m | \u001b[0m-r\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-d dir\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-nc \u001b[1m|\u001b[0m -co\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-np\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-cr copyright\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-R\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-J\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-O\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m-n yyyy_mm_dd-hh_mm_ss\u001b[1m]\u001b[0m
\u001b[1m[\u001b[0m-fla \u001b[1m|\u001b[0m -flx\u001b[1m]\u001b[0m \u001b[1m[\u001b[0m
\u001b[1m[\u001b[0m \u001b[1m[\u001b[0m--\u001b[1m]\u001b[0m \u001b[1m<\u001b[0mfiles-or-dirs\u001b[1m>*\u001b[0m \u001b[1m]\u001b[0m`,
				'ã‚ªãƒ—ã‚·ãƒ§ãƒ³:',
				' \u001b[1m-h\u001b[0m - ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã™ã‚‹',
				' \u001b[1m-nc\u001b[0m - è‰²ä»˜ãã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ç”¨ã—ãªã„',
				' \u001b[1m-co\u001b[0m - è‰²ä»˜ãã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å¼·åˆ¶',
				' \u001b[1m-l XX\u001b[0m - ã“ã“ã§ã€XX ã¯æœ‰åŠ¹ãªè¨€èªã‚³ãƒ¼ãƒ‰ã§ã™ (ç¾åœ¨: DEã€ENã€FRã€JA)',
				'         ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ imbraw2dng_XX.js ã«å¤‰æ›´ã™ã‚‹ã“ã¨ã§è¨€èªã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚',
				' \u001b[1m-d dir\u001b[0m - å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ dir ã«ç½®ã',
				' \u001b[1m-f\u001b[0m - ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãã™ã‚‹',
				' \u001b[1m-r\u001b[0m - rename output file, if already exists',
				' \u001b[1m-np\u001b[0m - Do not add preview thumbnail to DNG',
				' \u001b[1m-cr \'copyright...\'\u001b[0m - add copyright to DNG',
				' \u001b[1m-fla\u001b[0m, \u001b[1m-flx\u001b[0m - add multiple images to fake long exposure, flx scales down',
				' \u001b[1m-R\u001b[0m - WifiçµŒç”±ã§æ¥ç¶šã•ã‚ŒãŸImBã¾ãŸã¯æŒ‡å®šã•ã‚ŒãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰RAWã‚’å–å¾—ã™ã‚‹',
				' \u001b[1m-J\u001b[0m - WifiçµŒç”±ã§æ¥ç¶šã•ã‚ŒãŸImBã¾ãŸã¯æŒ‡å®šã•ã‚ŒãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰JPEGã‚’å–å¾—ã™ã‚‹',
				' \u001b[1m-O\u001b[0m - WifiçµŒç”±ã§æ¥ç¶šã•ã‚ŒãŸImBã¾ãŸã¯æŒ‡å®šã•ã‚ŒãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰éRAW/éJPEGã‚’å–å¾—ã™ã‚‹',
				' \u001b[1m-n yyyy_mmdd_hhmmss\u001b[0m (ã¾ãŸã¯ä»»æ„ã®é•·ã•ã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹) - ImB ã‹ã‚‰ã“ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚ˆã‚Šæ–°ã—ã„ã‚‚ã®ã®ã¿ã‚’é¸æŠã™ã‚‹',
				' -----',
				' \u001b[1m--\u001b[0m - æ®‹ã‚Šã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ã‚«ãƒ« ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ã—ã¦æ‰±ã†',
				'<files-or-dirs> ã¨ -R/-J/-O/-n ã¯åŒæ™‚ã«ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚'
				]
		},
		unkopt: {
			en: '\u001b[31mUnknown Option:\u001b[0m $$0',
			de: '\u001b[31mUnbekannte Option:\u001b[0m $$0',
			fr: '\u001b[31mOption inconnue:\u001b[0m $$0',
			ja: '\u001b[31mæœ€å¾Œã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å€¤ãŒæ¬ è½ã—ã¦ã„ã¾ã™ã€‚\u001b[0m'
		},
		missingval: {
			en: '\u001b[31mMissing value for last parameter.\u001b[0m',
			de: '\u001b[31mFehlender Wert fÃ¼r letzten Parameter.\u001b[0m',
			fr: '\u001b[31mValeur manquante pour le dernier paramÃ¨tre.\u001b[0m',
			ja: '\u001b[31mæœ€å¾Œã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å€¤ãŒæ¬ è½ã—ã¦ã„ã¾ã™ã€‚\u001b[0m'
		},
		fnwarn: {
			en: '\u001b[31mWarning:\u001b[0m $$0 looks like a timestamp, did you forget \u001b[1m-n\u001b[0m or \u001b[1m--\u001b[0m in front of it?',
			de: '\u001b[31mWarnung:\u001b[0m $$0 sieht wie ein Zeitstempel aus, vielleicht \u001b[1m-n\u001b[0m oder \u001b[1m--\u001b[0m davor vergessen?',
			fr: '\u001b[31mAvertissement:\u001b[0m $$0 ressemble Ã  un horodatage, oubliÃ©e \u001b[1m-n\u001b[0m ou \u001b[1m--\u001b[0m?',
			ja: '\u001b[31mè­¦å‘Š:\u001b[0m $$0 lã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®ã‚ˆã†ã§ã™ãŒã€ \u001b[1m-n\u001b[0m ã¾ãŸã¯ \u001b[1m--\u001b[0m æ‰‹å‰ã«ã‚ã‚‹ã®ã‚’å¿˜ã‚Œã¾ã—ãŸã‹?'
		},
		renamed: {
			en: '(renamed)',
			de: '(umbenannt)',
			fr: '(renomee)'
		},
		readconfig: {
			en: '\u001b[2mConfig file $$0 read.\u001b[0m',
			de: '\u001b[2mKonfigurationsdatei $$0 eingelesen.\u001b[0m',
		},
		noconfig: {
			de: '\u001b[2mKeine json Konfigurationsdatei gefunden, gesucht: $$0\u001b[0m',
			en: '\u001b[2mNo json config file found, searched: $$0\u001b[0m'
		}
	}
};

// ImBCBase: generic data
mylang = 'en';
withpreview = true;
copyright = '';
// { name: 'xxx.jpg', data: array-ifd... }
#exififds = [];

// ImBCBase: fake long exposure:
#addimgs = [];
addall = false;
addscaleall = false;
#historystring = '';

/* ImBCBase: For processing several files */
totnum=0;
actnum=0;
stats = { total: 0, skipped: 0, ok: 0, error: 0 };
allfiles = [];

// ImBCBase: from the back itself
imbpics = [];  // found jpegs
rimbpics = []; // found raws
imbmovies = []; // found other
earliestmov = '9999';  // upper/lower bounds of dates for types
latestmov='0000';
earliestjpg='9999';
latestjpg='0000';
earliestraw='9999';
latestraw='0000';

// generic user input timestamp (any prefix)
//                  y      y     y     y      .      m     m     .      d      d      .      h     h      .      m     m      .      s     s
static tsregex = /^[02-3]([0-9]([0-9]([0-9](([^0-9])[01]([0-9](([^0-9])[0123]([0-9](([^0-9])[012]([0-9](([^0-9])[0-5]([0-9](([^0-9])[0-5]([0-9])?)?)?)?)?)?)?)?)?)?)?)?)?$/ // actually const
/* ImBCBase: Data for the Imback variants and exif stuff */
// generic imb filename format
//                   y    y    y    y     .         m    m     .        d     d      .        h    h      .        m    m      .        s    s     EXT
static fnregex = /^([2-3][0-9][0-9][0-9])([^0-9]?)([01][0-9])([^0-9]?)([0123][0-9])([^0-9]?)([012][0-9])([^0-9]?)([0-6][0-9])([^0-9]?)([0-6][0-9])(.*[.])([^.]*)$/ // actually const
// generic imb filename format, only timestamp
//                    y    y    y    y     .         m    m     .        d     d      .        h    h      .        m    m      .        s    s      .        n
static fnregexx = /^([2-3][0-9][0-9][0-9])([^0-9]?)([01][0-9])([^0-9]?)([0123][0-9])([^0-9]?)([012][0-9])([^0-9]?)([0-6][0-9])([^0-9]?)([0-6][0-9])([^0-9]?)([0-9]*)/ // actually const
static orients = [ '', 'none', '', 'upsidedown', '', '', 'clockwise', '', 'counterclockwise' ]; // actually const
static oriecw = [ 1, 6, 3, 8 ]; // clockwise indices // actually const
static types = [ "unknown", "ImB35mm", "MF 6x7 ", "MF6x4.5", "MF 6x6 " ]; // all length 7, actually const
static infos = [ // actually const
	{
		size: 14065920,
		w: 4320,
		h: 3256,
		typ: 0,
		mode: "historic"
	},
	{ /* MF 6x7 */
		size: 15925248,
		w: 4608,
		h: 3456,
		typ: 2,
		mode: ""
	},
	{ /* MF 6x4.5 */
		size: 12937632,
		w: 4152, h: 3116,
		typ: 3,
		mode: ""
	},
	{
		size: 9806592,
		w: 3616, h: 2712,
		typ: 3,
		mode: "Medium-angle"
	},
	{
		size: 6470944,
		w: 2936, h: 2204,
		typ: 3,
		mode: "Small-angle"
	},
	{ /* MF 6x6 */
		size: 11943936,
		w: 3456, h: 3456,
		typ: 4,
		mode: ""
	},
	{ /* 35mm */
		size: 15335424,
		w: 4608, h: 3328,
		typ: 1,
		mode: ""
	},
	{
		size: 11618752,
		w: 4012, h: 2896,
		typ: 1,
		mode: "Medium-angle"
	},
	{
		size: 7667520,
		w: 3260, h: 2352,
		typ: 1,
		mode: "Small-angle"
	}
	/* Film ? */
];

/* ImBCBase: debug */
debugflag = false;
useraw = null;

constructor() {
}
/* ImBCBase: primitive basename helper */
static basename(n) {
	while (n.lastIndexOf("/") > -1) {
		n = n.substring(n.lastIndexOf("/") + 1);
	}
	return n;
}
/* ImBCBase: compare timestamp */
comptime(fname, compts) {
	const res = ImBCBase.fnregex.exec(fname);
	if (res === null) {
		this.appmsgxl(false, 'words.warning');
		this.appmsgxl(0, 'onimback.strangename', fname);
		return (compts === '0000');
	} else {
		const ts = res[1] + '_' + res[3] + '_' + res[5] + '-' + res[7] + '_' + res[9] + '_' + res[11];
		if (ts.substring(0, ts.length) >= compts)
			return true;
	}
	return false;
}
/* ImBCBase: translated append to main log */
mappx(nlflag, key, arg0, arg1, arg2, arg3) {
	this.appmsgxl((nlflag === 0) ? undefined : nlflag, key, arg0, arg1, arg2, arg3);
}
/* ImBCBase: remove VT100 color escapes for html or windows */
rmesc(str) {
	if (!document && this.withcolours) return (str);
	let i = 0, j, k;
	while ((j = str.substring(i).indexOf('\u001b')) !== -1) {
		k = str.substring(i+j).indexOf('m');
		if (j !== -1 && k !== -1) {
			str = str.substring(0, i+j) + str.substring(i+j+k+1);
			i += j;
		} else i++;
	}
	return str;
}
/* ImBCBase: get part of translation */
xl0(str, base) {
	if (undefined === base) base = ImBCBase.texts;
	const i = str.indexOf('.');
	if (i === -1) {
		let r = base[str][this.mylang];
		if (undefined === r) r = base[str]['en'];
		if (typeof r === 'string')
			return this.rmesc(r);
		else {
			let res = [];
			for (const e of r)
				res.push(this.rmesc(e));
			return res;
		}
	}
	else {
		const e = base[str.substring(0,i)];
		return this.xl0(str.substring(i+1),e);
	}
}
/* ImBCBase: substitute in translation */
subst(r, arg0, arg1, arg2, arg3) {
	if (r.indexOf('$$0') !== -1 && arg0 !== undefined) {
		r = r.substring(0, r.indexOf('$$0')) + arg0 + r.substring(r.indexOf('$$0') + 3);
		if (r.indexOf('$$1') !== -1 && arg1 !== undefined) {
			r = r.substring(0, r.indexOf('$$1')) + arg1 + r.substring(r.indexOf('$$1') + 3);
			if (r.indexOf('$$2') !== -1 && arg2 !== undefined) {
				r = r.substring(0, r.indexOf('$$2')) + arg2 + r.substring(r.indexOf('$$2') + 3);
				if (r.indexOf('$$3') !== -1 && arg3 !== undefined) {
					r = r.substring(0, r.indexOf('$$3')) + arg3 + r.substring(r.indexOf('$$3') + 3);
				}
			}
		}
	}
	return this.rmesc(r);
}
/* ImBCBase: translate one string with parameters */
xl(str, arg0, arg1, arg2, arg3, base) {
	// console.log(' XL ' + str + ' - ' + base + ' - ' + arg0 + ' - ' + arg1);
	if (undefined === base) base = ImBCBase.texts;
	if (this.mylang === '00') {
		let res = '[' + str;
		if (undefined !== arg0) {
			res += ',' + arg0;
			if (undefined !== arg1) {
				res += ',' + arg1;
				if (undefined !== arg2) {
					res += ',' + arg2;
					if (undefined !== arg3) {
						res += ',' + arg3;
					}
				}
			}
		}
		return (res + ']');
	}
	const i = str.indexOf('.');
	if (i === -1) {
		let r = base[str][this.mylang];
		if (undefined === r) r = base[str]['en'];
		return this.rmesc(this.subst(r, arg0, arg1, arg2, arg3));
	}
	else {
		const e = base[str.substring(0,i)];
		return this.xl(str.substring(i+1), arg0, arg1, arg2, arg3, e);
	}
}
/* ImBCBase: find language from filename or nodejs scriptfile */
querylang(name, offset) {
	if (undefined === offset) offset = 8;
	let found = 0;
	for (const l of ImBCBase.alllangs) {
		if (name.substring(name.length - offset, name.length - offset + 4).toUpperCase() === ('_' + l.toUpperCase() + '.')) {
			this.mylang = l;
			if ('00' === l) {
				this.debugflag = true;
				if (document) { // translation output into browser log
					for (const el of Object.keys(ImBCBase.texts))
						this.prxl(el, ImBCBase.texts[el]);
					document.getElementById('langsel').innerHTML += '<option value="00" onclick="imbc.setlang()">00</option></select>';
				}
			}
			if (document) {
				document.getElementById('langsel').value = l;
			}
			found = 1;
			break;
		}
	}
	if (!found) {
		if (name.substring(name.length - offset, name.length - offset+1) === '_') console.log('Unknown language: ' + name.substring(name.length - offset+1).substring(0,2));
	}
	// followed by xlall anyway
}
/* ImBCBase: debug: print translations for csv */
prxl(key, el) {
	if (el['de'] && el['en']) {
		try{
		if (typeof el['de'] === 'string') {
			let out = key + ';';
			for (const l of ImBCBase.alllangs) {
				if (undefined !== el[l]) {
					let a = el[l];
					let b = '"';
					if (-1 !== a.indexOf('"')) b = '\'';
					out += b + a  + b + ';';
				} else out += ';'
			}
			console.log(out);
		}
		else if (typeof el['de'][0] === 'string') {
			for (let i=0; i< el['de'].length; i++) {
				let out = key + '[' + i + '];';
				for (const l of ImBCBase.alllangs) {
					if (undefined !== el[l] && undefined !== el[l][i]) {
						let a = el[l][i];
						let b = '"';
						if (-1 !== a.indexOf('"')) b = '\'';
						out += b + a  + b + ';';
					} else out += ';';
				}
				console.log(out);
			}
		}
		} catch (e) {
			console.log(JSON.stringify(e));
			if (!document) require('process').exit();
		}
	}
	for (const ne of Object.keys(el).filter((k) => ((k !== 'en') && (k !== 'de') && (typeof(el[k]) !== 'string')))) {
		this.prxl(key + '.' + ne, el[ne]);
	}
}
/* ImBCBase: language helper */
findlang(i) {
	let found = 0;
	for (const l of ImBCBase.alllangs) {
		if (i.toUpperCase() === l.toUpperCase()) {
			this.mylang = l;
			found = 1;
			break;
		}
	}
	if (!found) {
		this.mylang = 'en';
		console.log('Unknown language(2): ' + i);
	}
	else if ('00' === this.mylang)
		this.debugflag = true;
	return this.mylang;
}
/* ImBCBase: extract exif from jpeg */
xexif(name, view) {
	if (view.getUint8(0) !== 0xff) return; /* JFIF */
	if (view.getUint8(1) !== 0xd8) return;
	if (view.getUint8(2) !== 0xff) return; /* APP1 */
	if (view.getUint8(3) !== 0xe1) return;
	if (view.getUint8(6) !== 0x45) return; /* E */
	if (view.getUint8(7) !== 0x78) return; /* x */
	if (view.getUint8(8) !== 0x69) return; /* i */
	if (view.getUint8(9) !== 0x66) return; /* f */
	if (view.getUint8(12) !== 0x49) return; /* I */
	if (view.getUint8(13) !== 0x49) return; /* I */
	if (view.getUint8(14) !== 0x2a) return; /* magic */
	if (view.getUint8(15) !== 0x00) return; /* magic */
	let baseoff = 12, off = 12+4+4+2, exifoff = -1;
	let nent = TIFFOut.readshort(view, 12+4+4);
	for (let j=0; j<nent; j++) {
		let tag = TIFFOut.readshort(view, off);
		if (tag === 34665) {
			exifoff = TIFFOut.readint(view, off+8);
			break;
		}
		off += 12;
	}
	if (exifoff === -1) return;
	// but how long is it?
	let maxdat = 0;
	off = exifoff + baseoff;
	nent = TIFFOut.readshort(view, off);
	off += 2;
	for (let j=0; j<nent; j++) {
		// seek end of data for tags
		let typ = TIFFOut.readshort(view, off+2);
		let num = TIFFOut.readint(view, off+4);
		let addr = TIFFOut.readint(view, off+8);
		off += 12;
		let ee = TIFFOut.types.find(e => e.t === typ);
		if (undefined === ee) {
			console.log('EXIF: TYP NOT FOUND ' + typ);
			continue;
		}
		if (ee.l * num <= 4)
			continue;
		if (addr < exifoff) {
			console.log('EXIF OFFSET BEFORE IFD');
			continue;
		}
		if (addr + ee.l * num > maxdat) maxdat = addr + ee.l * num;
		// we correct the addresses so that 0 is start of exif ifd
		addr = addr - exifoff;
		view.setUint8(off-4, addr % 256);
		addr = Math.floor(addr / 256);
		view.setUint8(off-3, addr % 256);
		addr = Math.floor(addr / 256);
		view.setUint8(off-2, addr % 256);
		addr = Math.floor(addr / 256);
		view.setUint8(off-1, addr % 256);
		addr = Math.floor(addr / 256);
	}
	if (maxdat === 0) maxdat = off;
	if (maxdat - off > 10000) return;
	let na = [];
	for (let z = baseoff+exifoff; z<maxdat; z++)
		na.push(view.getUint8(z));
	this.#exififds.push( { name: name, data: na } );
}
/* ImBCBase: time values from filename */
static nametotime(name) {
	let res = ImBCBase.fnregexx.exec(name);
	if (res !== null) {
		const yr = Number.parseInt(res[1]);
		const mon = Number.parseInt(res[3]);
		const day = Number.parseInt(res[5]);
		const hr = Number.parseInt(res[7]);
		const min = Number.parseInt(res[9]);
		const sec = Number.parseInt(res[11]);
		const nn = Number.parseInt(res[13]);
		const dd = new Date(yr, mon -1, day, hr, min, sec);
		const datestr = "" + yr + ":" + ((mon < 10) ? "0":"") + mon + ":" + ((day < 10) ? "0":"") + day + " "+
			((hr < 10) ? "0":"") + hr + ":" + ((min < 10) ? "0":"") + min + ":" + ((sec < 10) ? "0":"") + sec;
		return { date: dd, datestr: datestr, nn: nn, yr: yr, mon: mon, day: day, hr: hr, min: min, sec: sec }
	}
	else return {};
}
/* ImBCBase: actual processing function for one file */
handleone(orientation, fromloop) {
	const f = (this.debugflag && this.useraw) ? this.useraw : this.allfiles[this.actnum];
	if (undefined === f) {
		this.mappx(true, 'process.nothing');
		return this.handlenext(fromloop);
	}
	if (undefined === f.size) {
		setTimeout(() => {
		  this.resolver(f, (url, fx, rot) => {
				this.allfiles[this.actnum] = fx;
				this.handleone(rot ? rot: orientation, fromloop);
			}, (url) => {
				this.mappx(false, 'words.sorryerr');
				this.mappx(true, 'process.erraccess', url);
				this.stats.error ++;
				this.handlenext(fromloop);
		  });
		});
		return;
	}
	let rawname = ImBCBase.basename(f.name);
	if (rawname.substring(rawname.length - 4).toUpperCase() !== '.RAW') {
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = (evt) => {
			if (this.totnum > 1) {
				this.appmsg("[" + (1 + this.actnum) + " / " + this.totnum + "] ", false);
			}
			this.mappx(0, 'process.notraw',rawname);
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<contents.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			if (rawname.substring(rawname.length - 4).toUpperCase() === '.JPG') this.xexif(rawname, view);
			this.writewrap(rawname, 'application/octet-stream', 'process.copyok' + (this.checkdlfolder ? 'checkdl' : ''), out, fromloop);
		}
		reader.onerror = (evt) => {
			console.log('Non-RAW process reader error for ' + f.name + ' ' + JSON.stringify(evt));
			this.mappx(false, 'words.sorryerr');
			this.mappx(true, 'process.errorreadingfile', f.name);
			this.stats.error++;
			this.handlenext(fromloop);
		}
		reader.readAsArrayBuffer(f);
		return;
	}
	let w, h, mode = "??";
	let typ = 0;
	const zz = ImBCBase.infos.findIndex(v => v.size === f.size);
	if (zz === -1) {
		if (this.totnum > 1) {
			this.appmsg("[" + (1 + this.actnum) + " / " + this.totnum + "] ", false);
		}
		this.appmsg('[' + f.name + '] ', false);
		this.mappx(false, 'words.sorry');
		this.mappx(0, 'process.unknownsize', f.size);
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = (evt) => {
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<view.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			this.writewrap(rawname, 'application/octet-stream', 'process.copyok' + (this.checkdlfolder ? 'checkdl' : ''), out, fromloop);
		}
		reader.onerror = (evt) => {
			console.log('Unk-RAW process reader error for ' + f.name + ' ' + JSON.stringify(evt));
			this.mappx(false, 'words.sorryerr');
			this.mappx(true, 'process.errorreadingfile', f.name);
			this.stats.error++;
			this.handlenext(fromloop);
		}
		reader.readAsArrayBuffer(f);
		return;
	} else {
		w = ImBCBase.infos[zz].w;
		h = ImBCBase.infos[zz].h;
		mode = ImBCBase.infos[zz].mode;
		if (mode.length !== 0) mode += ' ';
		mode += '(' + w + ' x ' + h + ')';
		typ = ImBCBase.infos[zz].typ;
	}
	const rawnamearr = new TextEncoder().encode(rawname);
	let dateok = false;
	/*// date?
	if (undefined !== f.datestr) {
		datestr = f.datestr;
		dateok = true;
	}*/
	let { date, datestr, nn } = ImBCBase.nametotime(rawname);
	if (date && datestr) dateok = true;
	else datestr = '';

	const reader = f.imbackextension ? f : new FileReader();
	reader.onload = (evt) => {
		if (this.totnum > 1) {
			this.appmsg("[" + (1 + this.actnum) + " / " + this.totnum + "] ", false);
		}
		const contents = evt.target.result;
		const view = new DataView(contents);
		if (this.addall) {
			if (this.#addimgs.length === 0 && this.addscaleall)
				this.#historystring='(';
			else if (this.#addimgs.length === 0)
				this.#historystring='';
			this.#addimgs.push(view);
			this.mappx(0, 'main.fakelong.added', rawname);
			if (this.#historystring.length < 2)
				this.#historystring += rawname;
			else
				this.#historystring += ('+' + rawname);
			if (this.actnum === this.totnum - 1) {
				this.appmsg('', true);
				let npic = this.#addimgs.length;
				for (let j=0; j < w*h; j++) {
					let res = 0;
					for (const k of this.#addimgs) {
						try {
							res += k.getUint8(j);
						} catch { ; }
					}
					if (this.addscaleall) {
						res = Math.floor(res / npic);
					}
					if (res > 255) {
						view.setUint8(j, 255);
					}
					else view.setUint8(j, res);
				}
				if (this.addscaleall) {
					this.#historystring += (')/' + npic);
				}
				this.#addimgs = [];
			}
			else {
				return this.handlenext(fromloop);
			}
		}
		this.mappx(0, 'process.processing', rawname);
		this.mappx(0, 'process.assuming', ImBCBase.types[typ], mode);
		if (dateok) {
			this.mappx(0, 'process.datetime', datestr);
		}
		let ori = orientation ? orientation : 1;
		let transp = false;
		if (ori !== 1) {
			this.mappx(0, 'process.orientation', this.xl0('preview.orients.' + ImBCBase.orients[ori]));
			if (ori === 6 || ori === 8) transp = true;
		}
		/* Here comes the actual building of the DNG */
		let ti = new TIFFOut();
		ti.addIfd(); /* **************************************** */
		if (this.withpreview) {
			this.mappx(0, 'process.addpreview');
			/* **** PREVIEW image **** */
			let scale = 32;
			if (w < 4096 && h < 4096) scale=16;
			ti.addImageStrip(1, ImBCBase.buildpvarray(view, typ, w, h, ori, scale), Math.floor(transp ? (h+scale-1)/scale:(w+scale-1)/scale), Math.floor(transp ? (w+scale-1)/scale: (h+scale-1)/scale));
			ti.addEntry(258 , 'SHORT', [ 8, 8, 8 ]); /* BitsPerSample */
			ti.addEntry(259 , 'SHORT', [ 1 ]); /* Compression - none */
			ti.addEntry(262, 'SHORT', [ 2 ]); /* Photometric - RGB */
			ti.addEntry(277, 'SHORT', [ 3 ]); /* Samples per Pixel */
			ti.addEntry(284, 'SHORT', [ 1 ]); /* Planar config - chunky */
			ti.addEntry(282, 'RATIONAL', [ 30, 1 ]); /* X resolution */
			ti.addEntry(283, 'RATIONAL', [ 30, 1 ]); /* y resolution */
		}
		ti.addEntry(271, 'ASCII', 'ImBack'); /* Make */
		ti.addEntry(50708, 'ASCII', 'ImBack' + ' ' + ImBCBase.types[typ]); /* Unique model */
		ti.addEntry(272, 'ASCII', ImBCBase.types[typ]); /* Model */
		ti.addEntry(274, 'SHORT', [ ori ]); /* Orientation */
		ti.addEntry(305, 'ASCII', 'imbraw2dng ' + ImBCBase.version); /* SW and version */
		if (this.#historystring.length)
			ti.addEntry(37395, 'ASCII', this.#historystring); /* image history */
		this.#historystring = '';
		if (dateok) {
			ti.addEntry(306, 'ASCII', datestr); /* datetime */
			ti.addEntry(36867, 'ASCII', datestr); /* Original date time */
			// do we have exifdata ?
			let odate = date, onn = nn, cand=[];
			for (const e of this.#exififds) {
				let { date, nn } = ImBCBase.nametotime(e.name);
				if (date) {
					//console.log('DGT ' + date.getTime() + ' OGT ' + odate.getTime() + ' nn ' + nn + ' onn ' + onn);
					if (Math.abs(date.getTime() - odate.getTime()) < 5000 && Math.abs(nn -onn) < 2) {
						cand.push( { e: e, td: date.getTime() - odate.getTime() });
					}
				}
			}
			if (cand.length) {
				let e =  cand.sort((a, b) => a.td - b.td)[0].e;
				this.mappx(0, 'process.addexif', e.name);
				ti.addExifIfd(e.data);
			}
		}
		ti.addEntry(50706, 'BYTE', [ 1, 2, 0, 0 ]); /* DNG Version */
		if (this.copyright != '') {
			// do UTF-8 bytes instead of ASCII if necessary
			let bytes = new TextEncoder().encode(this.copyright);
			//console.log('cr str ' + this.copyright.length + ' bytes ' + bytes.length);
			if (bytes.length === this.copyright.length)
				ti.addEntry(33432, 'ASCII', this.copyright); /* copyright */
			else
				ti.addEntry(33432, 'BYTE', bytes); /* copyright */
		}
		ti.addEntry(50707, 'BYTE', [ 1, 2, 0, 0 ]); /* DNG Backward Version */
		ti.addEntry(50827, 'BYTE', rawnamearr); /* Raw file name */
		ti.addEntry(50717, 'LONG', [ 255 ]); /* White level */
		/* **** TODOs: **** */
		ti.addEntry(50721, 'SRATIONAL', [ 19624, 10000, -6105, 10000, -34134, 100000, -97877, 100000, 191614, 100000, 3345, 100000, 28687, 1000000, -14068, 100000, 1348676, 1000000 ]); /* Color Matrix 1 */
		ti.addEntry(50964, 'SRATIONAL', [ 7161, 10000, 10093, 100000, 14719, 100000, 25819, 100000, 72494, 100000, 16875, 1000000, 0, 1000000, 5178, 100000, 77342, 100000 ]); /* Forward Matrix 1 */
		ti.addEntry(50778, 'SHORT', [ 23 ]); /* Calibration Illuminant 1 - D50 */
		ti.addEntry(50728, 'RATIONAL', [ 6, 10, 1, 1, 6, 10 ]); /* As shot neutral */
		ti.addEntry(50932, 'ASCII', 'Generic ImB conv profile Sig'); /* Profile calibration signature */
		ti.addEntry(50931, 'ASCII', 'Generic ImB conv profile Sig'); /* Camera calibration signature */
		//ti.addEntry(50936, 'ASCII', 'Generic ImB neutral'); /* Camera calibration name */
		if (this.withpreview) {
			ti.addEntry(50971, 'ASCII', new Date(Date.now()).toISOString() ); /* Preview date time */
			ti.addSubIfd(); /* **************************************** */
		}
		/* **** RAW image **** */
		ti.addImageStrip(0, view, w, h);
		ti.addEntry(258 , 'SHORT', [ 8 ]); /* BitsPerSample */
		ti.addEntry(259 , 'SHORT', [ 1 ]); /* Compression - none */
		ti.addEntry(262, 'SHORT', [ 0x8023 ]); /* Photometric - CFA */
		ti.addEntry(277, 'SHORT', [ 1 ]); /* Samples per Pixel */
		ti.addEntry(284, 'SHORT', [ 1 ]); /* Planar config - chunky */
		ti.addEntry(33421, 'SHORT', [ 2, 2 ]); /* CFA Repeat Pattern Dim */
		ti.addEntry(33422, 'BYTE', (typ > 1) ? [ 2, 1, 1, 0 ] : [ 1, 0, 2, 1 ]); /* CFA Pattern dep. on MF/35mm*/
		//ti.createCamProf('Generic ImB darker'); /* **************************************** */
		//ti.addEntry(50941, 'LONG', [ 3 ]); /* profile embed policy */
		//ti.addEntry(50932, 'ASCII', 'Generic ImB conv profile Sig'); /* Profile calibration signature */
		//ti.createCamProf('Generic ImB brighter');
		//ti.addEntry(50941, 'LONG', [ 3 ]); /* profile embed policy */
		//ti.addEntry(50932, 'ASCII', 'Generic ImB conv profile Sig'); /* Profile calibration signature */
		this.writewrap(rawname.substring(0, rawname.length - 3) + 'dng', 'image/x-adobe-dng', 'process.converted' + ((this.checkdlfolder && !this.zip) ? 'checkdl' : ''), ti.getData(), fromloop);
	};
	reader.onerror = (evt) => {
		console.log('Unk-RAW process reader error for ' + f.name + ' ' + JSON.stringify(evt));
		this.mappx(false, 'words.sorryerr');
		this.mappx(true, 'process.errorreadingfile', f.name);
		this.stats.error++;
		this.handlenext(fromloop);
	};
	reader.readAsArrayBuffer(f);
}
/* ImBCBase: wrapper for zip output */
writewrap(name, type, okmsg, arr1, fromloop) {
	if (this.zip) {
		this.zip.add(arr1, name, () => {
			this.mappx(true, okmsg, name);
			this.writepostok(name, fromloop);
		});
	} else
		this.writefile(name, type, okmsg, arr1, fromloop);
}
/* ImBCBase: get one downsampled median image value [ r g b ] */
static getPix(x, y, w, view, typ) {
	let outrgb = [];
	let reds = [];
	if (typ > 1) {
		reds.push(view.getUint8((y+1)*w + x + 1));
		reds.push(view.getUint8((y+1)*w + x + 3));
		reds.push(view.getUint8((y+1)*w + x + 2*w + 1));
		reds.push(view.getUint8((y+1)*w + x + 2*w + 3));
	} else {
		reds.push(view.getUint8(y*w + x + 1));
		reds.push(view.getUint8(y*w + x + 3));
		reds.push(view.getUint8(y*w + x + 2*w + 1));
		reds.push(view.getUint8(y*w + x + 2*w + 3));
	}
	reds.sort(function(a,b) { return a - b; });
	// median of red pixels
	outrgb.push((reds[1] + reds[2]) / 2.0);
	let greens = [];
	if (typ > 1) {
		greens.push(view.getUint8(y*w + x + 1));
		greens.push(view.getUint8(y*w + x + w));
		greens.push(view.getUint8(y*w + x + 3));
		greens.push(view.getUint8(y*w + x + 2 + w));
		greens.push(view.getUint8(y*w + x + 2*w + 1));
		greens.push(view.getUint8(y*w + x + 3*w));
		greens.push(view.getUint8(y*w + x + 2*w + 3));
		greens.push(view.getUint8(y*w + x + 3*w + 2));
	} else {
		greens.push(view.getUint8(y*w + x));
		greens.push(view.getUint8(y*w + x + w + 1));
		greens.push(view.getUint8(y*w + x + 2));
		greens.push(view.getUint8(y*w + x + 3 + w));
		greens.push(view.getUint8(y*w + x + 2*w));
		greens.push(view.getUint8(y*w + x + 3*w +1));
		greens.push(view.getUint8(y*w + x + 2*w + 2));
		greens.push(view.getUint8(y*w + x + 3*w + 3));
	}
	greens.sort(function(a,b) { return a - b; });
	outrgb.push((greens[3] + greens[4]) / 2.0);
	let blues = [];
	if (typ > 1) {
		blues.push(view.getUint8(y*w + x));
		blues.push(view.getUint8(y*w + x + 2));
		blues.push(view.getUint8(y*w + x + 2*w));
		blues.push(view.getUint8(y*w + x + 2*w + 2));
	} else {
		blues.push(view.getUint8((y+1)*w + x));
		blues.push(view.getUint8((y+1)*w + x + 2));
		blues.push(view.getUint8((y+1)*w + x + 2*w));
		blues.push(view.getUint8((y+1)*w + x + 2*w + 2));
	}
	blues.sort(function(a,b) { return a - b; });
	outrgb.push((blues[1] + blues[2]) / 2.0);
	return outrgb;
}
/* ImBCBase: build preview in array */
static buildpvarray(view, typ, w, h, orientation, scale) {
	const sfact = scale ? scale : 8;
	const w8 = Math.floor((w+(sfact -1))/sfact) - (scale ? 0 : 1);
	const h8 = Math.floor((h+(sfact -1))/sfact) - (scale ? 0 : 1);
	let minred=255, minblue = 255, mingreen = 255, maxred = 0, maxblue = 0, maxgreen = 0, allmin = 255, allmax = 0;
	let outpix = [];
	let rowiterstart, rowiterend;
	let coliterstart, coliterend;
	let transpose = false;
	if (orientation === 3) {
		rowiterstart = -1*(h8 -1);
		rowiterend = 1;
		coliterstart = -1*(w8 - 1);
		coliterend = 1;
	} else if (orientation === 6) {
		transpose = true;
		rowiterstart = 0;
		rowiterend = w8;
		coliterstart = -1*(h8 - 1);
		coliterend = 1;
	} else if (orientation === 8) {
		transpose = true;
		rowiterstart = -1*(w8 -1);
		rowiterend = 1;
		coliterstart = 0;
		coliterend = h8;
	} else {
		rowiterstart = 0;
		rowiterend = h8;
		coliterstart = 0;
		coliterend = w8;
	}
	for (let i = rowiterstart; i < rowiterend; i +=1) {
		for (let j = coliterstart; j < coliterend; j+=1) {
			let a = ImBCBase.getPix(Math.abs(transpose ? i :j)*sfact, Math.abs(transpose ? j :i)*sfact, w, view, typ);
			outpix.push(a[0]);
			if (a[0] > maxred) maxred = a[0];
			if (a[0] < minred) minred = a[0];
			if (a[0] > allmax) allmax = a[0];
			if (a[0] < allmin) allmin = a[0];
			outpix.push(a[1]);
			if (a[1] > maxgreen) maxgreen = a[1];
			if (a[1] < mingreen) mingreen = a[1];
			if (0.6*a[1] > allmax) allmax = a[1] * 0.6;
			if (0.6*a[1] < allmin) allmin = a[1] * 0.6;
			outpix.push(a[2]);
			if (a[2] > maxblue) maxblue = a[2];
			if (a[2] < minblue) minblue = a[2];
			if (a[2] > allmax) allmax = a[2];
			if (a[2] < allmin) allmin = a[2];
			if (!scale) outpix.push(255);
		}
	}
	const fact = 255 / (allmax - allmin);
	const o = scale ? 3 : 4;
	for (let i = 0; i < h8; i++) {
		for (let j=0; j< w8; j++) {
			if ((outpix[o*((i * w8) + j)] > 250) &&
				(outpix[o*((i * w8) + j) + 2] > 250) &&
				(outpix[o*((i * w8) + j) + 1] > 0.6 * 250))
			{
				outpix[o*((i*w8) + j) + 1] = 255;
			} else {
				// maybe some brightening gamma?
				const r = (fact * (outpix[o * ((i*w8) + j)] - allmin));
				outpix[o * ((i*w8) + j)] = 255-Math.round(255*((255-r)/255)*((255-r)/255));
				const g = (fact * 0.6 * (outpix[o * ((i*w8) + j) + 1] - allmin* 0.6));
				outpix[o * ((i*w8) + j) + 1] = 255-Math.round(255*((255-g)/255)*((255-g)/255));
				const b = (fact * (outpix[o * ((i*w8) + j) + 2] - allmin));
				outpix[o * ((i*w8) + j) + 2] = 255-Math.round(255*((255-b)/255)*((255-b)/255));
			}
		}
	}
	return outpix;
}
/* ImBCBase: handle one entry from imb PHOTO/MOVIE listing page */
handle1imb(url) {
	let rawname = ImBCBase.basename(url);
	if (rawname.substring(0,10).toUpperCase() === 'IMBRAW2DNG') return;
	let timestx = ImBCBase.fnregex.exec(rawname);
	let timest = null, cl = '9999_99_99-99';
	if (null !== timestx) {
		timest = timestx[1] + '_' + timestx[3] + '_' + timestx[5] + '-' + timestx[7] + '_' + timestx[9] + '_' + timestx[11];
		cl = timestx[1] + '_' + timestx[3] + '_' + timestx[5] + '-' + timestx[7];
	} else {
		this.mappx(false, 'words.warning');
		this.mappx(true, 'onimback.strangename', rawname);
	}
	if (rawname.substring(rawname.length -4).toUpperCase() === '.RAW') {
		if (null !== timest) {
			if (timest < this.earliestraw) this.earliestraw = timest;
			if (timest > this.latestraw) this.latestraw = timest;
		}
		this.rimbpics.push(url);
		if (this.imbeles && this.typedclasses) {
			this.imbeles.push({
					type: 'RAW',
					url: url,
					raw: rawname,
					ts: cl,
					selected: false,
					preview: null,
					entry: null,
					waiting: false,
					error: false,
					processed: false
			});
			if (this.untypedclasses.findIndex(v => v === cl) === -1)
				this.untypedclasses.push(cl);
			if (this.typedclasses.findIndex(v => v === ('RAW' + cl)) === -1)
				this.typedclasses.push('RAW' + cl);
		}
	}
	else if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG') {
		if (null !== timest) {
			if (timest < this.earliestjpg) this.earliestjpg = timest;
			if (timest > this.latestjpg) this.latestjpg = timest;
		}
		this.imbpics.push(url);
		if (this.imbeles && this.typedclasses) {
			this.imbeles.push({
					type: 'JPG',
					url: url,
					raw: rawname,
					ts: cl,
					selected: false,
					preview: null,
					entry: null,
					waiting: false,
					error: false,
					processed: false
			});
			if (this.untypedclasses.findIndex(v => v === cl) === -1)
				this.untypedclasses.push(cl);
			if (this.typedclasses.findIndex(v => v === ('JPG' + cl)) === -1)
				this.typedclasses.push('JPG' + cl);
		}
	}
	else {
		if (null !== timest) {
			if (timest < this.earliestmov) this.earliestmov = timest;
			if (timest > this.latestmov) this.latestmov = timest;
		}
		this.imbmovies.push(url);
		if (this.imbeles && this.typedclasses) {
			this.imbeles.push({
					type: 'oth',
					url: url,
					raw: rawname,
					ts: cl,
					selected: false,
					preview: null,
					entry: null,
					waiting: false,
					error: false,
					processed: false
			});
			if (this.untypedclasses.findIndex(v => v === cl) === -1)
				this.untypedclasses.push(cl);
			if (this.typedclasses.findIndex(v => v === ('oth' + cl)) === -1)
				this.typedclasses.push('oth' + cl);
		}
	}
}
/* Indentation in - end of class ImBCBase */
}
/* *************************************** Main class E N D *************************************** */
/* *************************************** HTML helper class *************************************** */
class ImBCHtmlOut extends ImBCBase {
/* Indentation out */
// ImBCHtmlOut: from the back itself
untypedclasses = []; // elements for groups with type for visual browser
typedclasses = []; // elements for groups with type for visual browser
imbeles = [];
// current preview image
currentrot = 1; // see oriecw above
// single-step/process all/skip all
stepmode = 1;
// bottom most text index
#dispcnt = 1;
// const if html:
checkdlfolder = true;
constructor() {
	super();
}
/* ImBCHtmlOut: output one thing via browser */
writefile(name, type, okmsg, arr1, fromloop) {
	let b = new Blob([ arr1 ], { type: type });
	const outel = document.getElementById('result');
	outel.download = name;
	const thisurl = URL.createObjectURL(b);
	outel.href = thisurl;
	outel.click();
	this.appmsgxl(false, 'words.finished');
	this.appmsgxl(true, okmsg, name);
	this.writepostok(name, okmsg, fromloop);
}
/* ImBCHtmlOut: find html style for translation */
applystyle(span, msg, base) {
	if (undefined === base) base = ImBCBase.texts;
	const i = msg.indexOf('.');
	if (i === -1) {
		let r = base[msg]['htmlstyle'];
		if (r !== undefined) {
			for (const s of r) {
				span.style[s[0]] = s[1];
			}
		}
		return span;
	}
	else {
		const e = base[msg.substring(0,i)];
		return this.applystyle(span, msg.substring(i+1), e);
	}
}
/* ImBCHtmlOut: output function to main log */
appmsg(msg, opt) {
	const s = document.createElement('span');
	s.innerHTML = msg;
	this.#dispcnt++;
	s.id = 'mappx_' + this.#dispcnt;
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	msgel.append(s);
	const ll = document.getElementById('mappx_' + this.#dispcnt);
	if (ll) {
		ll.scrollIntoView(false, { block: 'nearest' });
	}
	if (opt !== false)
		msgel.innerHTML += '<br>';
	if (opt === true)
		msgel.innerHTML += '<br>&nbsp;<br>';
}
/* ImBCHtmlOut: output function to main log */
appmsgxl(opt, msg, arg0, arg1, arg2, arg3) {
	const s = this.genspan(msg, arg0, arg1, arg2, arg3);
	this.#dispcnt++;
	s.id = 'mappx_' + this.#dispcnt;
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	msgel.append(s);
	const ll = document.getElementById('mappx_' + this.#dispcnt);
	if (ll) {
		ll.scrollIntoView(false, { block: 'nearest' });
	}
	if (opt !== false)
		msgel.innerHTML += '<br>';
	if (opt === true)
		msgel.innerHTML += '<br>&nbsp;<br>';
}
/* translate one element */
xl1(el) {
	if (el.attributes.getNamedItem('data-myxlkey')) {
		el.innerHTML = this.xl(el.attributes.getNamedItem('data-myxlkey').value, el.attributes.getNamedItem('data-myxlarg0')?.value, el.attributes.getNamedItem('data-myxlarg1')?.value, el.attributes.getNamedItem('data-myxlarg2')?.value, el.attributes.getNamedItem('data-myxlarg3')?.value );
	}
	if (el.attributes.getNamedItem('data-myvalxlkey')) {
		el.value = this.xl(el.attributes.getNamedItem('data-myvalxlkey').value);
	}
	if (el.attributes.getNamedItem('data-mytitlexlkey')) {
		el.title = this.xl(el.attributes.getNamedItem('data-mytitlexlkey').value);
	}
	if (el.attributes.getNamedItem('data-myhrefxlkey')) {
		el.href = this.xl(el.attributes.getNamedItem('data-myhrefxlkey').value);
	}
	return el;
}
/* ImBCHtmlOut: wrapper for zip output */
starthandleone() {
	if (this.totnum > 0 && !this.imbcb && window.showSaveFilePicker && document.getElementById('usezip').checked) {
		window.showSaveFilePicker({
			types: [ { description: 'Output Zip Archive', accept: { "application/zip": [ ".zip", ".ZIP" ] } } ],
			startIn: 'downloads',
			suggestedName: 'imbraw2dng_' + ('' + Date.now()).substring(3,10) + '_out.zip'
		}).then((newHandle) => {
			newHandle.getFile().then((f) => {
				this.zipname = f.name;
				newHandle.createWritable().then((ws) => {
					this.writestream = ws;
					this.zip = new ZIPHelp((data, cb) => {
						let p = this.writestream.write(data);
						p.then(() => { cb(); }).catch((e) => {
							this.mappx(false, 'words.error');
							this.mappx(0, 'process.errsave', this.zipname);
							this.appmsg(JSON.stringify(e), true);
							cb();
						});
					});
					this.handleonex();
				}).catch((e) => {
					this.mappx(false, 'words.error');
					this.mappx(0, 'process.errsave', this.zipname);
					this.appmsg(JSON.stringify(e), true);
				});
			}).catch((e) => {
				this.mappx(false, 'words.error');
				this.mappx(0, 'process.errsave', '??');
				this.appmsg(JSON.stringify(e), true);
			});
		});
	}
	else this.handleonex();
}
/* ImBCHtmlOut: main handler function for one file */
handleonex() {
	const f = (this.debugflag && this.useraw) ? this.useraw : this.allfiles[this.actnum];
	this.currentrot = 1;
	document.getElementById('doforall').checked = false;
	if (this.actnum < this.totnum-1) {
		document.getElementById('forrest').style['display'] = '';
	} else document.getElementById('forrest').style['display'] = 'none';
	let rawname = ImBCBase.basename(f.url ? f.url : (f.name ? f.name : f));
	if (this.stepmode === 2) {
		// skip rest
		if (!this.imbcb) this.shownormal();
		return this.handlenext();
	}
	else if (this.stepmode === 1) {
		// show preview and ask for rotation, skip, save
		// then (in handler) set mode, call handleone (if save) or handlenext (if skip)
		if (!this.imbcb) this.showquestion();
		if (undefined === f) {
			return;
		}
		if (this.totnum > 1) {
			document.getElementById('qhdr').innerHTML = '[' + (1 + this.actnum) + ' / ' + this.totnum + '] ';
		} else document.getElementById('qhdr').innerHTML = '';
		if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG' ||
			rawname.substring(rawname.length -5).toUpperCase() === '.JPEG') {
			/* jpeg preview */
			this.#qappx('main.file.jpeg', rawname);
			if (f.name) {
				// read jpeg file for preview
				const fr = new FileReader();
				fr.onload = (evt) => {
					let contents = evt.target.result;
					contents = 'data:image/jpeg;' + contents.substring(8);
					document.getElementById('jpegpreview').src = contents;
					/* shown in onload of img */
				}
				fr.onerror = (evt) => {
					console.log('JPEG preview reader error for ' + f.name + ' ' + JSON.stringify(evt));
					this.setpverr();
				}
				fr.readAsDataURL(f);
			}
			else {
				// simply set image src
				document.getElementById('jpegpreview').src = f;
			}
		}
		else if (rawname.substring(rawname.length -4).toUpperCase() !== '.RAW') {
			/* no preview */
			this.#qappx('main.file.nopreview', rawname);
			this.setnopv();
		}
		else {
			const zz = ImBCBase.infos.findIndex(v => v.size === f.size);
			if (zz === -1 && undefined !== f.size) {
				/* no preview */
				this.#qappx('main.file.rawunknown', rawname, f.size);
				this.setnopv();
			} else {
				this.#qappx('main.file',rawname);
				this.buildpreview(f, () => { this.setrawpv(); }, () => { this.setpverr(); });
			}
		}
	}
	else { // normal processing without question
		if (this.imbcb)
			this.imbcb.handleone();
		else {
			this.shownormal();
			this.handleone(f.rot);
		}
	}
}
/* ImBCHtmlOut: translation helper */
genspan(key, arg0, arg1, arg2, arg3) {
	const s = this.applystyle(document.createElement('span'), key);
	s.setAttribute('data-myxlkey', key);
	if (undefined !== arg0) {
		s.setAttribute('data-myxlarg0', arg0);
		if (undefined !== arg1) {
			s.setAttribute('data-myxlarg1', arg1);
			if (undefined !== arg2) {
				s.setAttribute('data-myxlarg2', arg2);
				if (undefined !== arg3) {
					s.setAttribute('data-myxlarg3', arg3);
				}
			}
		}
	}
	return this.xl1(s);
}
/* ImBCHtmlOut: translated append to preview header */
#qappx(key, arg0, arg1, arg2, arg3) {
	const s = this.genspan(key, arg0, arg1, arg2, arg3);
	document.getElementById('qhdr').append(s);
}
/* ImBCHtmlOut: handle the normal selection from imback (do it button), also for nodejs */
imbdoit() {
	if (this.actnum !== this.allfiles.length) return;
	let selecteds = [];
	let compval = '0000';
	if (document.getElementById('imbstartts').value != undefined && document.getElementById('imbstartts').value.length > 0) {
		compval = document.getElementById('imbstartts').value;
		if (null === ImBCBase.tsregex.exec(compval)) {
			this.mappx(false, 'words.error');
			this.mappx(0, 'onimback.invaltime', compval);
			alert(this.rmesc(this.xl('onimback.invaltime'), compval));
			return;
		}
	}
	if (document.getElementById('rpicfromimb').checked) {
		for (const e of this.rimbpics) {
			let rawname = ImBCBase.basename(e);
			if (this.comptime(rawname, compval))
				selecteds.push(e);
		}
	}
	if (document.getElementById('picfromimb').checked) {
		for (const e of this.imbpics) {
			let rawname = ImBCBase.basename(e);
			if (this.comptime(rawname, compval))
				selecteds.push(e);
		}
	}
	if (document.getElementById('movfromimb').checked) {
		for (const e of this.imbmovies) {
			let rawname = ImBCBase.basename(e);
			if (this.comptime(rawname, compval))
				selecteds.push(e);
		}
	}
	selecteds.sort((a, b) => {
		let ra = ImBCBase.basename(a);
		let rb = ImBCBase.basename(b);
		if (ra < rb) return -1;
		else if (ra === rb) return 0;
		else return 1;
	});
    this.stepmode = 0;
	const stepprev = document.getElementById('steppreview');
	if (stepprev !== null && stepprev.checked) this.stepmode = 1;
	const copytext = document.getElementById('copytext');
	const copycheck = document.getElementById('copycheck');
	this.copyright = '';
	if (copycheck !== null && copycheck.checked && copytext !== null && copytext.value !== '') this.copyright = copytext.value;
	this.totnum = selecteds.length;
	this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
	this.actnum = 0;
	this.allfiles = selecteds;
	this.mappx(true, 'process.frombackn', this.totnum);
	if (this.totnum > 0) {
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true
		this.starthandleone();
	}
	else this.mappx(true, 'onimback.nomatch');
}
/* ImBCHtmlOut: translate everything */
xlateall() {
	document.getElementById('mainversion').innerHTML = ImBCBase.version;
	document.documentElement.lang = this.mylang;
	const k = document.querySelectorAll('*[data-myxlkey]');
	for (const e of k)
		this.xl1(e);
	const l = document.querySelectorAll('*[data-myvalxlkey]');
	for (const e of l)
		this.xl1(e);
	const m = document.querySelectorAll('*[data-mytitlexlkey]');
	for (const e of m)
		this.xl1(e);
	const h = document.querySelectorAll('*[data-myhrefxlkey]');
	for (const e of h)
		this.xl1(e);
	if (undefined === this.imbcb)
		document.title = this.xl('main.title') + ' ' + ImBCBase.version;
	else
		document.title = this.xl('main.backw.title') + ' ' + ImBCBase.version;
}
/* ImBCHtmlOut: nodejs: parse config */
parseconfig(data) {
	const d = JSON.parse(data);
	if (d.np) this.withpreview = false;
	else this.withpreview = true;
	if (undefined !== d.cr) this.copyright = d.cr;
	if (d.l) this.trylang(d.l);
	if (d.zip && window.showSaveFilePicker && !this.imbcb) document.getElementById('usezip').checked = true;
	if (d.step) this.stepmode = 1;
	else this.stepmode = 0;
}
/* ImBCHtmlOut: browserdisplay: put last message viewable */
showlastmsg() {
	const ll = document.getElementById('mappx_' + this.#dispcnt);
	if (ll) {
		ll.scrollIntoView(false, { block: 'nearest' });
	}
}
/* ImBCHtmlOut: post write ok handler */
writepostok(name, fromloop) {
	const ie = this.imbeles.find((v) => v.raw.substring(0, v.raw.length - 3) === name.substring(0, name.length - 3));
	if (ie) {
		ie.wasselected = true;
		if (ie.entry)
			ie.entry.classList.add('picprocd');
	}
	this.stats.ok++;
	this.handlenext(fromloop);
}
/* Indentation in - end of class ImBCHtmlOut */
}
/* *************************************** HTML helper class E N D *************************************** */
/* *************************************** Main class for HTML, forward *************************************** */
writestream = null;
zip = null;
zipname = '';
ziperr = false;
class ImBCHtml extends ImBCHtmlOut {
/* Indentation out */
constructor() {
	super();
}
// from the back itself
#maxcache = 30; // max. length of cache for already downloaded raw data - you may increase or decrease this
#cache = []; // actual cache buffer
#loaderrunning=false; // currently handled browser raw preview download
#fromvisbrows = false;
/* deleting */
#deletephase = 0;

/* ImBCHtml: browserdisplay: copyright checkbox change */
chgcopycheck() {
    const copytext = document.getElementById('copytext');
    const copycheck = document.getElementById('copycheck');
    if (null !== copytext) {
    	if (null !== copycheck && copycheck.checked)
    		copytext.style['display'] = '';
    	else
    		copytext.style['display'] = 'none';
    }
    this.dirtysettings();
}
/* ImBCHtml: browserdisplay: handler for file selection input */
fselected() {
	if (this.actnum !== this.allfiles.length) return;
    const stepprev = document.getElementById('steppreview');
    this.stepmode = 0;
    const copytext = document.getElementById('copytext');
    const copycheck = document.getElementById('copycheck');
	if (stepprev !== null && stepprev.checked) this.stepmode = 1;
	this.copyright = '';
	if (copycheck !== null && copycheck.checked && copytext !== null && copytext.value !== '') this.copyright = copytext.value;
	const el = document.getElementById('infile');
	this.totnum = el.files.length;
	this.actnum = 0;
	this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
	this.allfiles = el.files;
	if (this.totnum > 0) {
		this.appmsgxl(true, 'process.selectedn', this.totnum);
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true;
		this.starthandleone();
	}
}
/* ImBCHtml: translation helper with title * /
#genspantitle(title, key, arg0, arg1, arg2, arg3) {
	const s = this.genspan(key, arg0, arg1, arg2, arg3);
	s.setAttribute('data-mytitlexlkey', title);
	return this.xl1(s);
}*/
/* ImBCHtml: preview: switch preview config to jpeg img */
setjpegpv() {
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = '';
	document.getElementById('continues').style['display']='';
}
/* ImBCHtml: preview: switch preview config to err */
setpverr() {
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewerr').style['display'] = '';
}
/* ImBCHtml: preview: switch preview config to wait */
setpvwait() {
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
	document.getElementById('previewwait').style['display'] = '';
}
/* ImBCHtml: browserdisplay: open visual browser */
showbrowser() {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	document.getElementById('browser').style['display'] = '';
	quest.style['display'] = 'none';
	norm.style['display'] = 'none';
	window.onscroll = () => this.#startloadimg();
	window.onresize = () => this.#startloadimg();
	this.#startloadimg();
}
/* ImBCHtml: visual browser: prepare the browser display, group the stuff */
aftercheck() {
	document.getElementById('piccnt').innerHTML = '' + this.imbpics.length;
	if (this.earliestjpg.length > 4) {
		document.getElementById('picinterval').innerHTML += '(';
		document.getElementById('picinterval').innerHTML += this.earliestjpg;
		document.getElementById('picinterval').innerHTML += ' - ';
		document.getElementById('picinterval').innerHTML += this.latestjpg;
		document.getElementById('picinterval').innerHTML += ')';
		document.getElementById('picinterval').style['display']='';
	}
	document.getElementById('piccnt').removeAttribute('data-myxlkey');
	document.getElementById('rpiccnt').innerHTML = '' + this.rimbpics.length;
	if (this.earliestraw.length > 4) {
		document.getElementById('rpicinterval').innerHTML += '(';
		document.getElementById('rpicinterval').innerHTML += this.earliestraw;
		document.getElementById('rpicinterval').innerHTML += ' - ';
		document.getElementById('rpicinterval').innerHTML += this.latestraw;
		document.getElementById('rpicinterval').innerHTML += ')';
		document.getElementById('rpicinterval').style['display']='';
	}
	document.getElementById('rpiccnt').removeAttribute('data-myxlkey');
	document.getElementById('movcnt').innerHTML = '' + this.imbmovies.length;
	if (this.earliestmov.length > 4) {
		document.getElementById('movinterval').innerHTML += '(';
		document.getElementById('movinterval').innerHTML += this.earliestmov;
		document.getElementById('movinterval').innerHTML += ' - ';
		document.getElementById('movinterval').innerHTML += this.latestmov;
		document.getElementById('movinterval').innerHTML += ')';
		document.getElementById('movinterval').style['display']='';
	}
	document.getElementById('movcnt').removeAttribute('data-myxlkey');
	document.getElementById('imbdoit').disabled = false;
	document.getElementById('imbvisbrows').disabled = false;
	document.getElementById('notimback').style['display'] = 'none';
	if (this.untypedclasses[0].title) return;
	for (const x of this.untypedclasses) {
		const cl = {
			title: x,
			level: 5,
			fmembers: []
		};
		cl.entry = document.createElement('div');
		cl.entry.id = 'gg_' + x + '_X';
		cl.entry.classList.add('gg');
		cl.entry.classList.add('ggclosed');
		cl.entry.classList.add('gl5');
		for (const y of this.imbeles) {
			if (x === y.ts)
			{
				// todo: sort
				cl.fmembers.push(y);
				y.inuntyped = true;
			}
		}
		this.untypedclasses.splice(this.untypedclasses.findIndex(v => v === x), 1, cl);
	}
	for (const x of this.typedclasses) {
		const cl = {
			title: x,
			level: 5,
			fmembers: []
		};
		cl.entry = document.createElement('div');
		cl.entry.id = 'gg_' + x + '_X';
		cl.entry.classList.add('gg');
		cl.entry.classList.add('ggclosed');
		cl.entry.classList.add('gl5');
		for (const y of this.imbeles) {
			if (x === y.type + y.ts)
			{
				// todo: sort
				cl.fmembers.push(y);
				y.intyped = true;
			}
		}
		this.typedclasses.splice(this.typedclasses.findIndex(v => v === x), 1, cl);
	}
	this.#higherclasses(this.untypedclasses, 10, 5);
	this.#higherclasses(this.typedclasses, 13, 5);
	// top type classes here
	for (const u of this.typedclasses.filter((o) => o.level === 2)) {
		if (u.ischild) continue;
		if (this.typedclasses.filter((o) => u.title.substring(0,3) === o.title.substring(0,3)).length === 1) {
			u.level --;
			u.entry.classList.add('gl' + u.level);
			u.entry.classList.remove('gl' + (u.level + 1));
		} else if (this.typedclasses.findIndex((o) => o.title === u.title.substring(0,3)) === -1) {
			const cl = {
				title: u.title.substring(0,3),
				level: 1,
				smembers: []
			};
			cl.entry = document.createElement('div');
			cl.entry.id = 'gg_' + u.title.substring(0,3) + '_X';
			cl.entry.classList.add('gg');
			cl.entry.classList.add('ggclosed');
			cl.entry.classList.add('gl1');
			for (const x of this.typedclasses.filter((o) => u.title.substring(0,3) === o.title.substring(0,3))) {
				x.ischild = true;
				// todo: sort when display
				cl.smembers.push(x);
				cl.haschildren = true;
				this.typedclasses.splice(this.typedclasses.findIndex((o) => o.title === x.title),1);
			}
			this.typedclasses.push(cl);
		}
	}
	// non-typed upgraded to gl1, unless only one
	if (this.untypedclasses.filter((o) => o.level === 2).length === 1 && this.untypedclasses.filter((o) => o.level === 2)[0].smembers) {
		const t = this.untypedclasses.filter((o) => o.level === 2)[0];
		this.untypedclasses.splice(0,1);
		for (const s of t.smembers) {
			s.entry.classList.add('gl1');
			s.level = 2;
			this.untypedclasses.push(s);
		}
	} else
		for (const s of this.untypedclasses.filter((o) => o.level === 2)) s.entry.classList.add('gl1');
	// build title elemenes
	for (const s of this.untypedclasses) this.#buildtitlerec(s);
	for (const s of this.typedclasses) this.#buildtitlerec(s);
	if (document) {
		document.getElementById('brnsel').innerHTML = '0';
		document.getElementById('brntot').innerHTML = '' + this.imbeles.length;
		this.buildtree();
	}
	/* debug * /
	if (debugflag) {
		for (const s of untypedclasses.filter((o) => o.level === 2)) prgr(s,1);
		for (const s of typedclasses.filter((o) => o.level === 1)) prgr(s,1);
	} */
}
/* ImBCHtml: visual browser: build ordered lists */
buildtree() {
	let list, toplevel;
	if (document.getElementById('sbytype').checked) {
		list = this.typedclasses;
		toplevel = 1;
	}
	else {
		list = this.untypedclasses;
		toplevel = 2;
	}

	// first, make everything empty
	for (const e of this.untypedclasses) {
		e.entry.remove();
		this.#doclose(e, true);
	}
	for (const e of this.typedclasses) {
		e.entry.remove();
		this.#doclose(e, true);
	}
	for (const d of this.imbeles) {
		if (undefined !== d.entry && null !== d.entry)
			d.entry.remove();
	}

	// now, sort and add
	for (const e of list.filter((o) => o.level === toplevel).sort((a,b) => this.#mysort(a, b))) {
		document.getElementById('browser').append(e.entry);
		this.#addsorted(e);
	}
	this.xlateall();
}
/* ImBCHtml: visual browser: find next to load */
#findnexttoload(alsooutside) {
	for (const e of this.imbeles.sort((a,b) => this.#myisort(a,b))) {
		// display: none somewhere?
		if (!e.entry) continue;
		const p = e.entry;
		if (!p.parentElement) continue;
		// not waiting or error at all?
		if (e.type === 'oth') continue;
		if (e.nonewerr) continue;
		if (p.attributes.getNamedItem('data-state').value !== 'err' && p.attributes.getNamedItem('data-state').value !== 'wait') continue;
		let dispno = false;
		let f = p.parentElement;
		while (f) {
			if (f.style['display'] === 'none') {
				dispno = true;
				break;
			}
			if (f.classList.contains('ggclosed')) {
				dispno = true;
				break;
			}
			f = f.parentElement;
		}
		if (dispno) continue;
		// display not none, check pos
		let rect = p.getBoundingClientRect();
		if (rect.top < window.innerHeight && rect.bottom > 0 && rect.width > 0)
			return e;
		if (alsooutside && rect.bottom > 0 && rect.width > 0)
			if ((p.querySelector('.waitdiv') && p.querySelector('.waitdiv').style['display'] !== 'none') ||
				(p.querySelector('.errimg') && p.querySelector('.errimg').style['display'] !== 'none'))
			return e;
	}
	return undefined;
}
/* ImBCHtml: visual browser: sort helper */
#mysort(a, b) {
	const fact = document.getElementById('solder').checked ? 1 : -1
	if (a.title > b.title) return fact;
	else if (a.title < b.title) return -1 * fact;
	else return 0;
}
/* ImBCHtml: visual browser: sort helper */
#myisort(a, b) {
	const fact = document.getElementById('solder').checked ? 1 : -1
	if (a.raw > b.raw) return fact;
	else if (a.raw < b.raw) return -1 * fact;
	else return 0;
}
/* ImBCHtml: visual browser: add images sorted  */
#addimgsorted(el) {
	if (el.fmembers !== null && el.fmembers !== undefined) {
		for (const e of el.fmembers.sort((a,b) => this.#myisort(a, b))) {
			if (null === e.entry || undefined === e.entry) this.#displaydiv(e);
			el.entry.querySelector('.igtype').append(e.entry);
			e.nonewerr = false; // retry again if was error
		}
	}
}
/* ImBCHtml: visual browser: add sorted recursively */
#addsorted(el) {
	if (el.smembers === null || el.smembers ===  undefined) return;
	for (const e of el.smembers.sort((a,b) => this.#mysort(a, b))) {
		this.#addsorted(e);
		el.entry.append(e.entry);
	}
}
/* ImBCHtml: visual browser: recursive texts */
#buildtitlerec(el) {
	this.#buildtitle(el);
	if (el.smembers === null || el.smembers ===  undefined) return;
	for (const e of el.smembers) {
		this.#buildtitlerec(e);
	}
}
/* ImBCHtml: visual browser: recursive fold close */
#doclose(gr, recurse) {
	const e = gr.entry;
	e.querySelector('.ggtt').classList.add('ggttclosed');
	e.querySelector('.ggtt').classList.remove('ggttopen');
	e.classList.add('ggclosed');
	e.classList.remove('ggopen');
	if (recurse && gr.smembers)
		for (const m of gr.smembers) this.#doclose(m, recurse);
}
/* ImBCHtml: visual browser: recursive fold open */
#doopen(gr, recurse, nontop) {
	const e = gr.entry;
	e.querySelector('.ggtt').classList.remove('ggttclosed');
	e.querySelector('.ggtt').classList.add('ggttopen');
	e.classList.remove('ggclosed');
	e.classList.add('ggopen');
	if (recurse && gr.smembers)
		for (const m of gr.smembers) this.#doopen(m, recurse, true);
	if (gr.fmembers) {
		for (const m of gr.fmembers) {
			if (m.entry) m.entry.remove();
		}
	}
	if (gr.fmembers && !e.querySelector('.onepic'))
		this.#addimgsorted(gr);
	if (nontop !== true) this.#startloadimg();
}
/* ImBCHtml: visual browser: select all from top */
topreccheck(force) {
	if (undefined === force)
		force = document.getElementById('selall').checked;
	this.#reccheck(force);
}
/* ImBCHtml: visual browser: select all */
#reccheck(to, root) {
	if (undefined === root) {
		for (const e of this.typedclasses) this.#reccheck(to, e);
		for (const e of this.untypedclasses) this.#reccheck(to, e);
		return;
	} else {
		root.entry.querySelector('.selcb').checked = to;
		if (root.fmembers) {
			for (const e of root.fmembers) {
				e.selected = to;
				if (e.entry) e.entry.querySelector('.selcb').checked = to;
			}
		}
		if (root.smembers)
			for (const e of root.smembers) this.#reccheck(to, e);
	}
	this.#updateselections();
}
/* ImBCHtml: visual browser: text and controls on top of a group */
#buildtitle(gr) {
	let t = '', s = gr.title;
	const d = document.querySelector('#titlet').content.querySelector('.titletop').cloneNode(true); //document.createElement('div');
	const pluss = d.querySelector('.ggttp');
	pluss.onclick = () => {
		this.#doopen(gr, false);
	};
	const pluspluss = d.querySelector('.ggttpp');
	if (gr.haschildren) {
		pluspluss.innerHTML = '[++]';
		pluspluss.onclick = () => {
			this.#doopen(gr, true);
		};
	}
	const minuss = d.querySelector('.ggttm');
	minuss.onclick = () => {
		d.classList.remove('ggttopen');
		d.classList.add('ggttclosed');
		d.parentElement.classList.remove('ggopen');
		d.parentElement.classList.add('ggclosed');
		this.#startloadimg();
	};
	const sp = d.querySelector('.gtype');
	if (s.startsWith('JPG') || s.startsWith('RAW')) {
		sp.append(' ' + s.substring(0,3) + ': ');
		s = s.substring(3);
	} else if (s.startsWith('oth')) {
		sp.setAttribute('data-myxlkey', 'main.types.notpic');
		s = s.substring(3);
	}
	if (s.length > 0) t += (' ' + s);
	const tit = d.querySelector('.grtit');
	tit.append(t);
	//const selno = d.querySelector('.selnumber');
	//selno.id = 'SEL_' + gr.title;
	const totno = d.querySelector('.totno');
	//totno.id = 'TOT_' + gr.title;
	totno.append('' + this.#countfiles(gr));
	const texttit = d.querySelector('label');
	const cb = d.querySelector('.selcb');
	cb.id = 'SELC_' + gr.title;
	texttit.htmlFor = cb.id;
	cb.onclick = (/*ev*/) => {
		if (cb.checked) this.#reccheck(true, gr);
		else this.#reccheck(false, gr);
	};

	gr.entry.append(d);
	if (!gr.haschildren) {
		const ig = document.createElement('div');
		ig.classList.add('igtype');
		gr.entry.append(ig);
	}
}
/* ImBCHtml: visual browser: add classes upwards */
#higherclasses(arr, len, curlevel) {
	for (const u of arr.filter((o) => o.level === curlevel)) {
		if (u.ischild) continue;
		if (arr.filter((o) => u.title.substring(0,len) === o.title.substring(0,len)).length === 1) {
			u.level --;
			u.entry.classList.add('gl' + u.level);
			u.entry.classList.remove('gl' + (u.level + 1));
		} else if (arr.findIndex((o) => o.title === u.title.substring(0,len)) === -1) {
			const cl = {
				title: u.title.substring(0,len),
				level: curlevel - 1,
				smembers: []
			};
			cl.entry = document.createElement('div');
			const ce = cl.entry;
			ce.id = 'gg_' + u.title.substring(0,len) + '_X';
			ce.classList.add('gg');
			ce.classList.add('ggclosed');
			ce.classList.add('gl' + (curlevel - 1));
			for (const x of arr.filter((o) => u.title.substring(0,len) === o.title.substring(0,len))) {
				x.ischild = true;
				// todo: sort when open
				cl.smembers.push(x);
				cl.haschildren = true;
				arr.splice(arr.findIndex((o) => o.title === x.title),1);
			}
			arr.push(cl);
		}
	}
	if (curlevel === 5)
		this.#higherclasses(arr, len - 3, 4);
	else if (curlevel === 4)
		this.#higherclasses(arr, len - 3, 3);
}
/* visual browser: return count of files in class */
#countfiles(cla) {
	let res = 0;
	if (undefined !== cla.fmembers) res += cla.fmembers.length;
	if (undefined !== cla.smembers)
		for (const s of cla.smembers)
			res += this.#countfiles(s);
	return res;
}
/* ImBCHtml: visual browser: recursive count selection */
#countsel(gr) {
	let res = 0;
	if (gr.fmembers) {
		res += gr.fmembers.filter((o) => o.selected).length;
	}
	if (gr.smembers) {
		for (const g of gr.smembers)
			res += this.#countsel(g);
	}
	gr.entry.querySelector('.selnumber').innerHTML = '' + res;
	gr.entry.querySelector('.selcb').checked = (res === this.#countfiles(gr));
	gr.sels = res;
	return res;
}
/* ImBCHtml: visual browser: update all "selected" values */
#updateselections() {
	for (const s of this.typedclasses) this.#countsel(s);
	for (const s of this.untypedclasses) this.#countsel(s);
	let res = 0, sum = 0;
	for (const s of this.typedclasses) {
		res += s.sels;
		sum += this.#countfiles(s);
	}
	document.getElementById('brnsel').innerHTML = '' + res;
	document.getElementById('selall').checked = (res === sum);
	document.getElementById('delselbut').disabled = (res === 0);
}
/* ImBCHtml: visual browser: fill a html div into an imbele */
#displaydiv(e) {
	e.entry = document.querySelector('#onepict').content.querySelector('.onepic').cloneNode(true);
	const ne = e.entry;
	if (e.wasselected) ne.classList.add('picprocd');
	ne.id = 'div_' + e.raw + '_X';
	ne.classList.add(e.type + '_CL');
	let rawname = ImBCBase.basename(e.url);
	//e.entry.classList.add('ET_' + e.type + rawname.substring(0,12));
	//e.entry.classList.add('EY_' + rawname.substring(0,12));
	const topline = ne.querySelector('.pictitle');
	const check = ne.querySelector('.pictitle input');
	//check.name = 'cb_sel_' + e.raw + '_X';
	check.id = 'cb_sel_' + e.raw + '_X';
	check.checked = e.selected;
	check.onclick = () => {
		e.selected = check.checked;
		this.#updateselections();
	};
	topline.htmlFor = check.id;
	topline.append(rawname);
	const dlbtn = ne.querySelector('.dlbtn');
	if (e.type === 'oth') {
		topline.append(dlbtn);
		dlbtn.classList.remove('disabled');
		dlbtn.classList.remove('biggiebtn');
		ne.querySelector('.waitdiv').style['display'] = 'none';
		ne.setAttribute('data-state', 'ok');
	}
	let rotbtn = ne.querySelector('.rotbtn');
	if (e.type === 'RAW') {
		e.rot = 1;
		//rotbtn.id = 'rot_b_' + e.raw + '_Y';
		rotbtn.classList.add('disabled');
		rotbtn.onclick = () => {
			if (!this.debugflag && rotbtn.classList.contains('disabled')) return;
			let j = ImBCBase.oriecw.indexOf(e.rot);
			j = ((j + 1) % 4);
			e.rot = ImBCBase.oriecw[j];
			e.preview.style['display'] = 'none';
			ne.querySelector('.waitdiv').style['display'] = '';
			ne.querySelectorAll('.biggiebtn').forEach((x) => { x.classList.add('disabled') });
			ne.querySelector('.dlbtn').classList.add('disabled');
			ne.setAttribute('data-state', 'wait');
			this.#startloadimg();
		};
		dlbtn.onclick = (/*ev*/) => {
			if (!this.debugflag && dlbtn.classList.contains('disabled')) return;
			if (this.actnum !== this.allfiles.length) return;
			let selecteds = [ e ];
			this.#fromvisbrows = true;
			this.stepmode = 0;
			this.totnum = 1;
			this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
			this.actnum = 0;
			this.allfiles = selecteds;
			this.#startloadimg();
			document.getElementById('imbdoit').disabled = true;
			document.getElementById('imbvisbrows').disabled = true;
			document.getElementById('droptarget').style['display'] = 'none';
			document.getElementById('infile').disabled = true;
			this.shownormal();
			//this.#handleone(e.rot);
			ne.classList.add('picprocd');
		};
	}
	//dlbtn.id = 'dl_b_' + e.raw;
	else {
		dlbtn.onclick = (/*ev*/) => {
			if (!this.debugflag && dlbtn.classList.contains('disabled')) return;
			const outel = document.getElementById('result');
			outel.download = rawname;
			outel.href = e.url;
			outel.click();
			ne.classList.add('picprocd');
		};
	}
	let bigbtn = ne.querySelector('.bigbtn')
	bigbtn.classList.add('disabled');
	bigbtn.onclick = (/*ev*/) => {
		e.preview.classList.add('picbig');
	};
	
	if (e.type === 'RAW') {
		ne.setAttribute('data-state', 'wait');
		e.preview = ne.querySelector('.eeraw');
		//e.preview.classList.add('eewait');
		e.preview.style['display'] = 'none';
		e.preview.onmouseout = (/*ev*/) => {
			e.preview.classList.remove('picbig');
		}
	} else if (e.type === 'JPG') {
		e.preview = ne.querySelector('.eejpg');
		ne.setAttribute('data-state', 'wait');
		//e.preview.classList.add('eewait');
		e.preview.style['display'] = 'none';
		e.preview.onmouseout = (/*ev*/) => {
			e.preview.classList.remove('picbig');
		}
	}
}
/* ImBCHtml: visual browser: image loader call */
#loadimg(url, type, to/*, rot*/) {
	const e = to.entry;
	if ((e.attributes.getNamedItem('data-state').value !== 'err' && e.attributes.getNamedItem('data-state').value !== 'wait')
			|| (type === 'oth')) {
		if (this.debugflag) console.log('ldr aa lnx ' + to.raw);
		this.#loadnextimg();
		return;
	}
	e.setAttribute('data-state', 'load');
	e.querySelector('.errimg').style['display'] = 'none';
	e.querySelector('.waitdiv').style['display'] = '';
	to.preview.style['display'] = 'none';
	if (type === 'JPG') {
		to.preview.onload = (/*ev*/) => {
			e.setAttribute('data-state', 'ok');
			e.querySelector('.waitdiv').style['display'] = 'none';
			to.preview.style['display'] = '';
			to.preview.style['width'] = to.preview.woidth * (120 / to.preview.height);
			e.querySelectorAll('.biggiebtn').forEach((x) => { x.classList.remove('disabled') });
			e.querySelector('.dlbtn').classList.remove('disabled');
			if (this.debugflag) console.log('ldr j f lnx ' + to.raw);
			this.#loadnextimg();
		};
		to.preview.onerror = (ev) => {
			e.setAttribute('data-state', 'err');
			console.log('JPEG preview load error for ' + url + ' ' + JSON.stringify(ev));
			e.querySelector('.waitdiv').style['display'] = 'none';
			e.querySelector('.errimg').style['display'] = '';
			e.querySelectorAll('.biggiebtn').forEach((x) => { x.classList.add('disabled') });
			e.querySelector('.dlbtn').classList.add('disabled');
			if (this.debugflag) console.log('ldr j e lnx ' + to.raw);
			to.nonewerr = true;
			this.#loadnextimg();
		};
		to.preview.src = url;
	}
	else if (type === 'RAW') {
		let afterloadcalled = false;
		if (this.debugflag) console.log('li raw start bpv ' + url);
		this.buildpreview((this.debugflag && this.useraw) ? this.useraw : url, () => { /* on ok: */
			e.setAttribute('data-state', 'ok');
			e.querySelector('.waitdiv').style['display'] = 'none';
			e.querySelectorAll('.biggiebtn').forEach((x) => { x.classList.remove('disabled') });
			e.querySelector('.dlbtn').classList.remove('disabled');
			to.preview.style['display'] = '';
			if (this.debugflag) console.log('ldr r f ' + to.raw);
			if (!afterloadcalled) {
				if (this.debugflag) console.log('ldr r e lnx ' + to.raw);
				this.#loadnextimg();
			} // else the afterload had already been called
			else if (this.debugflag) {
				console.log('ldr r ff lnyy ' + to.raw);
			}
		}, () => { /* on err: */
			e.setAttribute('data-state', 'err');
			e.querySelector('.waitdiv').style['display'] = 'none';
			e.querySelector('.errimg').style['display'] = '';
			e.querySelectorAll('.biggiebtn').forEach((x) => { x.classList.add('disabled') });
			e.querySelector('.dlbtn').classList.add['disabled'];
			to.nonewerr = true;
			if (this.debugflag) console.log('ldr r e ' + to.raw);
			if (!afterloadcalled) {
				if (this.debugflag) console.log('ldr r e lnx ' + to.raw);
				this.#loadnextimg();
			} // else the afterload had already been called
			else if (this.debugflag) {
				console.log('ldr r ee lnyy ' + to.raw);
			}
		}, to.rot, to.preview, () => { /* afterload: */
			if (this.debugflag) console.log('ldr r l lnx ' + to.raw);
			// invalidate url for err callback
			this.#loaderrunning = '1';
			this.#loadnextimg();
			afterloadcalled = true;
		});
		if (this.debugflag) console.log('li raw end bpv ' + url);
	}
}
/* ImBCHtml: visual browser or from imback: load next from todo list */
#loadnextimg() {
	if (this.debugflag) console.log('L  N  I');
	let e;
	if (this.allfiles.length > 0 && this.actnum <= this.allfiles.length - 1) {
		e = this.allfiles[this.actnum];
		this.#loaderrunning = e.url;
		window.setTimeout(() => {
			if (this.debugflag) console.log('NN li dl ' + e.url + ' ' + this.actnum);
			if (undefined === e.url) {
				console.log('x');
				this.allfiles[this.actnum] = e;
				this.handleone(undefined, true);
			} else {
				this.allfiles[this.actnum] = e.url;
				this.handleone(e.rot, true);
			}
		}, 33);
		return;
	}
	e = this.#findnexttoload();
	if (!e) e = this.#findnexttoload(true);
	if (!e) {
		this.#loaderrunning = false;
		if (this.debugflag) console.log('TERM loader');
		return;
	}
	else {
		this.#loaderrunning = e.url;
		window.setTimeout(() => {
			if (this.debugflag) console.log('L ' + e.raw);
			this.#loadimg(e.url, e.type, e)
		}, 33);
	}
}
/* ImBCHtml: visual browser: start loading */
#startloadimg() {
	if (!this.#loaderrunning) {
		if (this.debugflag) console.log('start loader');
		this.#loadnextimg();
	}
	else if (this.debugflag) {
		console.log('load already on ' + this.#loaderrunning);
	}
}
/* ImBCHtml: visual browser: delete browser selected */
browserdelete() {
	document.getElementById('del_text').setAttribute('data-myxlarg0', this.imbeles.filter((o) => o.selected).length);
	this.xl1(document.getElementById('del_text'));
	document.getElementById('delq').style['display'] = '';
	document.getElementById('browser').style['display'] = 'none';
	document.getElementById('delokbut').disabled = false;
	document.getElementById('delcancelbut').disabled = false;
}
/* ImBCHtml: visual browser: do delete */
dodelete(list) {
	const deletephs = [ '|' , '/', '-', '\\' ];
	if (list === undefined && this.imbeles.filter((o) => o.selected).length === 0) {
		this.delcancel();
		return;
	}
	else if (list === undefined) {
		document.getElementById('delokbut').disabled = true;
		document.getElementById('delcancelbut').disabled = true;
		this.dodelete(this.imbeles.filter((o) => o.selected));
		this.#deletephase=0;
		document.getElementById('delprogmsg').innerHTML = deletephs[this.#deletephase];
		return;
	} else if (list.length > 0) {
		let xhr = new XMLHttpRequest();
		xhr.onload = () => {
			this.#deletephase ++;
			document.getElementById('delprogmsg').innerHTML = deletephs[this.#deletephase % deletephs.length];
			const pv = list[0].preview;
			if (pv)
				pv.classList.add('picdeleted');
			list.splice(0,1);
			this.dodelete(list);
			xhr.onerror = undefined;
			xhr.onload = undefined;
			xhr.ontimeout = undefined;
		};
		xhr.onerror = xhr.onload;
		xhr.ontimeout = xhr.onload;
		xhr.open('GET',list[0].url + '?del=1');
		xhr.send();
	} else {
		alert(this.xl('del.reload'));
		this.delcancel();
	}
}
/* ImBCHtml: visual browser: cancel the delete */
delcancel() {
	document.getElementById('delq').style['display'] = 'none';
	document.getElementById('browser').style['display'] = '';
}
/* ImBCHtml: visual browser: process browser selected */
browserprocess() {
	if (this.actnum !== this.allfiles.length) return;
	let selecteds = [];
	for (const i of this.imbeles) {
		if (i.selected) {
			selecteds.push(i);
		}
	}
	selecteds.sort((a, b) => {
		let ra = ImBCBase.basename(a.url);
		let rb = ImBCBase.basename(b.url);
		if (ra < rb) return -1;
		else if (ra === rb) return 0;
		else return 1;
	});
    this.stepmode = 0;
    const copytext = document.getElementById('copytext');
    const copycheck = document.getElementById('copycheck');
	this.copyright = '';
	if (copycheck !== null && copycheck.checked && copytext !== null && copytext.value !== '') this.copyright = copytext.value;
	this.totnum = selecteds.length;
	this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
	this.actnum = 0;
	this.allfiles = selecteds;
	if (this.totnum > 0) {
		this.mappx(true, 'process.frombrowsern', this.totnum);
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true
		this.shownormal();
		this.#startloadimg();
		this.topreccheck(false);
	} else {
		this.shownormal();
	}
}
/* ImBCHtml: html dng preview checkbox handler */
chgdngpreview() {
    const dngprev = document.getElementById('dngpreview');
    this.withpreview = (dngprev !== null && dngprev.checked);
    this.dirtysettings();
}
/* ImBCHtml: translate html for new language */
setlang() {
	if (this.mylang !== document.getElementById('langsel').value) this.dirtysettings();
	this.mylang = document.getElementById('langsel').value;
	this.xlateall();
}
/* ImBCHtml: browserdisplay: settings are dirty */
dirtysettings() {
	if (window.location.origin.startsWith('http') && window.localStorage) {
		document.getElementById('onlyhttp').style['display'] = 'none';
		document.getElementById('setsettings').style['display'] = '';
		document.getElementById('settingsset').style['display'] = 'none';
		document.getElementById('settingsset').setAttribute('data-myxlarg0',window.location.origin);
		document.getElementById('setsettingsurl').setAttribute('data-myxlarg0',window.location.origin);
	}
}
/* ImBCHtml: browserdisplay: save settings */
savesettings() {
	if (window.location.origin.startsWith('http') && window.localStorage) {
		try {
			const copytext = document.getElementById('copytext');
			const copycheck = document.getElementById('copycheck');
			let copyval = ''
			if (copycheck !== null && copytext !== null && copycheck.checked) {
				copyval = copytext.value;
			}
			let stepmode = 0;
			const stepprev = document.getElementById('steppreview');
			if (stepprev !== null && stepprev.checked) stepmode = 1;
			window.localStorage.setItem('imbraw2dng_json', JSON.stringify(
				{
					'cr': copyval,
					'np': document.getElementById('dngpreview') ? !document.getElementById('dngpreview').checked : false,
					'l': this.mylang,
					'step': stepmode,
					'version': ImBCBase.version,
					'loca': window.location.origin,
					'zip': document.getElementById('usezip')?.checked
				}
			));
		}
		catch (e) {
			console.log(JSON.stringify(e));
		}
		this.initsettings();
	}
}
/* ImBCHtml: try lang from node param */
trylang(i) {
	document.getElementById('langsel').value = this.findlang(i);
}
/* ImBCHtml: debug * /
#prgr(gr, indent) {
	const str = '                ';
	if (undefined === gr.title) return;
	console.log(str.substring(0,2*indent), gr.title, '   ', this.#countfiles(gr));
	if (undefined === gr.smembers) return;
	for (const s of gr.smembers) {
		this.#prgr(s, indent + 1);
	}
}*/
/* ImBCHtml: only debug */
dodebug() {
	const fr = new FileReader();
	fr.onload = (res) => {
		const dp = new DOMParser();
		const doc = dp.parseFromString(res.target.result,'text/html');
		const sel2 = doc.querySelectorAll('a');
		for (const r of sel2) {
			if (r && (-1 === r.href.indexOf('?del='))) {
				this.handle1imb(r.href);
			}
		}
		document.getElementById('dbgfsel').style['display'] = 'none';
		document.getElementById('onimback').style['display'] = '';
		this.aftercheck();
	};
	fr.readAsText(document.getElementById('dbgfsel').files[0]);
}
/* ImBCHtml: only debug - use local img instead of from imb */
replraw() {
	this.useraw = document.getElementById('dbgreplraw').files[0];
}
/* ImBCHtml: browserdisplay: handler function for dropping OS files into the rect */
drophandler(ev) {
	if (this.actnum !== this.allfiles.length) return;
    const stepprev = document.getElementById('steppreview');
    this.stepmode = 0;
    const copytext = document.getElementById('copytext');
    const copycheck = document.getElementById('copycheck');
	if (stepprev !== null && stepprev.checked) this.stepmode = 1;
	this.copyright = '';
	if (copycheck !== null && copycheck.checked && copytext !== null && copytext.value !== '') this.copyright = copytext.value;
	ev.preventDefault();
	this.allfiles = [];
	this.actnum = 0;
	if (ev.dataTransfer.items) {
		this.totnum = [...ev.dataTransfer.items].length;
		[...ev.dataTransfer.items].forEach((item/*, i*/) => {
			if (item.kind === "file") {
				this.allfiles.push(item.getAsFile());
			}
		});
	} else {
		this.totnum = [...ev.dataTransfer.files].length;
		[...ev.dataTransfer.files].forEach((file/*, i*/) => {
			this.allfiles.push(file);
		});
	}
	this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
	this.mappx(true, 'process.droppedn', this.totnum);
	document.getElementById('imbdoit').disabled = true;
	document.getElementById('imbvisbrows').disabled = true;
	document.getElementById('droptarget').style['display'] = 'none';
	document.getElementById('infile').disabled = true;
	document.getElementById('infileb').disabled = true;
	if (document.getElementById('fakelongexpadd')?.checked) {
		this.addall = true;
		this.addscaleall = document.getElementById('fakelongexpscale')?.checked;
		if (document.getElementById('fakelongexpadd')) document.getElementById('fakelongexpadd').checked = false;
	} else {
		this.addall = false;
		this.addscaleall = false;
	}
	this.starthandleone();
}
/* ImBCHtml: browserdisplay: some handler on the drop rectangle */
prevdef(ev) {
	ev.preventDefault();
}
/* ImBCHtml: browserdisplay: put preview into canvas */
// orientation: 1: norm, 3: rot 180, 6 rot 90 CW, 8: rot 270 CCW
buildpreview(f, onok, onerr, orientation, targ, afterload) {
	let w, h, typ;
	if (undefined === f.size) {
		window.setTimeout(() => {
		  this.resolver(f, (url, fx) => {
				this.buildpreview(fx, onok, onerr, orientation, targ, afterload);
			}, (/*url*/) => {
				onerr(f);
		  });
		});
		return;
	}
	const zz = ImBCBase.infos.findIndex(v => v.size === f.size);
	if (zz === -1) {
		console.log('preview: unsupported size ' + f.size + ' of ' + f.name);
		onerr(f);
		return;
	} else {
		w = ImBCBase.infos[zz].w;
		typ = ImBCBase.infos[zz].typ;
		h = ImBCBase.infos[zz].h;
	}
	let canv;
	if (undefined !== targ)
		canv = targ;
	else
		canv = document.getElementById('preview');
	const w8 = Math.floor((w+7)/8) - 1;
	const h8 = Math.floor((h+7)/8) - 1;
	canv.width = w8;
	canv.height = h8;
	if (orientation === 6 || orientation === 8) {
		canv.width = h8;
		canv.height = w8;
	}
	const ctx = canv.getContext('2d', { alpha: false });
	if (undefined !== targ) {
		const sc = 120 / canv.height;
		canv.style['width'] = '' + (sc*canv.width) + 'px';
	}
	const reader = f.imbackextension ? f : new FileReader();
	reader.onload = (evt) => {
		if (undefined !== afterload) afterload();
		const contents = evt.target.result;
		const view = new DataView(contents);
		let transpose = false;
		let outpix = ImBCBase.buildpvarray(view, typ, w, h, orientation, false);
        if (orientation === 6 || orientation === 8) {
                transpose = true;
        }
		ctx.putImageData(new ImageData(new Uint8ClampedArray(outpix), transpose ? h8: w8, transpose? w8 :h8), 0, 0);
		onok(f);
	};
	reader.onerror = (/*evt*/) => {
		console.log('preview: error reading ' + f.name);
		onerr();
	};
	reader.readAsArrayBuffer(f);
}
/* ImBCHtml: preview: raw preview okay */
setrawpv() {
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('preview').style['display'] = '';
	document.getElementById('rotations').style['display'] = '';
	document.getElementById('continues').style['display']='';
}
/* ImBCHtml: preview: no preview in question */
setnopv() {
	document.getElementById('preview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
}
/* ImBCHtml: browserdisplay: show the preview question skip/process */
showquestion() {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	quest.style['display'] = '';
	norm.style['display'] = 'none';
	this.setpvwait();
	document.getElementById('qhdr').innerHTML = '';
	document.getElementById('browser').style['display'] = 'none';
}
/* ImBCHtml: browserdisplay: as it says */
shownormal() {
	window.onscroll = () => undefined;
	window.onresize = () => undefined;
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	document.getElementById('browser').style['display'] = 'none';
	document.getElementById('browser').style['display'] = 'none';
	quest.style['display'] = 'none';
	norm.style['display'] = '';
	window.setTimeout(() => { this.showlastmsg(); }, 100);
}
/* ImBCHtml: preview: skip handler in the step preview */
skipthis() {
	if (document.getElementById('doforall').checked) this.stepmode = 2;
	if (this.totnum > 1) {
		this.appmsg("[" + (1 + this.actnum) + " / " + this.totnum + "] ", false);
	}
	if (document.getElementById('doforall').checked) {
		this.appmsgxl(true, 'process.skipped.remaining', this.totnum - this.actnum);
		this.stats.skipped += (this.totnum - this.actnum);
	} else {
		let rawname = ImBCBase.basename(this.allfiles[this.actnum].name ? this.allfiles[this.actnum].name : this.allfiles[this.actnum]);
		this.appmsgxl(true, 'process.skipped', rawname);
		this.stats.skipped ++;
	}
	this.shownormal();
	this.handlenext();
}
/* ImBCHtml: previewquestion: process handler in the step preview */
procthis() {
	if (document.getElementById('doforall').checked) {
		this.stepmode = 0;
		this.shownormal();
	}
	this.setpvwait();
	this.handleone(this.currentrot);
}
/* ImBCHtml: previewquestion, rotation hepler */
#rotxx(r) {
	this.setpvwait();
	let j = ImBCBase.oriecw.indexOf(this.currentrot);
	j = ((j + r) % 4);
	this.currentrot = ImBCBase.oriecw[j];
	this.buildpreview(this.allfiles[this.actnum], () => { this.setrawpv(); }, () => { this.setpverr(); }, this.currentrot);
}
/* ImBCHtml: previewquestion: handler for clockwise rotation */
rotcw() {
	this.#rotxx(1);
}
/* ImBCHtml: previewquestion: handler for counterclockwise rotation */
rotccw() {
	this.#rotxx(3);
}
/* ImBCHtml: previewquestion: handler for upside down rotation */
rot180() {
	this.#rotxx(2);
}
/* ImBCHtml: previewquestion: handler for reset rotation */
rot0() {
	if (1 === this.currentrot) return;
	this.setpvwait();
	this.currentrot = 1;
	this.buildpreview(this.allfiles[this.actnum], () => { this.setrawpv(); }, () => { this.setpverr(); }, 1);
}
/* ImBCHtml: visual browser: change cache size (currently only visible in debug _00) */
chgcache() {
	this.#maxcache = document.getElementById('dbgcache').value;
}
/* ImBCHtml: after finishing.... */
#afterfinish() {
	if (this.stats.total > 0) {
		this.appmsg('');
		this.mappx(true, 'process.totals', this.stats.total, this.stats.ok, this.stats.skipped, this.stats.error);
	}
	this.actnum = 0;
	this.allfiles = [];
	document.getElementById('imbdoit').disabled = false;
	document.getElementById('imbvisbrows').disabled = false;
	document.getElementById('droptarget').style['display'] = '';
	document.getElementById('infile').disabled = false;
	document.getElementById('infileb').disabled = false;
	if (this.zip) {
		this.zip.finish(() => {
			this.writestream.close().then(() => {
				if (!this.ziperr) {
					this.mappx(false, 'words.finished');
					this.mappx(true, 'process.copyok', this.zipname);
				} else {
					this.mappx(false, 'words.error');
					this.mappx(true, 'process.errsave', this.zipname);
				}
			}).catch((e) => {
				this.mappx(false, 'words.error');
				this.mappx(0, 'process.errsave', this.zipname);
				this.appmsg(JSON.stringify(e), true);
			});
		});
		this.zip = null;
		this.ziperr = false;
	}
}
/* ImBCHtml: continue with the next file if any */
handlenext(fromloop) {
	if (fromloop) {
		if (this.debugflag) console.log('HN fl an ' + this.actnum + ' aflen ' + this.allfiles.length);
		if (this.actnum >= this.allfiles.length - 1) {
			this.#afterfinish();
			if (this.#fromvisbrows) {
				this.#fromvisbrows = false;
				setTimeout(() => {
						this.showbrowser();
						this.#startloadimg();
				}, 1000);
			} else {
				this.shownormal();
			}
		}
		else {
			this.actnum++;
		}
		this.#loadnextimg();
		return;
	}
	if (this.actnum < this.allfiles.length - 1) {
		this.actnum++;
		this.handleonex();
	} else {
		this.#afterfinish();
		this.shownormal();
	}
}
/* ImBCHtml: check if we are directly on a back */
checkimb(type) {
	if (this.debugflag && document) {
		document.getElementById('dbgcache').value = this.#maxcache;
		document.getElementById('debugonly').style['display'] = '';
	}
	if (!window.location.href.startsWith('http://192.168.1.254')) return;
	document.getElementById('onimback').style['display'] = '';
	const xhr = new XMLHttpRequest();
	xhr.onloadend = (/*event*/) => {
		if (xhr.status === 200) {
			const sel2 = xhr.responseXML.querySelectorAll('a');
			for (const r of sel2) {
				if (r && r.href.indexOf('del=') === -1) {
					if (r.href.startsWith('http://192.168.1.254'))
						this.handle1imb(r.href);
					else
						this.handle1imb('http://192.168.1.254'+ r.href);
				}
			}
			if (type && (this.imbpics.length + this.rimbpics.length + this.imbmovies.length > 0)) {
				this.aftercheck();
			}
			else if (!type) this.checkimb(true);
		}
		else if (!type) this.checkimb(true);
	};
	xhr.onerror = (/*event*/) => {
		if (!type) this.checkimb(true);
		else if (this.imbpics.length + this.rimbpics.length + this.imbmovies.length > 0) {
			this.aftercheck();
		}
	};
	xhr.open('GET', '/IMBACK/' + (type ? 'MOVIE' : 'PHOTO'));
	xhr.responseType = 'document';
	xhr.send();
}
/* ImBCHtml: browserdisplay: initialize settings */
initsettings() {
	if (window.location.origin.startsWith('http') && window.localStorage) {
		try {
			let e = window.localStorage.getItem('imbraw2dng_json');
			if (e) {
				this.parseconfig(e);
				const copytext = document.getElementById('copytext');
				const copycheck = document.getElementById('copycheck');
				const stepprev = document.getElementById('steppreview');
				if (copycheck !== null && copytext !== null) {
					copycheck.checked = (this.copyright.length > 0);
					copytext.value = this.copyright;
					copytext.style['display'] = (this.copyright.length > 0) ? '' : 'none';
				}
				if (stepprev !== null) stepprev.checked = (this.stepmode===1);
				const dngprev = document.getElementById('dngpreview');
				if (dngprev) dngprev.checked = this.withpreview;
				document.getElementById('onlyhttp').style['display'] = 'none';
				document.getElementById('setsettings').style['display'] = 'none';
				document.getElementById('settingsset').style['display'] = '';
				document.getElementById('settingsset').setAttribute('data-myxlarg0',window.location.origin);
				document.getElementById('setsettingsurl').setAttribute('data-myxlarg0',window.location.origin);
			} else {
				document.getElementById('onlyhttp').style['display'] = 'none';
				document.getElementById('setsettings').style['display'] = '';
				document.getElementById('settingsset').style['display'] = 'none';
				document.getElementById('settingsset').setAttribute('data-myxlarg0',window.location.origin);
				document.getElementById('setsettingsurl').setAttribute('data-myxlarg0',window.location.origin);
			}
		} catch  {
			document.getElementById('onlyhttp').style['display'] = '';
			document.getElementById('setsettings').style['display'] = 'none';
			document.getElementById('settingsset').style['display'] = 'none';
			this.xlateall();
		}
	} else {
		document.getElementById('onlyhttp').style['display'] = '';
		document.getElementById('setsettings').style['display'] = 'none';
		document.getElementById('settingsset').style['display'] = 'none';
	}
	this.xlateall();
}
/* ImBCHtml: file/filereader like interface for imback http */
// url can also be an imbele member
resolver(url, onok, onerr, notfirst) {
	let rot, e = url;
	if (url.url) {
		e = url;
		url = e.url;
		rot = e.rot;
	}
	let fx = {
		imbackextension: true,
		name: url
	};
	const ii = this.#cache.findIndex((v) => (v.url === url));
	if (ii !== -1) {
		fx.data = this.#cache[ii].d;
		fx.size = this.#cache[ii].l;
		fx.readAsArrayBuffer = (fy) => {
			fy.onload({
				target: {
					result: fy.data				}
			});
		};
		window.setTimeout(() => {
			onok(url, fx, rot);
		});
		return;
	}
	let xhr = new XMLHttpRequest();
	xhr.onload = (/*evt*/) => {
		let len = JSON.parse(xhr.getResponseHeader('content-length'));
		if (0 >= len) len=1;
		if (notfirst && (url.substring(url.length -4).toUpperCase() === '.RAW') && len > 10000) {
			this.#cache.push({ url: url, d: xhr.response, l: len });
			if (this.#cache.length > this.maxcache) this.#cache.splice(0,1);
		}
		fx.data = xhr.response;
		fx.size = xhr.response.byteLength;
		fx.readAsArrayBuffer = (fy) => {
			fy.onload({
				target: {
					result: fy.data				}
			});
		};
		xhr.onerror = undefined;
		xhr.ontimeout = undefined;
		xhr.onabort = undefined;
		if (notfirst) {
			window.setTimeout(() => {
					onok(url, fx, rot);
			});
		} else this.resolver(e, onok, onerr, len);
	};
	xhr.onerror = (evt, typ) => {
		if (undefined === typ) typ = 'err';
		console.log('XHR err (createfx, ' + typ + ') for ' + url + ' readyState:' + xhr.readyState + ' http status:' + xhr.status + ' text: ' + xhr.statusText);
		xhr.onerror = undefined;
		xhr.onload = undefined;
		xhr.ontimeout = undefined;
		xhr.onabort = undefined;
		window.setTimeout(() => {
				onerr(url, fx, rot);
		});
	};
	xhr.onabort = (evt) => { xhr.onerror(evt, 'abort'); };
	xhr.ontimeout = (evt) => { xhr.onerror(evt, 'timeout'); };
	xhr.open(notfirst ? 'GET' : 'HEAD', url);
	xhr.setRequestHeader('Cache-control','max-stale');
	xhr.responseType = 'arraybuffer';
	xhr.timeout = (!notfirst || notfirst < 10000000) ? 30000 : Math.round(notfirst / 600);
	try {
		xhr.send();
	} catch (e) {
		console.log('XHR send exception (createfx) for ' + url + ' ' + e.toString());
		xhr.onerror = undefined;
		xhr.onload = undefined;
		xhr.ontimeout = undefined;
		xhr.onabort = undefined;
		window.setTimeout(() => {
				onerr(url, fx, rot);
		});
	}
}
/* Indentation in - end of class ImBCHtml */
}
/* *************************************** Main class for HTML, forward E N D *************************************** */
/* *************************************** Main class for HTML, backward *************************************** */
class ImBCHtmlBackw extends ImBCHtmlOut {
/* Indentation out */
constructor() {
	super();
	this.imbcb = new ImBCBackw(this);
}
/* ImBCHtmlBackw: browserdisplay: handler for file selection input */
fselected() {
	if (this.actnum !== this.allfiles.length) return;
	const el = document.getElementById('infileb');
	this.totnum = el.files.length;
	this.actnum = 0;
	this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
	this.allfiles = el.files;
	if (this.totnum > 0) {
		this.appmsgxl(true, 'process.selectedn', this.totnum);
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infileb').disabled = true;
		this.handleonex();
	}
}
/* ImBCHtmlBackw: browserdisplay: handler function for dropping OS files into the rect */
drophandler(ev) {
	if (this.actnum !== this.allfiles.length) return;
    this.stepmode = 0;
	ev.preventDefault();
	this.allfiles = [];
	this.actnum = 0;
	if (ev.dataTransfer.items) {
		this.totnum = [...ev.dataTransfer.items].length;
		[...ev.dataTransfer.items].forEach((item/*, i*/) => {
			if (item.kind === "file") {
				this.allfiles.push(item.getAsFile());
			}
		});
	} else {
		this.totnum = [...ev.dataTransfer.files].length;
		[...ev.dataTransfer.files].forEach((file/*, i*/) => {
			this.allfiles.push(file);
		});
	}
	this.stats = { total: this.totnum, skipped: 0, error: 0, ok: 0 };
	this.mappx(true, 'process.droppedn', this.totnum);
	document.getElementById('imbdoit').disabled = true;
	document.getElementById('imbvisbrows').disabled = true;
	document.getElementById('droptarget').style['display'] = 'none';
	document.getElementById('infileb').disabled = true;
	this.handleonex();
}
/* ImBCHtmlBackw: browserdisplay: some handler on the drop rectangle */
prevdef(ev) {
	ev.preventDefault();
}
/* ImBCHtmlBackw: continue with the next file if any */
handlenext(/*fromloop*/) {
	if (this.actnum < this.allfiles.length - 1) {
		this.actnum++;
		this.handleonex();
	} else {
		this.actnum = 0;
		this.allfiles = [];
		if (!this.imbcb) this.shownormal();
		if (this.stats.total > 0) {
			this.appmsg('');
			this.mappx(true, 'process.totals', this.stats.total, this.stats.ok, this.stats.skipped, this.stats.error);
		}
		document.getElementById('imbdoit').disabled = false;
		document.getElementById('imbvisbrows').disabled = false;
		document.getElementById('droptarget').style['display'] = '';
		document.getElementById('infile').disabled = false;
		document.getElementById('infileb').disabled = false;
	}
}
/* Indentation in - end of class ImBCHtmlBackw */
}
/* *************************************** Main class for HTML, backward E N D *************************************** */
/* *************************************** ZIP Helper class *************************************** */
class ZIPHelp {
/* Indentation out */
#lochdrs = [];
#loclens = [];
#datalens = [];
#writecb = null;
#finishoff = 0;
#sizecent = 0;
static crcTable = [];
/* ZIPHelp: constructor */
constructor(writecb) {
	this.#writecb = writecb;
}
/* ZIPHelp: make dos date */
static makeDosDate(yr, mon, day, hr, min, sec)
{
    if (yr>1980)
        yr-=1980;
    else if (yr>80)
        yr-=80;
    return (((day + (32 * mon) + (512 * yr)) * 65536) |
		((sec/2) + (32* min) + (2048 * hr)));
}
/* ZIPHelp: dos date from filename */
static datefromfile(name) {
	let { yr, mon, day, hr, min, sec } = ImBCBase.nametotime(name);
	if (yr) {
		return ZIPHelp.makeDosDate(yr, mon, day, hr, min, sec);
	} else {
		let r = ImBCBase.nametotime(new Date(Date.now()).toISOString());
		return ZIPHelp.makeDosDate(r.yr, r.mon, r.day, r.hr, r.min, r.sec);
	}
}
/* ZIPHelp: crc32 stuff */
static makeCRCTable(){
    var c;
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        ZIPHelp.crcTable[n] = c;
    }
}

static crc32(arr) {
	if (ZIPHelp.crcTable.length === 0) ZIPHelp.makeCRCTable();
    var crc = 0 ^ (-1);

    for (var i = 0; i < arr.length; i++ ) {
        crc = (crc >>> 8) ^ ZIPHelp.crcTable[(crc ^ arr[i]) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};
/* ZIPHelp: finish zip with centraldirs and endcentral */
finish(cb, i) {
	if (i === undefined) i=0;
	if (i < this.#lochdrs.length) {
		let j = this.#lochdrs[i];
		let ch = new Uint8Array(46);
		ch[0] = 0x50; // P
		ch[1] = 0x4B; // K
		ch[2] = 0x1; // magic
		ch[3] = 0x2;
		ch[4] = 0x0; // version made
		ch[5] = 0x0;
		ch[6] = 0x14; // version extract
		ch[7] = 0x0;
		ch[8] = 0x0; // gp bitflags
		ch[9] = 0x8;
		ch[10] = 0x0; // compr
		ch[11] = 0x0;
		let dosdate = j.dosdate;
		ch[12] = dosdate % 256;
		ch[13] = Math.floor(dosdate/256) % 256;
		ch[14] = Math.floor(dosdate/65536) % 256;
		ch[15] = Math.floor(dosdate/(256*65536)) % 256;
		let crc = j.crc;
		ch[16] = crc % 256;
		ch[17] = Math.floor(crc/256) % 256;
		ch[18] = Math.floor(crc/65536) % 256;
		ch[19] = Math.floor(crc/(256*65536)) % 256;
		let dl = j.dl; // compr. length
		ch[20] = dl % 256;
		ch[21] = Math.floor(dl/256) % 256;
		ch[22] = Math.floor(dl/65536) % 256;
		ch[23] = Math.floor(dl/(256*65536)) % 256;
		// uncompr. size is same
		ch[24] = dl % 256;
		ch[25] = Math.floor(dl/256) % 256;
		ch[26] = Math.floor(dl/65536) % 256;
		ch[27] = Math.floor(dl/(256*65536)) % 256;
		let fl = j.fl; // name length
		ch[28] = fl % 256;
		ch[29] = Math.floor(fl/256) % 256;
		ch[30] = 0; // extra length
		ch[31] = 0;
		ch[32] = 0x0; // comment length
		ch[33] = 0x0;
		ch[34] = 0x0; // disk no
		ch[35] = 0x0;
		ch[36] = 0x0; // int attr
		ch[37] = 0x0;
		ch[38] = 0x0; // ext attr
		ch[39] = 0x0;
		ch[40] = 0x0;
		ch[41] = 0x0;
		ch[42] = this.#finishoff % 256;
		ch[43] = Math.floor(this.#finishoff/256) % 256;
		ch[44] = Math.floor(this.#finishoff/65536) % 256;
		ch[45] = Math.floor(this.#finishoff/(256*65536)) % 256;
		this.#sizecent += (46 + j.fl);
		this.#finishoff += this.#loclens[i];
		this.#writecb(ch, () => {
			this.#writecb(j.name, () => { this.finish(cb, i+1); });
		});
		return;
	}
	// end of central
	let ec = new Uint8Array(22);
	ec[0] = 0x50; // P
	ec[1] = 0x4B; // K
	ec[2] = 0x5; // magic
	ec[3] = 0x6;
	ec[4] = 0x0; // disk no
	ec[5] = 0x0;
	ec[6] = 0x0; // startdisk
	ec[7] = 0x0;
	ec[8] = i % 256; // num entries
	ec[9] = Math.floor(i/256) % 256;
	ec[10] = i % 256; // num entries
	ec[11] = Math.floor(i/256) % 256;
	ec[12] = this.#sizecent % 256; // size of cent.dir
	ec[13] = Math.floor(this.#sizecent/256) % 256;
	ec[14] = Math.floor(this.#sizecent/65536) % 256;
	ec[15] = Math.floor(this.#sizecent/(65536*256)) % 256;
	ec[16] = this.#finishoff % 256; // start of cent.dir
	ec[17] = Math.floor(this.#finishoff/256) % 256;
	ec[18] = Math.floor(this.#finishoff/65536) % 256;
	ec[19] = Math.floor(this.#finishoff/(65536*256)) % 256;
	ec[20] = 0; // comment length
	ec[21] = 0;
	this.#writecb(ec, () => { cb(); });
}
/* ZIPHelp: add a file */
add(data, name, cb) {
	let narr = new TextEncoder().encode(name);
	// output local header
	let lh = new Uint8Array(30);
	lh[0] = 0x50; // P
	lh[1] = 0x4B; // K
	lh[2] = 0x3; // magic
	lh[3] = 0x4;
	lh[4] = 0x14; // version 20
	lh[5] = 0x0;
	lh[6] = 0x0; // gp bitflags
	lh[7] = 0x8;
	lh[8] = 0x0; // compression
	lh[9] = 0x0;
	let dosdate = ZIPHelp.datefromfile(name);
	lh[10] = dosdate % 256;
	lh[11] = Math.floor(dosdate/256) % 256;
	lh[12] = Math.floor(dosdate/65536) % 256;
	lh[13] = Math.floor(dosdate/(256*65536)) % 256;
	let crc = ZIPHelp.crc32(data);
	lh[14] = crc % 256;
	lh[15] = Math.floor(crc/256) % 256;
	lh[16] = Math.floor(crc/65536) % 256;
	lh[17] = Math.floor(crc/(256*65536)) % 256;
	let dl = data.length;
	lh[18] = dl % 256; // compr. length
	lh[19] = Math.floor(dl/256) % 256;
	lh[20] = Math.floor(dl/65536) % 256;
	lh[21] = Math.floor(dl/(256*65536)) % 256;
	// uncompr. size is same
	lh[22] = dl % 256;
	lh[23] = Math.floor(dl/256) % 256;
	lh[24] = Math.floor(dl/65536) % 256;
	lh[25] = Math.floor(dl/(256*65536)) % 256;
	let fl = narr.length;
	lh[26] = fl % 256;
	lh[27] = Math.floor(fl/256) % 256;
	lh[28] = 0; // extra length
	lh[29] = 0;
	this.#lochdrs.push( { name: narr, dosdate: dosdate, crc: crc, dl: dl, fl: fl } );
	this.#loclens.push( 30+fl+dl );
	this.#writecb(lh, () => {
		this.#writecb(name, () => {
			this.#writecb(data, () => { cb(); });
		})
	});
/* Indentation in - end of class ZIPHelp */
}
/* *************************************** ZIP Helper class E N D *************************************** */
}
/* outside of classes: */
let imbc;
/* onload of html body */
function init() {
	let backw = false;
	if (ImBCBase.basename(window.location.pathname.toUpperCase()).indexOf('IMBDNG2RAW') !== -1) {
		backw = true;
		imbc = new ImBCHtmlBackw();
		for (const o of document.getElementsByClassName('onlywhenbackw')) o.style['display']='';
		for (const o of document.getElementsByClassName('notwhenbackw')) o.style['display']='none';
	}
	else {
		imbc = new ImBCHtml();
		imbc.chgcopycheck();
		imbc.initsettings();
		if (!window.showSaveFilePicker) {
			document.getElementById('usezip').disabled = true;
			//document.getElementById('useziplbl').style['display'] = 'none';
		}
	}
	imbc.querylang(window.location.pathname);
	imbc.xlateall();
	if (!backw) imbc.checkimb();
}
</script>
</head>
<!-- here comes the html itself -->
<body style="font-family: Helvetica, Arial, sans-serif;" onload="init();" lang="en">
<div style="font-weight:bold;"><span class="notwhenbackw" data-myxlkey='main.title'> </span><span class="onlywhenbackw" style="display:none;" data-myxlkey='main.backw.title'> </span> <span id="mainversion"> </span> - 
 <a target="_new" data-myhrefxlkey="main.helplink" data-myxlkey='main.help'></a>
<select id="langsel" onchange="imbc.setlang()" value="en"><option value="de" onclick="imbc.setlang()">DE</option><option value="en" selected onclick="imbc.setlang()">EN</option>
<option value="ja" onclick="imbc.setlang()">JA</option><option value="fr" onclick="imbc.setlang()">FR</option><!--option value="ru" onclick="imbc.setlang()">RU</option--></select> <span class="notwhenbackw"> New! Internal Overwork, please report errors to me... &amp; <a href="imbraw2dng_ja.html">Japanese translation</a> thanks to Sadami Inoue!</span></div>
<br><div class="notwhenbackw"><span data-myxlkey="main.coloursyourrisk"> </span>&nbsp;<!--b style="background-color:#888888; text-shadow: 0.07em 0.12em 0 #FFFFFF;font-size:200%;">&#x26f6; &#x1f5d1; &#x2715;</b-->&nbsp;<br></div>
<!-- the normal display -->
<div id="normal" style="margin-top: 0.5em;">
<div><input class="notwhenbackw" type="checkbox" id="steppreview" onchange="imbc.dirtysettings()" checked><label class="notwhenbackw" for="steppreview" data-myxlkey="process.singlestep"></label></div>
<div><input class="notwhenbackw" type="checkbox" id="dngpreview" checked onchange="imbc.chgdngpreview()"><label class="notwhenbackw" for="dngpreview" data-myxlkey="process.addpreview"></label></div>
<div><input class="notwhenbackw" type="checkbox" id="copycheck" onchange="imbc.chgcopycheck()"><label class="notwhenbackw" for="copycheck" data-myxlkey="process.addcopyright"></label> <input class="notwhenbackw" onchange="imbc.dirtysettings()" type="text" id="copytext"></input></div>
<div><input class="notwhenbackw" type="checkbox" id="usezip" onchange="imbc.dirtysettings()"><label class="notwhenbackw" for="usezip" data-myxlkey="main.usezip" id="useziplbl"></label></div>
<div class="notwhenbackw" style="margin-top: 0.5em;">
<span id="onlyhttp" data-myxlkey="browser.prefnotfile"></span>
<span id="settingsset" data-myxlkey="browser.settingsset"></span>
<span id="setsettings"><input type="button" data-myvalxlkey="browser.setfrom" onclick="imbc.savesettings()"></input>&#xa0;<span id="setsettingsurl" data-myxlkey="browser.forurl"></span></span>
<!-- here goes the save preferences .. -->
</div>
<div class="notwhenbackw" style="margin-top: 0.5em;" data-myxlkey="main.generaladvice"></div>
<div class="onlywhenbackw" style="margin-top: 0.5em;display:none;" data-myxlkey="main.backw.generaladvice"></div>
<!-- connected ! -->
<div id="onimback" style="background-color:#ffffbb;border: 5px solid #ffff88;border-radius: 10px;width:fit-content;padding:1em;display:none;"><div style="font-size:133%;" data-myxlkey="onimback.connected">&nbsp;<br></div>
<span data-myxlkey="onimback.dlconvert"></span><br>
<input checked type="checkbox" id="rpicfromimb"><label for="rpicfromimb" id="rpiclbl" data-myxlkey="main.types.rawpics"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="rpiccnt" data-myxlkey="main.stillcounting"></span> <span id="rpicinterval" style="display:none;"></span>
<br><input checked type="checkbox" id="picfromimb"><label for="picfromimb" id="piclbl" data-myxlkey="main.types.jpgpics"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="piccnt" data-myxlkey="main.stillcounting"></span> <span id="picinterval" style="display:none;"></span> 
<br><input checked type="checkbox" id="movfromimb"><label for="movfromimb" id="movlbl" data-myxlkey="main.types.other"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="movcnt" data-myxlkey="main.stillcounting"></span> <span id="movinterval" style="display:none;"></span><br>
<span data-myxlkey="onimback.fromtime"></span> <input type="text" maxlength="19" id="imbstartts" inlength="0" placeholder="YYYY_MM_DD-hh_mm_ss" pattern="[0-9][0-9][0-9][0-9](_[0-9][0-9](_[0-9][0-9]-([0-9][0-9](_[0-9]([0-9](_[0-9][0-9])*)*)*)*)*)*"> (<span data-myxlkey="onimback.nullforall"></span>) <br>
<input onclick="imbc.imbdoit()" type="button" data-myvalxlkey="onimback.doit" id="imbdoit" disabled><br>
<span data-myxlkey="main.or"></span> <input type="button" data-myvalxlkey="onimback.visual" id="imbvisbrows" onclick="imbc.showbrowser()" disabled>.
</div>
<!-- end of connected -->
<div id="notimback">
<div class="notwhenbackw" style="font-size:133%;margin-top: 0.5em;" data-myxlkey="main.drophere"></div>
<div class="onlywhenbackw" style="font-size:133%;margin-top: 0.5em;display:none;" data-myxlkey="main.backw.drophere"></div>
<div id="droptarget" ondrop="imbc.drophandler(event);" ondragenter="imbc.prevdef(event);" ondragover="imbc.prevdef(event);" style="border: 5px solid blue;border-radius: 10px;width:300px; height:70px;background-color: rgba(0,0,255,0.2);"></div><br>
<div class="notwhenbackw" style="font-size:75%; background-color:rgba(0,0,255,0.1);width:fit-content;margin-top:-0.7em;color:#808080;">
<input type="checkbox" id="fakelongexpadd"> <label for="fakelongexpadd" data-myxlkey="main.fakelong"> </label> - 
<input type="checkbox" id="fakelongexpscale"> <label for="fakelongexpscale" data-myxlkey="main.fakelong.scale"> </label>
</div>
<div  style="font-size:133%;margin-top: 0.5em;"><span class="notwhenbackw" data-myxlkey="main.selectraw"></span><span class="onlywhenbackw" data-myxlkey="main.backw.selectdng" style="display:none;"></span> 
<input class="notwhenbackw" type="file" accept=".raw,.RAW" id="infile" name="infile" multiple onchange="imbc.fselected()">
<input class="onlywhenbackw" style="display:none;" type="file" accept=".dng,.DNG" id="infileb" name="infileb" multiple onchange="imbc.fselected()">
</div><br>
</div>
&nbsp;<br>
<div id="xmsg" style="display: none; width: fit-content;white-space: pre;"><span style="font-weight:bold;" data-myxlkey="main.log"></span><br>
<div id="outmsg"></div></div>
</div>
<!-- end of the normal display -->
<!-- normal preview with question -->
<div id="question" style="display:none;background-color:#ddffaa;border: 5px solid #33ff33; border-radius: 10px;width: fit-content;padding:2em;">
<div style="font-weight:bold;" id="qhdr">&nbsp;</div>
<canvas id="preview"></canvas><img style="display:none;max-width:550px; max-height:550px;" id="jpegpreview" onload="imbc.setjpegpv()" onerror="imbc.setpverr()"><div id="previewerr" data-myxlkey="preview.err"></div><div id="previewwait">
<span class="blink">.</span><span class="blink2">.</span><span class="blink3">.</span></div><br>
<div id="rotations"><input type="button" id="procthiscw" data-myvalxlkey="preview.rotcw" onclick="imbc.rotcw()" style="padding:0.5em; margin:0.5em;margin-left:2.5em;">
<input type="button" id="procthisccw" data-myvalxlkey="preview.rotccw" onclick="imbc.rotccw()" style="padding:0.5em; margin:0.5em;">
<input type="button" id="procthisud" data-myvalxlkey="preview.rot180" onclick="imbc.rot180()" style="padding:0.5em; margin:0.5em;" >
<input type="button" id="procthisrs"data-myvalxlkey="preview.rotreset" data-mytitlexlkey="preview.rotreset.tooltip" value="Reset" onclick="imbc.rot0()" style="padding:0.5em; margin:0.5em;"></div>
<div id="continues"><input type="button" id="procthis" data-myvalxlkey="preview.process" onclick="imbc.procthis()" style="padding:0.5em; margin:0.5em;">
<input type="button" id="skipthis" data-myvalxlkey="preview.skip" value="Skip" onclick="imbc.skipthis()" style="padding:0.5em; margin:0.5em;">&nbsp;
<span id="forrest"><input type="checkbox" id="doforall" style="padding-left:0.5em; margin-left:0.5em;"><label for="doforall" data-myxlkey="preview.forall"></label></span></div>
</div>
<!-- end of normal preview with question -->
<!-- this is the picture browser, generated content appended -->
<div id="browser" style="background-color:#ffccbb;border: 5px solid #ff8833; border-radius: 10px;width: 90%;padding-left:2em;padding-right:2em;padding-top:1em; padding-bottom:1em;display:none;flex-direction:column;">
<span id="browserx" style="position: fixed; right:9%;"><input type="button" value="&#x2715" style="font-weight: bold; font-size: 110%; border: 0.2px solid red; background-color: rgba(230,230,230,0.7);" onclick="imbc.shownormal()"></span>
<div style="margin-bottom:1em;"><span data-myxlkey="main.sort"></span>: <label for="sbytype"><input type="checkbox" id="sbytype" onclick="imbc.buildtree()"><span data-myxlkey="browser.bytype"></span></label> - <label for="solder">
<input type="checkbox" id="solder" onclick="imbc.buildtree()"><span data-myxlkey="browser.olderfirst"></span></label>
 - <span data-myxlkey="main.selected"></span>: <span id="brnsel" class="selnumber">?</span> / <span id="brntot">?</span> - <label for="selall" data-mytitlexlkey="browser.selall.tooltip">
 <input onclick="imbc.topreccheck()" type="checkbox" id="selall"><span data-myxlkey="browser.selall"></span></label> - <input type="button" data-myvalxlkey="browser.procall" onclick="imbc.browserprocess()" id="doselbut"> - 
 <input type="button" data-myvalxlkey="browser.delall" onclick="imbc.browserdelete()" id="delselbut" disabled></div> 
</div>
<!-- end of the picture browser, generated content appended -->
<!-- this is the delete question/progress -->
<div id="delq" style="border: 5px solid red; border-radius: 20px; padding: 20px;display:none;width:fit-content;">
<span id="del_text" data-myxlarg0="0" data-myxlkey="del.question"></span><br>
<input id="delcancelbut" type="button" data-myvalxlkey="del.question.cancel" onclick="imbc.delcancel()"> - <input id="delokbut" type="button" data-myvalxlkey="del.question.ok" onclick="imbc.dodelete()"><br>
<span data-myxlkey="del.nostatus"></span><br>
<div id="delprogmsg"></div>
</div>
<!-- end of the delete question/progress -->
<!-- debug -->
<div id="debugonly" style="display:none;">
Visual Browser Cache Size: <input type="number" onchange="imbc.chgcache()" id="dbgcache" style="width: 5em;"><br>
Debugging: <input type="file" onchange="imbc.dodebug()" accept=".html,.htm" id="dbgfsel">
Replaceraw: <input type="file" onchange="imbc.replraw()" accept=".raw,.RAW" id="dbgreplraw">
</div>
<!-- this is invisible -->
<a style="display: none;" id="result">x</a>
<!-- templates -->
<template id="onepict">
	<div class="onepic">
		<div class="labelholder">
			<label class="pictitle">
				<input type="checkbox" class="selcb">
			</label>
		</div>
		<div class="errimg" style="display:none;">X</div>
		<img class="eejpg" style="display:none; height: 120px;">
		<div class="eepvx">?</div>
		<canvas class="eeraw" style="height: 120px; display:none;"></canvas>
		<div class="waitdiv">
			<span class="blink">.</span><span class="blink2">.</span><span class="blink3">.</span>
		</div>
		<div class="btnsrow">
			<span class="biggiebtn bigbtn" style="left: 0.4em; margin-top: -0.5em;">â›¶</span>
			<span class="dlbtn biggiebtn" style="font-size: 133%;">â†“</span>
			<span class="biggiebtn rotbtn" style="left: 2.4em;">â†·</span>
		</div>
	</div>
</template>
<template id="titlet">
	<div class="ggtt ggttclosed titletop">
		<span class="ggttplus ggttp">[+]</span><span class="ggttplus ggttpp"></span><span class="ggttminus ggttm">[â€’]</span><span class="ggttminus ggttmm"> </span>
		<span class="gtype" style="display: none;"></span><span class="grtit"></span> - 
		<span data-myxlkey="main.selected"></span>: 
		<span class="selnumber">0</span> / <span class="totno"></span> - 
		<label>
			<input type="checkbox" class="selcb">
			<span data-myxlkey="browser.selall" data-mytitlexlkey="browser.selall.tooltip"></span>
		</label>
	</div>
</template>
</body>
</html>
