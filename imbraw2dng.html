<html>
<head>
<style type="text/css">
"use strict;"
.blink {
  animation: blinker 1s linear infinite;
}
.blink2 {
  animation: blinker 1s linear infinite;
  animation-delay: 0.33s;
}
.blink3 {
  animation: blinker 1s linear infinite;
  animation-delay: 0.66s;
}
.blink, .blink2, .blink3 {
	font-size: 200%;
	font-weight: bold;
	line-height: 5px;
	height: 100px;
	display: inline-block;
	z-index: 10;
}

@keyframes blinker {
  50% {
    opacity: 0;
  }
}
.gg {
	display: block;
}
.gg .grtit { font-weight: bold; font-size: 125%; }
.gg:not(.gl1) {
	margin-left: 1em;
}
.ggtt {
	border: 2px solid white;
	border-radius: 5px;
	margin:0.2em;
}
.gl1 > .ggtt span.gtype { display: inline !important; }
.ggttopen > .ggttplus { display: none; }
.ggttclosed > .ggttminus { display: none; }
.ggttclosed > div > .ggtt { display: none; }
.ggclosed > .gg, .ggclosed .igtype { display: none !important; }
.ggttminus, .ggttplus { cursor: pointer; display: inline-block; width: 1.9em; font-weight:normal !important; }
.rotbtn:not(.disabled), .dlbtn:not(.disabled) { cursor: pointer; }
.dlbtn { vertical-align: bottom; font-size: 150%; font-weight: bold; }
.igtype { border: 2px solid yellow; border-radius: 5px; display: flex; flex-flow: wrap; }
.ee { border: 2px solid gray; border-radius: 5px; margin: 2px; width: fit-content; display: flex; flex-direction: column; padding: 0.3em;}
.eepvx { color: #777777; font-size: 100px; align-self: center; font-weight: bold; }
.errimg { color: red; font-size: 100px; align-self: center; font-weight: bold; }
.eepvw { color: #444444; font-size: 100px; align-self: center; font-weight: bold; }
.eeraw, .eeimg { align-self: center; }
.ee > :nth-child(1) { margin-top: -0.5em; }
#previewwait {
	scale: 500%;
	margin-left: 250px;
	margin-top: 200px;
	line-height: 5px;
	height: 50px;
}
.selnumber {
	display: inline-block;
	width: 2em;
	text-align: end;
}
.biggie { scale: 3; position: absolute; }
.etit { z-index: 90; }
.picdeleted:before {
	content: '&#x1f6c7;';
	position: absolute;
	font-size: 50px;
	left: 1em;
	color: rgba(255,0,0,0.6);
	text-shadow: 6px 4px white;
}
.picprocd:before {
	content: '&#x2713;';
	position: absolute;
	font-size: 50px;
	left: 1em;
	color: rgba(0,255,0,0.6);
	text-shadow: 6px 4px white;
}
</style>
<script type="text/javascript" language="javascript">
function ImBC() {
/* Indentation out */
this.alllangs = [ 'de' , 'en', '00' ]; // actually const
this.texts = { // actually const
	main: {
		title: {
			de: 'ImB RAW nach DNG Konverter',
			en: 'ImB RAW to DNG converter',
		},
		file: {
			de: 'Datei',
			en: 'File',
		},
		help: {
			de: '? Hilfe Doku',
			en: '? Help Doc',
		},
		helplink: {
			de: 'https://shyrodgau.github.io/imbraw2dng/README_de',
			en: 'https://shyrodgau.github.io/imbraw2dng/',
		},
		generaladvice: {
			de: 'Kann sein, dass der Browser fragt, ob Sie zulassen wollen, dass mehrere Dateien heruntergeladen werden.<br>Dateien, die nicht oder unbekannte RAW-Dateien sind, werden 1:1 kopiert.',
			en: 'Browser may ask you if you want to allow downloading multiple files.<br>Not or unrecognized RAW Files simply will be copied.',
		},
		drophere: {
			de: 'Datein von ImB hier ablegen: ',
			en: 'Drop Files from ImB here: ',
		},
		selectraw: {
			de: 'Oder diese Datei per WLAN von ImB direkt verwenden<br>Oder <b>.raw</b> Datei(en) auswählen:',
			en: 'Or use this file via Wifi directly from ImB.<br> Or select <b>.raw</b> File(s):',
		},
		stillcounting: {
			de: '... zähle ... ',
			en: '... counting ... ',
		},
		types: {
			rawpics: {
				de: 'RAW Bilder',
				en: 'RAW Pictures',
			},
			jpgpics: {
				de: 'JPEG-Bilder',
				en: 'JPEG Pictures',
			},
			other: {
				de: 'Andere',
				en: 'Other',
			},
			notpic: {
				de: 'Keine Bilder',
				en: 'Not pictures',
			}
		},
		file: {
			jpeg: {
				de: 'Datei $$0 (JPEG)',
				en: 'File $$0 (JPEG)',
			},
			nopreview: {
				de: 'Datei $$0<br>Nicht jpeg oder raw, keine Vorschau...',
				en: 'File $$0<br>Not jpeg or raw, no preview...',
			},
			rawunknown: {
				de: 'Datei $$0<br>Unerkannte RAW Dateigröße $$1, bitte Entwickler kontaktieren! Keine Vorschau...',
				en: 'File $$0<br>Unknown raw size $$1, please contact developer! No preview...'
			},
			de: 'Datei $$0',
			en: 'File $$0',
		},
		sort: {
			de: 'Sortiere',
			en: 'Sort:'
		},
		or: {
			de: 'Oder ',
			en: 'Or '
		},
		reload: {
			de: 'Seite ab und zu neu laden, um Speicher freizugeben.',
			en: 'Reload page from time to time to free memory.'
		},
		log: {
			de: 'Protokoll-Ausgabe:',
			en: 'Message Log:'
		},
		selected: {
			de: 'Ausgewählt',
			en: 'Selected'
		}
	},
	browser: {
		bytype: {
			de: 'nach Typ',
			en: 'by type'
		},
		olderfirst: {
			de: 'Ältere nach oben',
			en: 'Older first'
		},
		selall: {
			tooltip: {
				de: 'Wenn Haken nicht gesetzt, wähle alles aus. Bei Klick wenn angehakt setze Auswahl auf Nichts.',
				en: 'If not selected then select all. If it is selected and clicked then unselect all.'
			},
			de: 'Alle de-/ oder selektieren',
			en: 'De-/select all'
		},
		procall: {
			de: 'Alle ausgewählte kopieren/verarbeiten',
			en: 'Copy/process all selected'
		},
		delall: {
			de: 'Alle ausgewählte löschen',
			en: 'Delete all selected'
		}
	},
	onimback: {
		connected: {
			de: 'ImB Verbunden!! <br>',
			en: 'ImB Connected! <br>'
		},
		dlconvert: {
			de: 'Konvertiere / Lade herunter: ',
			en: 'Download / convert: '
		},
		totalnum: {
			de: 'gesamt:',
			en: 'total:'
		},
		fromtime: {
			de: 'ab Zeitstempel bzw. jünger als ',
			en: 'from timestamp or younger than '
		},
		nullforall: {
			de: '0000 oder leer für "alle"',
			en: '0000 or empty for "all"'
		},
		doit: {
			de: 'Mach es',
			en: 'Do it'
		},
		visual: {
			de: 'Bild-Browser benutzen',
			en: 'Use visual Picture Browser'
		}
	},
	process: {
		singlestep: {
			de: 'Einzelschritt mit Vorschau',
			en: 'Single Step with preview'
		},
		addlink: {
			de: 'Extra Download-Link an jeder Datei',
			en: 'Add separate download link for each file'
		},
		maycostmem: {
			de: 'Dies könnte Speicher kosten und wird daher von Hause aus nicht mehr angeboten. Man kann einfach nochmal die gleiche(n) Datei(en) auswählen.',
			en: 'This may cost memory and is thus no longer by default. Simply select the file(s) again.'
		},
		nothing: {
			de: 'Nichts ausgewählt.. ?',
			en: 'Nothing selected...?'
		},
		erraccess: {
			de: '<b>Fehler beim Zugriff auf $$0. ENTSCHLDIGUNG! </b>',
			en: '<b>Error occured accessing $$0. SORRY! </b>'
		},
		notraw: {
			de: 'Durchleitung weil nicht raw: $$0<br>',
			en: 'Passing through as not raw: $$0<br>'
		},
		selectedn: {
			de: '$$0 Datei(en) wurden ausgewählt.<br>&nbsp;<br>',
			en: 'Got $$0 file(s) selected.<br>&nbsp;<br>'
		},
		copyok: {
			de: '<b style="background-color:#ddffdd;">Fertig! Nach $$0 kopiert (Downloads-Ordner prüfen)</b>&nbsp;',
			en: '<b style="background-color:#ddffdd;">Finished! Copied to $$0 (Check Downloads Folder)</b>&nbsp;'
		},
		dlagain: {
			de: '<a download="$$0\" href=\"$$1">Nochmal händisch herunterladen</a>',
			en: '<a download="$$0\" href=\"$$1">Manually download again</a>'
		},
		dlagaindng: {
			de: '<a type="image/x-adobe-dng" download="$$0dng" href="$$1">Nochmal händisch herunterladen</a>&nbsp;',
			en: '<a type="image/x-adobe-dng" download="$$0dng" href="$$1">Manually download again</a>&nbsp;'
		},
		errorreadingfile: {
			de: '<b style="background-color:#ffdddd;">Fehler beim Lesen der Datei $$0. ENTSCHULDIGUNG! </b><br>&nbsp;<br>',
			en: '<b style="background-color:#ffdddd;">Error occured reading file $$0. SORRY! </b><br>&nbsp;<br>'
		},
		unknownsize: {
			de: '<b style="background-color:#ffdddd;">[$$0] Entschuldigung, die Dateigröße <b>$$1</b> passt zu keinem bekannten Format. Bitte Entwickler kontaktieren!</b><br>',
			en: '<b style="background-color:#ffdddd;">[$$0] Sorry, file Size <b>$$1</b> does not match known formats. Please contact developer!</b><br>'
		},
		processing: {
			de: 'Verarbeite Datei: $$0 <br>',
			en:'Processing file: $$0<br>'
		},
		assuming: {
			de: 'Annahme: $$0 $$1<br>',
			en: 'Assuming $$0 $$1<br>'
		},
		datetime: {
			de: 'Datum/Zeit: $$0<br>',
			en: 'Date/Time: $$0 <br>'
		},
		orientation: {
			de: 'Drehung: ',
			en: 'Orientation: '
		},
		converted: {
			de: '<b style=\"background-color:#ddffdd;\">Fertig! Nach $$0dng konvertiert (Downloads-Ordner prüfen)</b>&nbsp;',
			en: '<b style=\"background-color:#ddffdd;\">Finished! Converted to $$0dng (Check Downloads Folder)</b>&nbsp;'
		},
		droppedn: {
			de: '$$0 Datei(en) wurden abgelegt.',
			en: 'Got $$0 file(s) dropped.'
		},
		frombackn: {
			de: '$$0 Datei(en) vom ImB zu verarbeiten.<br>&nbsp;<br>',
			en: 'Got $$0 file(s) from ImB.<br>&nbsp;<br>'
		},
		frombrowsern: {
			de: '$$0 Datei(en) vom Bild-Browser zu verarbeiten.<br>&nbsp;<br>',
			en: 'Got $$0 file(s) from Visual browser.<br>&nbsp;<br>'
		},
		skipped: {
			remaining: {
				de: 'Verbleibende $$0 Dateien auf Anforderung übersprungen',
				en: 'Skipping remaining $$0 images at your request'
			},
			de: 'Auf Anforderung übersprungen: $$0',
			en: 'Skipped at your request: $$0'
		}
	},
	preview: {
		err: {
			de: 'Fehler bei Vorschau :-(',
			en: 'Error with Preview :-('
		},
		rotcw: {
			de: 'im Uhrzeigersinn drehen',
			en: 'Rotate clockwise',
			tooltip: {
				de: 'Originalbild um 90° im Uhrzeigersinn drehen',
				en: 'Rotate original image by 90&deg; clockwise'
			}
		},
		rotccw: {
			de: 'gegen den Uhrzeigersinn drehen',
			en: 'rotate counterclockwise',
			tooltip: {
				de: 'Originalbild um 90° gegen den Uhrzeigersinn drehen',
				en: 'Rotate original image by 90&deg; counterlockwise'
			}
		},
		rot180: {
			de: 'auf den Kopf',
			en: 'Rotate 180&deg;',
			tooltip: {
				de: 'Originalbild auf den Kopf stellen',
				en: 'Rotate original image by 180&deg; upside down'
			}
		},
		rotreset: {
			de: 'Drehung zurücksetzen',
			en: 'Reset',
			tooltip: {
				de: 'Ursprüngliche Bildausrichtung wiederherstellen',
				en: 'Reset original image orientation'
			}
		},
		process: {
			de: 'Kopieren/Konvertieren',
			en: 'Copy/Convert'
		},
		skip: {
			de: 'Überspringen',
			en: 'Skip'
		},
		/*wait: {
			de: 'w a r t e . . .',
			en: 'w a i t . . .'
		},*/
		forall: {
			de: 'Für alle weiteren das selbe',
			en: 'Do this for all following'
		},
		orients: {
			none: {
				de: 'keine',
				en: 'none'
			},
			upsidedown: {
				de: '180°',
				en: '180°'
			},
			clockwise: {
				de: 'im Uhrzeigersinn',
				en: 'clockwise'
			},
			counterclockwise: {
				de: 'gegen den Uhrzeigersinn',
				en: 'counterclockwise'
			}
		}
	},
	raw: {
		unknownsize: {
			de: 'Unerkannte RAW-Dateigröße, Entwickler kontaktieren',
			en: 'Unrecognized RAW file size, contact developer'
		},
	},
	selection: {
		got: {
			de: '$$0 Dateien wurden ausgewählt.',
			en: 'Got $$0 files selected.'
		},
	},
	del: {
		question: {
			en: 'Deleting can not be undone! Are you sure you want to continue?',
			de: 'Löschen kann nicht rückgängig gemacht werden. Sicher damit weitermachen?',
			ok: {
				de: 'Ok',
				en: 'Ok'
			},
			cancel: {
				de: 'Abbrechen',
				en: 'Cancel'
			}
		},
		nostatus: {
			de: 'Der Status des Löschens kann nicht sicher geprüft werden. Bitte laden Sie die Seite nach dem Löschen neu.',
			en: 'The status of the delete can not be checked safely. Reload the page after deleting.'
		},
		reload: {
			de: 'Bitte Seite neu laden.',
			en: 'Please reload page.'
		}
	}
};
/* Data for the Imback variants and exif stuff */
this.orients = [ '', 'none', '', 'upsidedown', '', '', 'clockwise', '', 'counterclockwise' ]; // actually const
this.oriecw = [ 1, 6, 3, 8 ]; // clockwise indices // actually const
this.types = [ "unknown", "ImB35mm", "MF 6x7 ", "MF6x4.5", "MF 6x6 " ]; // actually const
this.infos = [
	{
		size: 14065920,
		w: 4320,
		h: 3256,
		typ: 0,
		mode: "historic (4320x3256)"
	},
	{
		size: 15925248,
		w: 4608,
		h: 3456,
		typ: 2,
		mode: "(4608x3456)"
	},
	{
		size: 12076120, // guessed
		w: 4012,
		h: 3010,
		typ: 2,
		mode: "Medium-angle (4012x3010)"
	},
	{
		size: 7967440, // guessed
		w: 3260,
		h: 2444,
		typ: 2,
		mode: "Small-angle (3260x2444)"
	},
	{
		size: 12937632,
		w: 4152, h: 3116,
		typ: 3,
		mode: "(4152x3116)"
	},
	{
		size: 9806592,
		w: 3616, h: 2712,
		typ: 3,
		mode: "Medium-angle (2616x2717)"
	},
	{
		size: 6470944,
		w: 2936, h: 2204,
		typ: 3,
		mode: "Small-angle (2936x2204)"
	},
	{
		size: 11943936,
		w: 3456, h: 3456,
		typ: 4,
		mode: "(3456x3456)"
	},
	{
		size: 9060100, // guessed
		w: 3010, h: 3010,
		typ: 4,
		mode: "Medium-angle (3010x3010)"
	},
	{
		size: 5973136, // guessed
		w: 2444, h: 2444,
		typ: 4,
		mode: "Small-angle (2444x2444)"
	},
	{
		size: 15335424,
		w: 4608, h: 3328,
		typ: 1,
		mode: "(4608x3328)"
	},
	{
		size: 11618752,
		w: 4012, h: 2896,
		typ: 1,
		mode: "Medium-angle (4012x2896)"
	},
	{
		size: 7667520,
		w: 3260, h: 2352,
		typ: 1,
		mode: "Small-angle (3260x2352)"
	}
];

this.mylang = 'en';
this.xlargs = [];
/* For processing several files */
this.totnum=0;
this.actnum=0;
this.allfiles = [];
this.addlinkbool = false;
this.dispcnt = 1;
this.stepmode = 0; // 0 always save (if not checkbox or "save all" in dialog), 1 always ask (set on checkbox), 2 skip all (if selected in dialog)
// current preview image
this.currentrot = 1;
// from the back itself
this.imbpics = [];
this.rimbpics = [];
this.imbmovies = [];
this.imbeles = [];
this.typedclasses = [];
this.untypedclasses = [];
this.earliestmov = '9999';
this.latestmov='0000';
this.earliestjpg='9999';
this.latestjpg='0000';
this.earliestraw='9999';
this.latestraw='0000';
this.loaderrunning;
this.fromvisbrows;
/* deleting */
this.deletephase = 0;
this.deletephs = [ '|' , '/', '-', '\\' ]; // actually const
/* debug */
this.debugflag = false;
this.firstflag = true;
/* helper to append message */
this.appendmsg = (msg) => {
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	msgel.innerHTML += msg;
}
/* helper to append message */
this.appendmsgx = (msg) => {
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	msgel.append(msg);
}
/* helper function to put integer into dng */
this.writeinttoout = (out, num, off) => {
	out[off] = (num % 256);
	out[off + 1] = (num / 256) % 256;
	out[off + 2] = (num / 65536) % 256;
	out[off + 3] = (num / 16777216) % 256;
}
/* handler for file selection input */
this.fselected = () => {
	if (this.actnum !== this.allfiles.length) return;
    const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) this.addlinkbool = addlinkel.checked;
    const stepprev = document.getElementById('steppreview');
    this.stepmode = 0;
	if (stepprev !== null && stepprev.checked) this.stepmode = 1;
	const el = document.getElementById('infile');
	this.totnum = el.files.length;
	this.actnum = 0;
	this.allfiles = el.files;
	if (this.totnum > 0) {
		this.mappx('process.selectedn', imbc.totnum);
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true;
		this.handleonex();
	}
}
/* continue with the next file */
this.handlenext = () => {
	// if (undefined !== allfiles[actnum]) allfiles[actnum] = undefined;
	if (this.actnum < this.allfiles.length - 1) {
		this.actnum++;
		this.handleonex();
	} else {
		this.actnum = 0;
		this.allfiles = [];
		if (this.fromvisbrows) {
			this.fromvisbrows = false;
			this.showbrowser();
		} else this.shownormal();
		document.getElementById('imbdoit').disabled = false;
		document.getElementById('imbvisbrows').disabled = false;
		document.getElementById('droptarget').style['display'] = '';
		document.getElementById('infile').disabled = false;
	}
}
/* as it says */
this.showreloadhints = () => {
	const rl1 = document.getElementById('reloadhint');
	if (null !== rl1) rl1.style['display'] = '';
	const rl2 = document.getElementById('reloadhint2');
	if (null !== rl2) rl2.style['display'] = '';
}
/* switch preview config to jpeg img */
this.setjpegpv = () => {
	document.getElementById('jpegpreview').style['display'] = '';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
}
/* switch preview config to err */
this.setpverr = () => {
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = '';
	document.getElementById('preview').style['display'] = 'none';
}
/* switch preview config to wait */
this.setpvwait = () => {
	document.getElementById('jpegpreview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='none';
	document.getElementById('previewwait').style['display'] = '';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('preview').style['display'] = 'none';
}
/* file/filereader like interface for imback http */
this.createFx = (url, onok, onerr) => {
	let fx = {
		imbackextension: true,
		name: url
	};
	xhr = new XMLHttpRequest();
	xhr.onload = function(evt) {
		fx.data = xhr.response;
		fx.size = xhr.response.byteLength;
		fx.readAsArrayBuffer = function(fy) {
			fy.onload({
				target: {
					result: fy.data
				}
			});
		};
		onok(url, fx);
		xhr.onerror = undefined;
		xhr.ontimeout = undefined;
		xhr.onabort = undefined;
	};
	xhr.onerror = function(evt) {
		xhr.onerror = undefined;
		xhr.onload = undefined;
		xhr.ontimeout = undefined;
		xhr.onabort = undefined;
		onerr(url);
	};
	xhr.onabort = xhr.onerror;
	xhr.ontimeout = xhr.onerror;
	xhr.open('GET', url);
	xhr.setRequestHeader('Cache-control','max-stale');
	xhr.responseType = 'arraybuffer';
	xhr.timeout = 16000;
	try {
		xhr.send();
	} catch (e) {
		xhr.onerror = undefined;
		xhr.onload = undefined;
		xhr.ontimeout = undefined;
		xhr.onabort = undefined;
		onerr(url);
	}
}
this.enablerots = (which) => {
	for (const rots in [ 'procthiscw', 'procthisccw', 'procthisud', 'procthisrs' ]) {
		if (which === rots)
			document.getElementById(which).disabled = true;
		else
			document.getElementById(which).disabled = false;
	}
}
/* main handler function for one file */
this.handleonex = () => {
	const f = this.allfiles[this.actnum];
	document.getElementById('doforall').checked = false;
	this.currentrot = 1;
	this.enablerots('procthisrs');
	if (this.actnum < this.totnum-1) {
		document.getElementById('forrest').style['display'] = '';
	} else document.getElementById('forrest').style['display'] = 'none';
	let rawname = f.name ? f.name : f;
	while (rawname.indexOf("/") > -1) {
		rawname = rawname.substring(rawname.indexOf("/") + 1);
	}
	if (this.stepmode === 2) {
		this.shownormal();
		return this.handlenext();
	}
	else if (this.stepmode === 1) {
		// show preview and ask for rotation, skip, save
		// then (in handler) set mode, call handleone (if save) or handlenext (if skip)
		this.showquestion();
		const f = this.allfiles[this.actnum];
		if (undefined === f) {
			return;
		}
		if (this.totnum > 1) {
			document.getElementById('qhdr').innerHTML = '[' + (1 + this.actnum) + ' / ' + this.totnum + '] ';
		} else document.getElementById('qhdr').innerHTML = '';
		if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG' ||
			rawname.substring(rawname.length -5).toUpperCase() === '.JPEG') {
			/* jpeg preview */
			this.qappx('main.file.jpeg', rawname);
			if (f.name) {
				const fr = new FileReader();
				fr.onload = function(evt) {
					let contents = evt.target.result;
					contents = 'data:image/jpeg;' + contents.substring(8);
					document.getElementById('jpegpreview').src = contents;
					/* shown in onload of img */
				}
				fr.onerror = function(evt) {
					this.setpverr();
				}
				fr.readAsDataURL(f);
			}
			else {
				document.getElementById('jpegpreview').src = f;
			}
		}
		else if (rawname.substring(rawname.length -4).toUpperCase() !== '.RAW') {
			/* no preview */
			this.qappx('main.file.nopreview', rawname);
			this.setnopv();
		}
		else {
			const zz = imbc.infos.findIndex((v, i, o) => v.size === f.size);
			if (zz === -1 && undefined !== f.size) {
				/* no preview */
				this.qappx('main.file.rawunknown', rawname, f.size);
				this.setnopv();
			} else {
				this.qappx('main.file',rawname);
				this.buildpreview(f, () => { imbc.setrawpv(); }, () => { imbc.setpverr(); });
			}
		}
	}
	else { // normal processing without question
		this.shownormal();
		this.handleone();
	}
}
/* xl helper */
this.genspan = (key, arg0, arg1, arg2, arg3) => {
	const s = document.createElement('span');
	s.setAttribute('data-myxlkey', key);
	s.setAttribute('data-myxloff', '' + this.xlargs.length);
	let n=0;
	if (undefined !== arg0) {
		this.xlargs.push(arg0);
		n++;
		if (undefined !== arg1) {
			this.xlargs.push(arg1);
			n++;
			if (undefined !== arg2) {
				this.xlargs.push(arg2);
				n++;
				if (undefined !== arg3) {
					n++;
					this.xlargs.push(arg3);
				}
			}
		}
	}
	s.setAttribute('data-myxlnnn', '' + n);
	return s;
}

/* translated append to preview header */
this.qappx = (key, arg0, arg1, arg2, arg3) => {
	const s = this.genspan(key, arg0, arg1, arg2, arg3);
	document.getElementById('qhdr').append(s);
	this.xlateall();
}
/* translated append to main log */
this.mappx = (key, arg0, arg1, arg2, arg3) => {
	const msgel = document.getElementById('outmsg');
	const xmsg = document.getElementById('xmsg');
	xmsg.style["display"] = "";
	const s = this.genspan(key, arg0, arg1, arg2, arg3);
	this.dispcnt++;
	s.id = 'mappx_' + this.dispcnt;
	msgel.append(s);
	this.xlateall();
}
/* actual processing function for one file */
this.handleone = (orientation) => {
	const f = this.allfiles[this.actnum];
	if (undefined === f) {
		this.mappx('process.nothing');
		this.appendmsg('<br>&nbsp;<br>');
		return this.handlenext();
	}
	if (undefined === f.size) {
		window.setTimeout(() => {
		  this.createFx(f, (url, fx) => {
				this.allfiles[this.actnum] = fx;
				this.handleone(orientation);
			}, (url) => {
				this.mappx('process.erraccess', url);
				this.appendmsg("<br>&nbsp;<br>");
				this.handlenext();
		  });
		});
		return;
	}
	let rawname = f.name;
	while (rawname.indexOf("/") > -1) {
		rawname = rawname.substring(rawname.indexOf("/") + 1);
	}
	if (rawname.substring(rawname.length -4).toUpperCase() !== '.RAW') {
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = function(evt) {
			if (imbc.totnum > 1) {
				imbc.appendmsg("[" + (1 + imbc.actnum) + " / " + imbc.totnum + "] ");
			}
			imbc.mappx('process.notraw',rawname);
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<contents.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			const b = new Blob([ out ], { type: "application/octet-stream"});
			const outel = document.getElementById('result');
			outel.download = rawname;
			const thisurl = URL.createObjectURL(b);
			outel.href = thisurl;
			outel.click();
			imbc.mappx('process.copyok', rawname);
			if (imbc.addlinkbool) {
				imbc.mappx('process.dlagain', rawname, thisurl);
				imbc.showreloadhints();
			}
			imbc.appendmsg("<br>&nbsp;<br>");
			imbc.handlenext();
		}
		reader.onerror = function(evt) {
			imbc.mappend('process.errorreadingfile', f.name);
			imbc.handlenext();
		}
		reader.readAsArrayBuffer(f);
		return;
	}
	let w, h, mode = "??";
	let typ = 0;
	const zz = this.infos.findIndex((v, i, o) => v.size === f.size);
	if (zz === -1) {
		if (totnum > 1) {
			this.appendmsg("[" + (1 + this.actnum) + " / " + this.totnum + "] ");
		}
		this.mappx('process.unknownsize', f.name, f.size);
		const reader = f.imbackextension ? f : new FileReader();
		reader.onload = function(evt) {
			const contents = evt.target.result;
			const view = new DataView(contents);
			const out = new Uint8Array(f.size);
			for (let j=0; j<contents.byteLength; j++) {
				out[j] = view.getUint8(j);
			}
			const b = new Blob([ out ], { type: "application/octet-stream"});
			const outel = document.getElementById('result');
			outel.download = rawname;
			const thisurl = URL.createObjectURL(b);
			outel.href = thisurl;
			outel.click();
			this.mappx('process.copyok', rawname);
			if (addlinkbool) {
				this.mappx('process.dlagain', rawname, thisurl);
				this.showreloadhints();
			}
			this.appendmsg("<br>&nbsp;<br>");
			this.handlenext();
		}
		reader.onerror = function(evt) {
			this.mappend('process.errorreadingfile', f.name);
			this.handlenext();
		}
		reader.readAsArrayBuffer(f);
		return;
	} else {
		w = this.infos[zz].w;
		h = this.infos[zz].h;
		mode = this.infos[zz].mode;
		typ = this.infos[zz].typ;
	}
	const rawnamearr = new TextEncoder().encode(rawname);
	let datestr="", dateaddoff = 0, dateok = false;
	// date?
	const yr = Number.parseInt(rawname.substring(0,4));
	if (yr >= 2019 && yr < 3000 && JSON.stringify(yr) === rawname.substring(0,4)) {
		let mon = Number.parseInt(rawname.substring(5,7));
		if (mon > 0 && mon < 13 && (JSON.stringify(mon) === ((mon < 10) ? rawname.substring(6,7) : rawname.substring(5,7)))) {
			let day = Number.parseInt(rawname.substring(7,9));
			if (day > 0 && day < 32 && (JSON.stringify(day) === ((day < 10) ? rawname.substring(8,9) : rawname.substring(7,9)))) {
				let hr = Number.parseInt(rawname.substring(10,12));
				if (hr >= 0 && hr < 25 && (JSON.stringify(hr) === ((hr < 10) ? rawname.substring(11,12) : rawname.substring(10,12)))) {
					let min = Number.parseInt(rawname.substring(12,14));
					if (min >= 0 && min <= 60 && (JSON.stringify(min) === ((min < 10) ? rawname.substring(13,14) : rawname.substring(12,14)))) {
						let sec = Number.parseInt(rawname.substring(14,16));
						if (sec >= 0 && sec <= 60 && (JSON.stringify(sec) === ((sec < 10) ? rawname.substring(15,16) : rawname.substring(14,16)))) { // maybe leap second?
							datestr = "" + yr + ":" + ((mon < 10) ? "0":"") + mon + ":" + ((day < 10) ? "0":"") + day + " "+
							((hr < 10) ? "0":"") + hr + ":" + ((min < 10) ? "0":"") + min + ":" + ((sec < 10) ? "0":"") + sec;
							if (datestr.length === 19) {
								dateaddoff = 24;
								dateok = true;
							}
						}
					}
				}
			}
		}
	}
	const reader = f.imbackextension ? f : new FileReader();
	reader.onload = function(evt) {
		if (imbc.totnum > 1) {
			imbc.appendmsg("[" + (1 + imbc.actnum) + " / " + imbc.totnum + "] ");
		}
		imbc.mappx('process.processing', rawname);
		imbc.mappx('process.assuming', imbc.types[typ], mode);
		if (dateok) {
			imbc.mappx('process.datetime', datestr);
		}
		if (orientation !== undefined && orientation !== 1) {
			imbc.mappx('process.orientation');
			imbc.appendmsgx(imbc.genspan('preview.orients.' + imbc.orients[imbc.orientation]));
			imbc.appendmsg('<br>');
		}
		/* Here comes the actual building of the DNG */
		const contents = evt.target.result;
		const view = new DataView(contents);
		const out = new Uint8Array(f.size + (dateok ? 466: 422));
		out[0] = 0x49;
		out[1] = 0x49;
		out[2] = 0x2a;
		out[3] = 0;
		imbc.writeinttoout(out, 8 + f.size, 4);
		let k = 8;
		for (let j=0; j<contents.byteLength; j++) {
			out[k++] = view.getUint8(j);
		}
		if (dateok)
			out[k++] = 0x19;
		else
			out[k++] = 0x17;
		const rest0 = [
			0x00, 0xfe, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00
		]; /* followed by 4b width */
		out.set(rest0, k);
		k += rest0.length;
		imbc.writeinttoout(out, w, k);
		k += 4;

		const rest1 = [
			0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00
		]; /* followed by 4b height */
		out.set(rest1, k);
		k += rest1.length;
		imbc.writeinttoout(out, h, k);
		k += 4;

		const rest2 = [ 0x02, 0x01,
			0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x23, 0x80,
			0x00, 0x00, 0x0f, 0x01, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00 ];
		out.set(rest2, k);
		k += rest2.length;
		imbc.writeinttoout(out, f.size + (dateaddoff + 290), k);
		k += 4;

		const rest3 = [ 0x10, 0x01, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00 ];
		out.set(rest3, k);
		k += rest3.length;
		imbc.writeinttoout(out, f.size + (dateaddoff + 298), k);
		k += 4;

		const rest4 = [ 0x11, 0x01, 0x04, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x12, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00 ];
		out.set(rest4, k);
		k += rest4.length;
		if (undefined === orientation) {
			imbc.writeinttoout(out, 1, k);
		} else imbc.writeinttoout(out, orientation, k);
		k += 4;
		const rest4b = [ 0x15, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x17, 0x01,
			0x04, 0x00, 0x01, 0x00, 0x00, 0x00 ];
		out.set(rest4b, k);
		k += rest4b.length;
		imbc.writeinttoout(out, f.size, k);
		k += 4;

		const rest5 = [ 0x1c, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x31, 0x01, 0x02, 0x00, 0x0b, 0x00, 0x00, 0x00 ];
		out.set(rest5, k);
		k += rest5.length;
		imbc.writeinttoout(out, f.size + (dateaddoff + 306), k);
		k += 4;

		if (dateok) { // one datetime tag
			const rest5a = [ 0x32, 0x01, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00 ];
			out.set(rest5a, k);
			k += rest5a.length;
			imbc.writeinttoout(out, f.size + 446, k);
			k += 4;
		}

		const rest6 = [ 0x8d, 0x82, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x8e, 0x82, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00 ];
		out.set(rest6, k);
		k += rest6.length;
		const cfa35 = [ 0x01, 0x00, 0x02, 0x01 ];
		const cfamf = [ 0x02, 0x01, 0x01, 0x00 ]
		if (typ > 1) // color filter array depends on type
			out.set(cfamf, k);
		else
			out.set(cfa35, k);
		k += cfa35.length; // both have same length

		if (dateok) { // other datetime tag
			const rest6a = [ 0x03, 0x90, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00 ];
			out.set(rest6a, k);
			k += rest6a.length;
			imbc.writeinttoout(out, f.size + 446, k);
			k += 4;
		}
		const rest6b = [ 0x12, 0xc6, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x13, 0xc6, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x14, 0xc6, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00 ];
		out.set(rest6b, k);
		k += rest6b.length;
		imbc.writeinttoout(out, (dateaddoff + 318) + f.size, k);
		k += 4;

		const rest7 = [ 0x1d, 0xc6, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x21, 0xc6, 0x0a, 0x00, 0x09, 0x00, 0x00, 0x00 ];
		out.set(rest7, k);
		k += rest7.length;
		imbc.writeinttoout(out, (dateaddoff + 326) + f.size, k);
		k += 4;

		const rest8 = [ 0x28, 0xc6, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00 ];
		out.set(rest8, k);
		k += rest8.length;
		imbc.writeinttoout(out, (dateaddoff + 398) + f.size, k);
		k += 4;

		const rest8b = [ 0x8b, 0xc6, 0x01, 0x00 ];
		out.set(rest8b, k);
		k += rest8b.length;
		imbc.writeinttoout(out, rawnamearr.length, k);
		k += 4;
		imbc.writeinttoout(out, (dateok ? 466: 422) + f.size, k);
		k += 4;

		const rest9 = [ 0x00, 0x00, 0x00, 0x00, 0x49, 0x6d, 0x42, 0x61, 0x63, 0x6b, 0x00, 0x00 ];
		out.set(rest9, k);
		k += rest9.length;
		out.set(new TextEncoder().encode(imbc.types[typ]), k);
		k += 7;

		const rest10a = [ 0x00, 0x69, 0x6d, 0x62, 0x72, 0x61, 0x77, 0x32, 0x64, 0x6e, 0x67,
			0x00, 0x00, 0x49, 0x6d, 0x42, 0x61, 0x63, 0x6b, 0x00, 0x00 ];
		out.set(rest10a, k);
		k += rest10a.length;

		const rest10b = [ 0xff, 0xff, 0xff, 0x7f, 0xf4, 0xb6,
			0x6d, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0xf4, 0xb6,
			0x6d, 0x5b ];
		out.set(rest10b, k);
		k += rest10b.length;

		const rest10c = [ 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff ];
		out.set(rest10c, k);
		k += rest10c.length;

		if (dateok) { // datetime value
			const datearr = new TextEncoder().encode(datestr);
			out.set(datearr, f.size + 446);
			out[f.size + 465] = 0;
		}
		const b = new Blob([ out, rawnamearr ], { type: "image/x-adobe-dng"});
		const outel = document.getElementById('result');
		outel.download = rawname.substring(0, rawname.length - 3) + 'dng';
		const thisurl = URL.createObjectURL(b);
		outel.href = thisurl;
		outel.click();
		imbc.mappx('process.converted', rawname.substring(0, rawname.length - 3));
		if (imbc.addlinkbool) {
			imbc.mappx('process.dlagaindng', rawname.substring(0, rawname.length - 3), thisurl);
			imbc.showreloadhints();
		}
		imbc.appendmsg("<br>&nbsp;<br>");
		imbc.handlenext();
	};
	reader.onerror = function(evt) {
		imbc.mappend('process.errorreadingfile', f.name);
		imbc.handlenext();
	};
	reader.readAsArrayBuffer(f);
}
/* handler function for dropping OS files into the rect */
this.drophandler = (ev) => {
	if (this.actnum !== this.allfiles.length) return;
	const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) this.addlinkbool = addlinkel.checked;
    const stepprev = document.getElementById('steppreview');
    this.stepmode = 0;
	if (stepprev !== null && stepprev.checked) this.stepmode = 1;
	ev.preventDefault();
	this.allfiles = [];
	this.actnum = 0;
	if (ev.dataTransfer.items) {
		this.totnum = [...ev.dataTransfer.items].length;
		[...ev.dataTransfer.items].forEach((item, i) => {
			if (item.kind === "file") {
				const file = item.getAsFile();
				this.allfiles.push(item.getAsFile());
			}
		});
	} else {
		this.totnum = [...ev.dataTransfer.files].length;
		[...ev.dataTransfer.files].forEach((file, i) => {
			this.allfiles.push(file);
		});
	}
	this.mappx('process.droppedn', this.totnum);
	this.appendmsg("<br>&nbsp;<br>");
	document.getElementById('imbdoit').disabled = true;
	document.getElementById('imbvisbrows').disabled = true;
	document.getElementById('droptarget').style['display'] = 'none';
	document.getElementById('infile').disabled = true;
	this.handleonex();
}
/* some handler on the drop rectangle */
this.prevdef = (ev) => {
	ev.preventDefault();
}
/* get one downsampled median image value [ r g b ] */
this.getPix = (x, y, w, view, typ) => {
	let outrgb = [];
	let reds = [];
	if (typ > 1) {
		reds.push(view.getUint8((y+1)*w + x + 1));
		reds.push(view.getUint8((y+1)*w + x + 3));
		reds.push(view.getUint8((y+1)*w + x + 2*w + 1));
		reds.push(view.getUint8((y+1)*w + x + 2*w + 3));
	} else {
		reds.push(view.getUint8(y*w + x + 1));
		reds.push(view.getUint8(y*w + x + 3));
		reds.push(view.getUint8(y*w + x + 2*w + 1));
		reds.push(view.getUint8(y*w + x + 2*w + 3));
	}
	reds.sort(function(a,b) { return a - b; });
	// median of red pixels
	outrgb.push((reds[1] + reds[2]) / 2.0);
	let greens = [];
	if (typ > 1) {
		greens.push(view.getUint8(y*w + x + 1));
		greens.push(view.getUint8(y*w + x + w));
		greens.push(view.getUint8(y*w + x + 3));
		greens.push(view.getUint8(y*w + x + 2 + w));
		greens.push(view.getUint8(y*w + x + 2*w + 1));
		greens.push(view.getUint8(y*w + x + 3*w));
		greens.push(view.getUint8(y*w + x + 2*w + 3));
		greens.push(view.getUint8(y*w + x + 3*w + 2));
	} else {
		greens.push(view.getUint8(y*w + x));
		greens.push(view.getUint8(y*w + x + w + 1));
		greens.push(view.getUint8(y*w + x + 2));
		greens.push(view.getUint8(y*w + x + 3 + w));
		greens.push(view.getUint8(y*w + x + 2*w));
		greens.push(view.getUint8(y*w + x + 3*w +1));
		greens.push(view.getUint8(y*w + x + 2*w + 2));
		greens.push(view.getUint8(y*w + x + 3*w + 3));
	}
	greens.sort(function(a,b) { return a - b; });
	outrgb.push((greens[3] + greens[4]) / 2.0);
	let blues = [];
	if (typ > 1) {
		blues.push(view.getUint8(y*w + x));
		blues.push(view.getUint8(y*w + x + 2));
		blues.push(view.getUint8(y*w + x + 2*w));
		blues.push(view.getUint8(y*w + x + 2*w + 2));
	} else {
		blues.push(view.getUint8((y+1)*w + x));
		blues.push(view.getUint8((y+1)*w + x + 2));
		blues.push(view.getUint8((y+1)*w + x + 2*w));
		blues.push(view.getUint8((y+1)*w + x + 2*w + 2));
	}
	blues.sort(function(a,b) { return a - b; });
	outrgb.push((blues[1] + blues[2]) / 2.0);
	return outrgb;
}
/* put preview into canvas */
// orientation: 1: norm, 3: rot 180, 6 rot 90 CW, 8: rot 270 CCW
this.buildpreview = (f, onok, onerr, orientation, targ, afterload) => {
	let w, h, typ;
	if (undefined === f.size) {
		window.setTimeout(() => {
		  this.createFx(f, (url, fx) => {
				this.buildpreview(fx, onok, onerr, orientation, targ, afterload);
			}, (url) => {
				onerr(f);
		  });
		});
		return;
	}
	const zz = this.infos.findIndex((v, i, o) => v.size === f.size);
	if (zz === -1) {
		console.log('preview: unsupported size ' + f.size + ' of ' + f.name);
		onerr(f);
		return;
	} else {
		w = this.infos[zz].w;
		typ = this.infos[zz].typ;
		h = this.infos[zz].h;
	}
	let canv;
	if (undefined !== targ)
		canv = targ;
	else
		canv = document.getElementById('preview');
	const w8 = Math.floor((w+7)/8) - 1;
	const h8 = Math.floor((h+7)/8) - 1;
	canv.width = w8;
	canv.height = h8;
	if (orientation === 6 || orientation === 8) {
		canv.width = h8;
		canv.height = w8;
	}
	const ctx = canv.getContext('2d', { alpha: false });
	if (undefined !== targ) {
		const sc = 120 / canv.height;
		//ctx.scale(sc, sc);
		//canv.height = 100;
		//canv.width *= sc;
		canv.style['width'] = '' + (sc*canv.width) + 'px';
	}
	const reader = f.imbackextension ? f : new FileReader();
	reader.onload = function(evt) {
		if (undefined !== afterload) afterload();
		const contents = evt.target.result;
		const view = new DataView(contents);
		let minred=255, minblue = 255, mingreen = 255, maxred = 0, maxblue = 0, maxgreen = 0, allmin = 255, allmax = 0;
		let outpix = [];
		let rowiterstart, rowiterend;
		let coliterstart, coliterend;
		let transpose = false;
		if (orientation === 3) {
			rowiterstart = -1*(h8 -1);
			rowiterend = 1;
			coliterstart = -1*(w8 - 1);
			coliterend = 1;
		} else if (orientation === 6) {
			transpose = true;
			rowiterstart = 0;
			rowiterend = w8;
			coliterstart = -1*(h8 - 1);
			coliterend = 1;
		} else if (orientation === 8) {
			transpose = true;
			rowiterstart = -1*(w8 -1);
			rowiterend = 1;
			coliterstart = 0;
			coliterend = h8;
		} else {
			rowiterstart = 0;
			rowiterend = h8;
			coliterstart = 0;
			coliterend = w8;
		}
		for (let i = rowiterstart; i < rowiterend; i +=1) {
			for (let j = coliterstart; j < coliterend; j+=1) {
				let a = imbc.getPix(Math.abs(transpose ? i :j)*8, Math.abs(transpose ? j :i)*8, w, view, typ);
				outpix.push(a[0]);
				if (a[0] > maxred) maxred = a[0];
				if (a[0] < minred) minred = a[0];
				if (a[0] > allmax) allmax = a[0];
				if (a[0] < allmin) allmin = a[0];
				outpix.push(a[1]);
				if (a[1] > maxgreen) maxgreen = a[1];
				if (a[1] < mingreen) mingreen = a[1];
				if (0.6*a[1] > allmax) allmax = a[1] * 0.6;
				if (0.6*a[1] < allmin) allmin = a[1] * 0.6;
				outpix.push(a[2]);
				if (a[2] > maxblue) maxblue = a[2];
				if (a[2] < minblue) minblue = a[2];
				if (a[2] > allmax) allmax = a[2];
				if (a[2] < allmin) allmin = a[2];
				outpix.push(255);
			}
		}
		const fact = 255 / (allmax - allmin);
		for (let i = 0; i < h8; i++) {
			for (let j=0; j< w8; j++) {
				if ((outpix[4*((i * w8) + j)] > 250) &&
					(outpix[4*((i * w8) + j) + 2] > 250) &&
					(outpix[4*((i * w8) + j) + 1] > 0.6 * 250))
				{
					outpix[4*((i*w8) + j) + 1] = 255;
				} else {
					// maybe some brightening gamma?
					const r = (fact * (outpix[4 * ((i*w8) + j)] - allmin));
					outpix[4 * ((i*w8) + j)] = 255-Math.round(255*((255-r)/255)*((255-r)/255));
					const g = (fact * 0.6 * (outpix[4 * ((i*w8) + j) + 1] - allmin* 0.6));
					outpix[4 * ((i*w8) + j) + 1] = 255-Math.round(255*((255-g)/255)*((255-g)/255));
					const b = (fact * (outpix[4 * ((i*w8) + j) + 2] - allmin));
					outpix[4 * ((i*w8) + j) + 2] = 255-Math.round(255*((255-b)/255)*((255-b)/255));
				}
			}
		}
		ctx.putImageData(new ImageData(new Uint8ClampedArray(outpix), transpose ? h8: w8, transpose? w8 :h8), 0, 0);
		onok(f);
	};
	reader.onerror = function(evt) {
		console.log('preview: error reading ' + f.name);
		onerr();
	};
	reader.readAsArrayBuffer(f);
}
/* raw preview okay */
this.setrawpv = () => {
	document.getElementById('preview').style['display'] = '';
	document.getElementById('rotations').style['display'] = '';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = 'none';
}
/* no preview in question */
this.setnopv = () => {
	document.getElementById('preview').style['display'] = 'none';
	document.getElementById('rotations').style['display'] = 'none';
	document.getElementById('continues').style['display']='';
	document.getElementById('previewwait').style['display'] = 'none';
	document.getElementById('previewerr').style['display'] = 'none';
	document.getElementById('jpegpreview').style['display'] = 'none';
}
/* as it says */
this.showquestion = () => {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	quest.style['display'] = '';
	norm.style['display'] = 'none';
	this.setpvwait();
	document.getElementById('qhdr').innerHTML = '';
	document.getElementById('browser').style['display'] = 'none';
}
/* put last message viewable */
this.showlastmsg = () => {
	const ll = document.getElementById('mappx_' + this.dispcnt);
	if (ll) {
		ll.scrollIntoView(false, { block: 'nearest' });
	}
}
/* as it says */
this.shownormal = () => {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	document.getElementById('browser').style['display'] = 'none';
	quest.style['display'] = 'none';
	norm.style['display'] = '';
	window.setTimeout(() => { this.showlastmsg(); }, 100);
}
/* previewquestion: skip handler in the step preview */
this.skipthis = () => {
	if (document.getElementById('doforall').checked) this.stepmode = 2;
	if (this.totnum > 1) {
		this.appendmsg("[" + (1 + this.actnum) + " / " + this.totnum + "] ");
	}
	if (document.getElementById('doforall').checked) {
		this.mappx('process.skipped.remaining', this.totnum - this.actnum);
	} else {
		let rawname = this.allfiles[this.actnum].name ? this.allfiles[this.actnum].name : this.allfiles[this.actnum];
		while (rawname.indexOf("/") > -1) 
			rawname = rawname.substring(rawname.indexOf("/") + 1);
		this.mappx('process.skipped', rawname);
		this.appendmsg("<br>&nbsp;<br>");
	}
	this.shownormal();
	this.handlenext();
}
/* previewquestion: process handler in the step preview */
this.procthis = () => {
	if (document.getElementById('doforall').checked) {
		this.stepmode = 0;
		this.shownormal();
	}
	this.setpvwait();
	this.handleone(imbc.currentrot);
}
/* previewquestion: handler for clockwise rotation */
this.rotcw = () => {
	if (6 === this.currentrot) return;
	this.enablerots('procthiscw');
	this.setpvwait();
	this.currentrot = 6;
	this.buildpreview(this.allfiles[this.actnum], () => { this.setrawpv(); }, () => { this.setpverr(); }, 6);
}
/* previewquestion: handler for counterclockwise rotation */
this.rotccw = () => {
	if (8 === this.currentrot) return;
	this.enablerots('procthisccw');
	this.setpvwait();
	this.currentrot = 8;
	this.buildpreview(this.allfiles[this.actnum], () => { this.setrawpv(); }, () => { this.setpverr(); }, 8);
}
/* previewquestion: handler for upside down rotation */
this.rot180 = () => {
	if (3 === this.currentrot) return;
	this.enablerots('procthisud');
	this.setpvwait();
	this.currentrot = 3;
	this.buildpreview(this.allfiles[this.actnum], () => { this.setrawpv(); }, () => { this.setpverr(); }, 3);
}
/* previewquestion: handler for reset rotation */
this.rot0 = () => {
	if (1 === this.currentrot) return;
	this.enablerots('procthisrs');
	this.setpvwait();
	this.currentrot = 1;
	this.buildpreview(this.allfiles[this.actnum], () => { this.setrawpv(); }, () => { this.setpverr(); }, 1);
}
/* check if we are directly on a back */
this.checkimb  = () => {
	if (this.debugflag) document.getElementById('dbgfsel').style['display'] = '';
	if (!window.location.origin.startsWith('http://192.168.1.254')) return;
	const xhr0 = new XMLHttpRequest();
	xhr0.onloadend = (event) => {
		if (xhr0.status === 200) {
			let foundph = false, foundmov = false;
			const sel = xhr0.responseXML.querySelectorAll('a');
			for (const r of sel) {
				if (r.href.indexOf('/IMBACK/PHOTO') != -1)
					foundph = true;
				if (r.href.indexOf('/IMBACK/MOVIE') != -1)
					foundmov = true;
			}
			if (!foundph && !foundmov) return;
			document.getElementById('onimback').style['display'] = '';
			const xhr = new XMLHttpRequest();
			xhr.onloadend = (event) => {
				//console.log('OLE ' + JSON.stringify(event) + ' XHR ' + JSON.stringify(xhr));
				if (xhr.status === 200) {
					const sel2 = xhr.responseXML.querySelectorAll('a');
					for (const r of sel2) {
						if (r) {
							let rawname = r.href;
							if (rawname.indexOf('del=') != -1) continue;
							while (rawname.indexOf("/") > -1)
								rawname = rawname.substring(rawname.indexOf("/") + 1);
							if (rawname.substring(rawname.length -4).toUpperCase() === '.RAW') {
								if (rawname < this.earliestraw) this.earliestraw = rawname;
								if (rawname > this.latestraw) this.latestraw = rawname;
								rimbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
								imbeles.push({
										type: 'RAW',
										url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									this.untypedclasses.push(cl);
								if (this.typedclasses.findIndex((v, i, o) => v === ('RAW' + cl)) === -1)
									this.typedclasses.push('RAW' + cl);
							}
							else if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG') {
								if (rawname < this.earliestjpg) this.earliestjpg = rawname;
								if (rawname > this.latestjpg) this.latestjpg = rawname;
								this.imbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
								this.imbeles.push({
										type: 'JPG',
										url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									this.untypedclasses.push(cl);
								if (this.typedclasses.findIndex((v, i, o) => v === ('JPG' + cl)) === -1)
									this.typedclasses.push('JPG' + cl);
							}
							else {
								if (rawname < this.earliestmov) this.earliestmov = rawname;
								if (rawname > this.latestmov) this.latestmov = rawname;
								this.imbmovies.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
								this.imbeles.push({
										type: 'oth',
										url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									this.untypedclasses.push(cl);
								if (this.typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
									this.typedclasses.push('oth' + cl);
							}
						}
					}
					document.getElementById('piccnt').innerHTML = '' + this.imbpics.length + ' (';
					if (earliestjpg.length > 4) document.getElementById('piccnt').innerHTML += this.earliestjpg.substring(0,16);
					document.getElementById('piccnt').innerHTML += ' - ';
					if (latestjpg.length > 4) document.getElementById('piccnt').innerHTML += this.latestjpg.substring(0,16);
					document.getElementById('piccnt').innerHTML += ')';
					document.getElementById('piccnt').removeAttribute('data-myxlkey');
					document.getElementById('rpiccnt').innerHTML = '' + this.rimbpics.length + ' (';
					if (earliestraw.length > 4) document.getElementById('rpiccnt').innerHTML += this.earliestraw.substring(0,16);
					document.getElementById('rpiccnt').innerHTML += ' - ';
					if (latestraw.length > 4) document.getElementById('rpiccnt').innerHTML += this.latestraw.substring(0,16);
					document.getElementById('rpiccnt').innerHTML += ')';
					document.getElementById('rpiccnt').removeAttribute('data-myxlkey');
					const xhrm = new XMLHttpRequest();
					xhrm.onloadend = (event) => {
						//console.log('OLE ' + JSON.stringify(event) + ' XHR ' + JSON.stringify(xhr));
						if (xhrm.status === 200) {
							const sel3 = xhrm.responseXML.querySelectorAll('a');
							for (const r of sel3) {
								if (r) {
									let rawname = r.href;
									while (rawname.indexOf("/") > -1)
										rawname = rawname.substring(rawname.indexOf("/") + 1);
									if (rawname.indexOf('del=') != -1) continue;
									if (rawname < this.earliestmov) this.earliestmov = rawname;
									if (rawname > this.latestmov) this.latestmov = rawname;
									this.imbmovies.push('http://192.168.1.254/IMBACK/MOVIE/' + rawname);
									this.imbeles.push({
										type: 'oth',
										url: 'http://192.168.1.254/IMBACK/MOVIE/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
									});
									const cl = rawname.substring(0,12);
									if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
										this.untypedclasses.push(cl);
									if (this.typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
										this.typedclasses.push('oth' + cl);
								}
							}
							document.getElementById('movcnt').innerHTML = '' + this.imbmovies.length + ' (';
							if (earliestmov.length > 4) document.getElementById('movcnt').innerHTML += this.earliestmov.substring(0,16);
							document.getElementById('movcnt').innerHTML += ' - ';
							if (latestmov.length > 4) document.getElementById('movcnt').innerHTML += this.latestmov.substring(0,16);
							document.getElementById('movcnt').innerHTML += ')';
							document.getElementById('movcnt').removeAttribute('data-myxlkey');
							document.getElementById('imbdoit').disabled = false;
							document.getElementById('imbvisbrows').disabled = false;
						}
					};
					xhrm.onerror = (event) => {
						document.getElementById('movcnt').innerHTML = '0';
						document.getElementById('movcnt').removeAttribute('data-myxlkey');
						document.getElementById('imbdoit').disabled = false;
						document.getElementById('imbvisbrows').disabled = false;
					};
					xhrm.open('GET', '/IMBACK/MOVIE/');
					xhrm.responseType = 'document';
					xhrm.send();
				}
			};
			xhr.onerror = (event) => {
				document.getElementById('piccnt').innerHTML = '0';
				document.getElementById('rpiccnt').innerHTML = '0';
				const xhrm = new XMLHttpRequest();
				xhrm.onloadend = (event) => {
					//console.log('OLE ' + JSON.stringify(event) + ' XHR ' + JSON.stringify(xhr));
					if (xhrm.status === 200) {
						const sel3 = xhrm.responseXML.querySelectorAll('a');
						for (const r of sel3) {
							if (r) {
								let rawname = r.href;
								while (rawname.indexOf("/") > -1)
									rawname = rawname.substring(rawname.indexOf("/") + 1);
								if (rawname.indexOf('del=') != -1) continue;
								if (rawname < this.earliestmov) this.earliestmov = rawname;
								if (rawname > this.latestmov) this.latestmov = rawname;
								this.imbmovies.push('http://192.168.1.254/IMBACK/MOVIE/' + rawname);
								this.imbeles.push({
										type: 'oth',
										url: 'http://192.168.1.254/IMBACK/MOVIE/' + rawname,
										raw: rawname,
										selected: false,
										preview: null,
										entry: null,
										waiting: false,
										error: false,
										processed: false
								});
								const cl = rawname.substring(0,12);
								if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
									this.untypedclasses.push(cl);
								if (this.typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
									this.typedclasses.push('oth' + cl);
							}
						}
						document.getElementById('movcnt').innerHTML = '' + this.imbmovies.length + ' (';
						if (earliestmov.length > 4) document.getElementById('movcnt').innerHTML += this.earliestmov.substring(0,16);
						document.getElementById('movcnt').innerHTML += ' - ';
						if (latestmov.length > 4) document.getElementById('movcnt').innerHTML += this.latestmov.substring(0,16);
						document.getElementById('movcnt').innerHTML += ')';
						document.getElementById('movcnt').removeAttribute('data-myxlkey');
						document.getElementById('imbdoit').disabled = false;
						document.getElementById('imbvisbrows').disabled = false;
					}
				};
				xhrm.onerror = (event) => {
					document.getElementById('movcnt').innerHTML = '0';
					document.getElementById('movcnt').removeAttribute('data-myxlkey');
					document.getElementById('imbdoit').disabled = false;
					document.getElementById('imbvisbrows').disabled = false;
				};
				xhrm.open('GET', '/IMBACK/MOVIE/');
				xhrm.responseType = 'document';
				xhrm.send();
			};
			xhr.open('GET', '/IMBACK/PHOTO/');
			xhr.responseType = 'document';
			xhr.send();
		}
	};
	xhr0.open('GET', '/IMBACK/');
	xhr0.responseType = 'document';
	xhr0.send();
}
/* handle the normal selection from imback (do it button) */
this.imbdoit = () => {
	if (this.actnum !== this.allfiles.length) return;
	let selecteds = [];
	let compval = '0000';
	if (document.getElementById('imbstartts').value != undefined && document.getElementById('imbstartts').value.length > 0) {
		compval = document.getElementById('imbstartts').value;
	}
	if (document.getElementById('picfromimb').checked) {
		for (const e of this.imbpics) {
			let rawname = e;
			while (rawname.indexOf("/") > -1)
				rawname = rawname.substring(rawname.indexOf("/") + 1);
			if (rawname.substring(0, compval.length) >= compval)
				selecteds.push(e);
		}
	}
	if (document.getElementById('rpicfromimb').checked) {
		for (const e of this.rimbpics) {
			let rawname = e;
			while (rawname.indexOf("/") > -1)
				rawname = rawname.substring(rawname.indexOf("/") + 1);
			if (rawname.substring(0, compval.length) >= compval)
				selecteds.push(e);
		}
	}
	if (document.getElementById('movfromimb').checked) {
		for (const e of this.imbmovies) {
			let rawname = e;
			while (rawname.indexOf("/") > -1)
				rawname = rawname.substring(rawname.indexOf("/") + 1);
			if (rawname.substring(0, compval.length) >= compval)
				selecteds.push(e);
		}
	}
	selecteds.sort((a, b) => {
		let ra = a;
		let rb = b;
		while (ra.indexOf("/") > -1)
			ra = ra.substring(ra.indexOf("/") + 1);
		while (rb.indexOf("/") > -1)
			rb = rb.substring(rb.indexOf("/") + 1);
		if (ra < rb) return -1;
		else if (ra === rb) return 0;
		else return 1;
	});
    const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null)  this.addlinkbool = addlinkel.checked;
    const stepprev = document.getElementById('steppreview');
    this.stepmode = 0;
	if (stepprev !== null && stepprev.checked) this.stepmode = 1;
	this.totnum = selecteds.length;
	this.actnum = 0;
	this.allfiles = selecteds;
	if (this.totnum > 0) {
		this.mappx('process.frombackn', this.totnum);
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true
		this.handleonex();
	}
}
/* open visual browser */
this.visbrows = () => {
	this.aftercheck();
	window.onscroll = () => this.startloadimg();
	window.onresize = () => this.startloadimg();
	this.showbrowser();
	this.buildtree();
}
/* as it says */
this.showbrowser = () => {
	const norm = document.getElementById('normal');
	const quest = document.getElementById('question');
	document.getElementById('browser').style['display'] = '';
	quest.style['display'] = 'none';
	norm.style['display'] = 'none';
}
/* visual browser: create the wait dots */
this.createwait = (el) => {
	const waitdiv = document.createElement('div');
	waitdiv.classList.add('eepvw');
	const d1 = document.createElement('span');
	d1.classList.add('blink');
	d1.append('.');
	waitdiv.append(d1);
	const d2 = document.createElement('span');
	d2.classList.add('blink2');
	d2.append('.');
	waitdiv.append(d2);
	const d3 = document.createElement('span');
	d3.classList.add('blink3');
	d3.append('.');
	waitdiv.append(d3);
	el.entry.append(waitdiv);
}
/* visual browser: prepare the browser display, group the stuff */
this.aftercheck = () => {
	if (this.untypedclasses[0].title) return;
	for (const x of this.untypedclasses) {
		const cl = {
			title: x,
			level: 5,
			fmembers: []
		};
		cl.entry = document.createElement('div');
		cl.entry.id = 'gg_' + x + '_X';
		cl.entry.classList.add('gg');
		cl.entry.classList.add('ggclosed');
		cl.entry.classList.add('gl5');
		for (const y of this.imbeles) {
			if (x === y.raw.substring(0,12))
			{
				// todo: sort
				cl.fmembers.push(y);
				y.inuntyped = true;
			}
		}
		this.untypedclasses.splice(this.untypedclasses.findIndex((v,i,o) => v === x), 1, cl);
	}
	for (const x of this.typedclasses) {
		const cl = {
			title: x,
			level: 5,
			fmembers: []
		};
		cl.entry = document.createElement('div');
		cl.entry.id = 'gg_' + x + '_X';
		cl.entry.classList.add('gg');
		cl.entry.classList.add('ggclosed');
		cl.entry.classList.add('gl5');
		for (const y of this.imbeles) {
			if (x === y.type + y.raw.substring(0,12))
			{
				// todo: sort
				cl.fmembers.push(y);
				y.intyped = true;
			}
		}
		this.typedclasses.splice(this.typedclasses.findIndex((v,i,o) => v === x), 1, cl);
	}
	this.higherclasses(this.untypedclasses, 9, 5);
	this.higherclasses(this.typedclasses, 12, 5);
	// top type classes here
	for (const u of this.typedclasses.filter((o) => o.level === 2)) {
		if (u.ischild) continue;
		if (this.typedclasses.filter((o) => u.title.substring(0,3) === o.title.substring(0,3)).length === 1) {
			u.level --;
			u.entry.classList.add('gl' + u.level);
			u.entry.classList.remove('gl' + (u.level + 1));
		} else if (this.typedclasses.findIndex((o) => o.title === u.title.substring(0,3)) === -1) {
			const cl = {
				title: u.title.substring(0,3),
				level: 1,
				smembers: []
			};
			cl.entry = document.createElement('div');
			cl.entry.id = 'gg_' + u.title.substring(0,3) + '_X';
			cl.entry.classList.add('gg');
			cl.entry.classList.add('ggclosed');
			cl.entry.classList.add('gl1');
			for (const x of this.typedclasses.filter((o) => u.title.substring(0,3) === o.title.substring(0,3))) {
				x.ischild = true;
				// todo: sort when display
				cl.smembers.push(x);
				cl.haschildren = true;
				this.typedclasses.splice(this.typedclasses.findIndex((o) => o.title === x.title),1);
			}
			this.typedclasses.push(cl);
		}
	}
	// non-typed upgraded to gl1, unless only one
	if (this.untypedclasses.filter((o) => o.level === 2).length === 1 && this.untypedclasses.filter((o) => o.level === 2)[0].smembers) {
		const t = this.untypedclasses.filter((o) => o.level === 2)[0];
		this.untypedclasses.splice(0,1);
		for (const s of t.smembers) {
			s.entry.classList.add('gl1');
			s.level = 2;
			this.untypedclasses.push(s);
		}
	} else
		for (const s of this.untypedclasses.filter((o) => o.level === 2)) s.entry.classList.add('gl1');
	// build title elemenes
	for (const s of this.untypedclasses) this.buildtitlerec(s);
	for (const s of this.typedclasses) this.buildtitlerec(s);
	document.getElementById('brnsel').innerHTML = '0';
	document.getElementById('brntot').innerHTML = '' + this.imbeles.length;
	/* debug * /
	if (debugflag) {
		for (const s of untypedclasses.filter((o) => o.level === 2)) prgr(s,1);
		for (const s of typedclasses.filter((o) => o.level === 1)) prgr(s,1);
	} */
}
/* visual browser: build ordered lists */
this.buildtree = () => {
	let list, toplevel;
	if (document.getElementById('sbytype').checked) {
		list = this.typedclasses;
		toplevel = 1;
	}
	else {
		list = this.untypedclasses;
		toplevel = 2;
	}

	// first, make everything empty
	for (const e of this.untypedclasses) {
		e.entry.remove();
		this.doclose(e, true);
	}
	for (const e of this.typedclasses) {
		e.entry.remove();
		this.doclose(e, true);
	}
	for (const d of this.imbeles) {
		if (undefined !== d.entry && null !== d.entry)
			d.entry.remove();
	}

	// now, sort and add
	for (const e of list.filter((o) => o.level === toplevel).sort((a,b) => this.mysort(a, b))) {
		document.getElementById('browser').append(e.entry);
		this.addsorted(e);
	}
	this.xlateall();
}
// visual browser: find next to load
this.findnexttoload = () => {
	for (const e of this.imbeles.sort((a,b) => this.myisort(a,b))) {
		// display: none somewhere?
		if (!e.entry) continue;
		const p = e.entry;
		if (!p.parentElement) continue;
		// not waiting or error at all?
		if (p.querySelector('.eepvx')) continue;
		if (e.nonewerr) continue;
		let nwaitandnerr = true;
		if (p.querySelector('.eepvw') && p.querySelector('.eepvw').style['display'] !== 'none') nwaitandnerr = false;
		if (p.querySelector('.errimg') && p.querySelector('.errimg').style['display'] !== 'none') nwaitandnerr = false;
		if (nwaitandnerr) continue;
		let dispno = false;
		let f = p.parentElement;
		while (f) {
			if (f.style['display'] === 'none') {
				dispno = true;
				break;
			}
			let y = f.classList;
			if (f.classList.contains('ggclosed')) {
				dispno = true;
				break;
			}
			f = f.parentElement;
		}
		if (dispno) continue;
		// display not none, check pos
		rect = p.getBoundingClientRect();
		if (rect.top < window.innerHeight && rect.bottom > 0 && rect.width > 0)
			return e;
	}
	return undefined;
}
/* visual browser: sort helper */
this.mysort = (a, b) => {
	const fact = document.getElementById('solder').checked ? 1 : -1
	if (a.title > b.title) return fact;
	else if (a.title < b.title) return -1 * fact;
	else return 0;
}
/* visual browser: sort helper */
this.myisort = (a, b) => {
	const fact = document.getElementById('solder').checked ? 1 : -1
	if (a.raw > b.raw) return fact;
	else if (a.raw < b.raw) return -1 * fact;
	else return 0;
}
/* visual browser: add images sorted  */
this.addimgsorted = (el) => {
	if (el.fmembers !== null && el.fmembers !== undefined) {
		for (const e of el.fmembers.sort((a,b) => this.myisort(a, b))) {
			if (null === e.entry || undefined === e.entry) this.displaydiv(e);
			el.entry.querySelector('.igtype').append(e.entry);
			e.nonewerr = false; // retry again if was error
		}
	}
}
/* visual browser: add sorted recursively */
this.addsorted = (el) => {
	if (el.smembers === null || el.smembers ===  undefined) return;
	for (const e of el.smembers.sort((a,b) => this.mysort(a, b))) {
		this.addsorted(e);
		el.entry.append(e.entry);
	}
}
/* visual browser: recursive texts */
this.buildtitlerec = (el) => {
	this.buildtitle(el);
	if (el.smembers === null || el.smembers ===  undefined) return;
	for (const e of el.smembers) {
		this.buildtitlerec(e);
	}
}
/* visual browser: recursive fold close */
this.doclose = (gr, recurse) => {
	gr.entry.querySelector('.ggtt').classList.add('ggttclosed');
	gr.entry.querySelector('.ggtt').classList.remove('ggttopen');
	gr.entry.classList.add('ggclosed');
	gr.entry.classList.remove('ggopen');
	if (recurse && gr.smembers)
		for (const e of gr.smembers) this.doclose(e, recurse);
}
/* visual browser: recursive fold open */
this.doopen = (gr, recurse, nontop) => {
	gr.entry.querySelector('.ggtt').classList.remove('ggttclosed');
	gr.entry.querySelector('.ggtt').classList.add('ggttopen');
	gr.entry.classList.remove('ggclosed');
	gr.entry.classList.add('ggopen');
	if (recurse && gr.smembers)
		for (const e of gr.smembers) this.doopen(e, recurse, true);
	if (gr.fmembers) {
		for (const e of gr.fmembers) {
			if (e.entry) e.entry.remove();
		}
	}
	if (gr.fmembers && !gr.entry.querySelector('.ee'))
		this.addimgsorted(gr);
	if (nontop !== true) this.startloadimg();
}
/* visual browser: select all from top */
this.topreccheck = (force) => {
	if (undefined === force)
		force = document.getElementById('selall').checked;
	this.reccheck(force);
}
/* select all */
this.reccheck = (to, root) => {
	if (undefined === root) {
		for (const e of this.typedclasses) this.reccheck(to, e);
		for (const e of this.untypedclasses) this.reccheck(to, e);
		return;
	} else {
		root.entry.querySelector('.selcb').checked = to;
		if (root.fmembers) {
			for (const e of root.fmembers) {
				e.selected = to;
				if (e.entry) e.entry.querySelector('.selcb').checked = to;
			}
		}
		if (root.smembers)
			for (const e of root.smembers) this.reccheck(to, e);
	}
	this.updateselections();
}
/* visual browser: text and controls on top of a group */
this.buildtitle = (gr) => {
	let t = '', s = gr.title;
	const d = document.createElement('div');
	d.classList.add('ggtt');
	d.classList.add('ggttclosed');
	const pluss = document.createElement('span');
	pluss.classList.add('ggttplus');
	pluss.append('[+]');
	pluss.onclick = () => {
		this.doopen(gr, false);
	};
	d.append(pluss);
	const pluspluss = document.createElement('span');
	pluspluss.classList.add('ggttplus');
	if (gr.haschildren) {
		pluspluss.append('[++]');
		pluspluss.onclick = () => {
			this.doopen(gr, true);
		};
	}
	else
		pluspluss.append(' ');
	d.append(pluspluss);
	const minuss = document.createElement('span');
	minuss.classList.add('ggttminus');
	minuss.append('[‒]');
	minuss.onclick = () => {
		d.classList.remove('ggttopen');
		d.classList.add('ggttclosed');
		d.parentElement.classList.remove('ggopen');
		d.parentElement.classList.add('ggclosed');
		this.startloadimg();
	};
	d.append(minuss);
	const nixs = document.createElement('span');
	nixs.classList.add('ggttminus');
	nixs.append(' ');
	d.append(nixs);
	if (s.startsWith('JPG') || s.startsWith('RAW')) {
		const sp = document.createElement('span');
		sp.classList.add('gtype');
		sp.append(' ' + s.substring(0,3) + ': ');
		sp.style['display'] = 'none';
		d.append(sp);
		s = s.substring(3);
	} else if (s.startsWith('oth')) {
		const sp = document.createElement('span');
		sp.classList.add('gtype');
		sp.setAttribute('data-myxlkey', 'main.types.notpic');
		sp.style['display'] = 'none';
		d.append(sp);
		s = s.substring(3);
	}
	if (s.length > 0) t += (' ' + s);
	const tit = document.createElement('span');
	tit.classList.add('grtit');
	tit.append(t);
	d.append(tit);
	d.append(' - ');
	d.append(this.genspan('main.selected'));
	d.append(': ');
	const selno = document.createElement('span');
	selno.id = 'SEL_' + gr.title;
	selno.classList.add('selnumber');
	selno.append('0');
	d.append(selno);
	d.append(' / ');
	const totno = document.createElement('span');
	totno.id = 'TOT_' + gr.title;
	totno.append('' + this.countfiles(gr));
	d.append(totno);
	d.append(' - ');
	const texttit = document.createElement('label');
	const cb = document.createElement('input');
	cb.type = 'checkbox';
	cb.checked = false;
	cb.classList.add('selcb');
	cb.id = 'SELC_' + gr.title;
	cb.classList.add('selcb');
	texttit.htmlFor = cb.id;
	texttit.append(cb);
	texttit.append(this.genspan('browser.selall'));
	cb.onclick = (ev) => {
		if (cb.checked) this.reccheck(true, gr);
		else this.reccheck(false, gr);
	};
	d.append(texttit);

	gr.entry.append(d);
	if (!gr.haschildren) {
		const ig = document.createElement('div');
		ig.classList.add('igtype');
		gr.entry.append(ig);
	}
}
/* visual browser: add classes upwards */
this.higherclasses = (arr, len, curlevel) => {
	for (const u of arr.filter((o) => o.level === curlevel)) {
		if (u.ischild) continue;
		if (arr.filter((o) => u.title.substring(0,len) === o.title.substring(0,len)).length === 1) {
			u.level --;
			u.entry.classList.add('gl' + u.level);
			u.entry.classList.remove('gl' + (u.level + 1));
		} else if (arr.findIndex((o) => o.title === u.title.substring(0,len)) === -1) {
			const cl = {
				title: u.title.substring(0,len),
				level: curlevel - 1,
				smembers: []
			};
			cl.entry = document.createElement('div');
			cl.entry.id = 'gg_' + u.title.substring(0,len) + '_X';
			cl.entry.classList.add('gg');
			cl.entry.classList.add('ggclosed');
			cl.entry.classList.add('gl' + (curlevel - 1));
			for (const x of arr.filter((o) => u.title.substring(0,len) === o.title.substring(0,len))) {
				x.ischild = true;
				// todo: sort when open
				cl.smembers.push(x);
				cl.haschildren = true;
				arr.splice(arr.findIndex((o) => o.title === x.title),1);
			}
			arr.push(cl);
		}
	}
	if (curlevel === 5)
		this.higherclasses(arr, len - 2, 4);
	else if (curlevel === 4)
		this.higherclasses(arr, len - 3, 3);
}
/* visual browser: return count of files in class */
this.countfiles = (cla) => {
	let res = 0;
	if (undefined !== cla.fmembers) res += cla.fmembers.length;
	if (undefined !== cla.smembers)
		for (const s of cla.smembers)
			res += this.countfiles(s);
	return res;
}
/* visual browser: recursive count selection */
this.countsel = (gr) => {
	let res = 0;
	if (gr.fmembers) {
		res += gr.fmembers.filter((o) => o.selected).length;
	}
	if (gr.smembers) {
		for (const g of gr.smembers)
			res += this.countsel(g);
	}
	gr.entry.querySelector('.selnumber').innerHTML = '' + res;
	gr.entry.querySelector('.selcb').checked = (res === this.countfiles(gr));
	gr.sels = res;
	return res;
}
/* visual browser: update all "selected" values */
this.updateselections = () => {
	for (const s of this.typedclasses) this.countsel(s);
	for (const s of this.untypedclasses) this.countsel(s);
	let res = 0, sum = 0;
	for (const s of this.typedclasses) {
		res += s.sels;
		sum += this.countfiles(s);
	}
	document.getElementById('brnsel').innerHTML = '' + res;
	document.getElementById('selall').checked = (res === sum);
	document.getElementById('delselbut').disabled = (res === 0);
}
/* visual browser: fill a html div into an imbele */
this.displaydiv = (e) => {
	e.entry = document.createElement('div');
	e.entry.id = 'div_' + e.raw + '_X';
	e.entry.classList.add('ee');
	e.entry.classList.add(e.type);
	let rawname = e.url;
	while (rawname.indexOf("/") > -1)
		rawname = rawname.substring(rawname.indexOf("/") + 1);
	e.entry.classList.add('ET_' + e.type + rawname.substring(0,12));
	e.entry.classList.add('EY_' + rawname.substring(0,12));
	const topline = document.createElement('div');
	const texttit = document.createElement('label');
	texttit.classList.add('etit');
	const check = document.createElement('input');
	check.type = 'checkbox';
	check.name = 'cb_sel_' + e.raw + '_X';
	check.id = 'cb_sel_' + e.raw + '_X';
	check.classList.add('selcb');
	check.checked = e.selected;
	check.onclick = () => {
		e.selected = check.checked;
		this.updateselections();
	};
	texttit.htmlFor = check.id;
	texttit.append(check);
	texttit.append(rawname);
	topline.append(texttit);
	if (e.type === 'RAW') {
		e.rot = 1;
		const rotbtn = document.createElement('span');
		rotbtn.id = 'rot_b_' + e.raw + '_Y';
		rotbtn.classList.add('rotbtn');
		rotbtn.classList.add('disabled');
		rotbtn.append('\u21ba');
		rotbtn.onclick = (e) => {
			if (rotbtn.classList.contains('disabled')) return;
			let j = oriecw.findIndex((v) => { v === e.rot });
			j = ((j + 1) % 4);
			e.rot = oriecw[j];
			e.preview.style['display'] = 'none';
			e.preview.querySelector('.eepvw').style['display'] = '';
			this.startloadimg();
		};
		topline.append(rotbtn);
	}
	const dlbtn = document.createElement('uutt');
	dlbtn.id = 'dl_b_' + e.raw;
	dlbtn.classList.add('dlbtn');
	//dlbtn.classList.add('disabled');
	dlbtn.append('\u2193');
	dlbtn.onclick = (ev) => {
		if (dlbtn.classList.contains('disabled')) return;
		if (this.actnum !== this.allfiles.length) return;
		let selecteds = [ e.url ];
		const addlinkel = document.getElementById('addlink');
		if (addlinkel !== null) addlinkbool = addlinkel.checked;
		this.stepmode = 0;
		this.totnum = 1;
		this.actnum = 0;
		this.allfiles = selecteds;
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true
		this.shownormal();
		fromvisbrows = true;
		this.handleone();
	};
	topline.append(dlbtn);
	
	e.entry.append(topline);
	// rotate button if raw

	const errdiv = document.createElement('div');
	errdiv.classList.add('errimg');
	errdiv.append('X');
	errdiv.style['display'] = 'none';
	e.entry.append(errdiv);
	if (e.type === 'RAW') {
		e.preview = document.createElement('canvas');
		e.preview.classList.add('eeraw');
		e.preview.classList.add('eewait');
		e.preview.style['display'] = 'none';
		e.preview.style['height'] = '120px';
		e.preview.onmouseover = (ev) => {
			e.preview.classList.add('biggie');
		}
		e.preview.onmouseout = (ev) => {
			e.preview.classList.remove('biggie');
		}
		e.entry.append(e.preview);
		this.createwait(e);
	} else if (e.type === 'JPG') {
		e.preview = document.createElement('img');
		e.preview.classList.add('eeimg');
		e.preview.classList.add('eewait');
		e.preview.style['display'] = 'none';
		e.preview.style['height'] = '120px';
		e.preview.onmouseover = (ev) => {
			e.preview.classList.add('biggie');
		}
		e.preview.onmouseout = (ev) => {
			e.preview.classList.remove('biggie');
		}
		e.entry.append(e.preview);
		this.createwait(e);
	} else {
		e.preview = document.createElement('div');
		e.preview.classList.add('eepvx');
		e.preview.append('?');
		e.entry.append(e.preview);
	}
}
/* visual browser: image loader call */
this.loadimg = (url, type, to) => {
	if (to.entry.querySelector('.eepvx') || (to.entry.querySelector('.eepvw').style['display'] === 'none' && to.entry.querySelector('.errimg').style['display'] === 'none')) {
		if (this.debugflag) console.log('ldr aa lnx ' + to.raw);
		this.loadnextimg();
		return;
	}
	to.entry.querySelector('.errimg').style['display'] = 'none';
	to.entry.querySelector('.eepvw').style['display'] = '';
	if (type === 'JPG') {
		to.preview.onload = (ev) => {
			to.entry.querySelector('.eepvw').style['display'] = 'none';
			to.preview.style['display'] = '';
			to.preview.style['width'] = to.preview.woidth * (120 / to.preview.height);
			if (this.debugflag) console.log('ldr j f lnx ' + to.raw);
			this.loadnextimg();
		};
		to.preview.onerror = (ev) => {
			to.entry.querySelector('.eepvw').style['display'] = 'none';
			to.entry.querySelector('.errimg').style['display'] = '';
			if (this.debugflag) console.log('ldr j e lnx ' + to.raw);
			to.nonewerr = true;
			this.loadnextimg();
		};
		to.preview.src = url;
	}
	else if (type === 'RAW') {
		this.buildpreview(url, () => {
			to.entry.querySelector('.eepvw').style['display'] = 'none';
			to.entry.querySelector('.rotbtn').classList.remove['disabled'];
			to.entry.querySelector('.dlbtn').classList.remove['disabled'];
			to.preview.style['display'] = '';
			if (this.debugflag) console.log('ldr r f ' + to.raw);
		}, () => {
			to.entry.querySelector('.eepvw').style['display'] = 'none';
			to.entry.querySelector('.errimg').style['display'] = '';
			to.entry.querySelector('.rotbtn').classList.add['disabled'];
			to.entry.querySelector('.dlbtn').classList.add['disabled'];
			to.nonewerr = true;
			if (this.debugflag) console.log('ldr r e ' + to.raw);
			if (this.loaderrunning === url) {
				if (this.debugflag) console.log('ldr r e lnx ' + to.raw);
				this.loadnextimg();
			} // else the afterload had already been called
		}, 1, to.preview, () => { /* afterload: */
			if (this.debugflag) console.log('ldr r l lnx ' + to.raw);
			// invalidate url for err callback
			this.loaderrunning = '1';
			this.loadnextimg();
		});
	}
}
/* visual browser: load next from todo list */
this.loadnextimg = () => {
	const e = this.findnexttoload();
	if (!e) {
		this.loaderrunning = false;
		if (this.debugflag) console.log('TERM loader');
		return;
	}
	else {
		this.loaderrunning = e.url;
		window.setTimeout(() => {
			if (this.debugflag) console.log('L ' + e.raw);
			this.loadimg(e.url, e.type, e)
		}, 33);
	}
}
/* visual browser: start loading */
this.startloadimg = () => {
	if (!this.loaderrunning) {
		if (this.debugflag) console.log('start loader');
		this.loadnextimg();
	}
	else if (this.debugflag) {
		console.log('load already on ' + this.loaderrunning);
	}
}
/* visual browser: delete browser selected */
this.browserdelete = () => {
	document.getElementById('delq').style['display'] = '';
	document.getElementById('browser').style['display'] = 'none';
	document.getElementById('delokbut').disabled = false;
	document.getElementById('delcancelbut').disabled = false;
}
/* visual browser: do delete */
this.dodelete = (list) => {
	if (list === undefined && this.imbeles.filter((o) => o.selected).length === 0) {
		delcancel();
		return;
	}
	else if (list === undefined) {
		document.getElementById('delokbut').disabled = true;
		document.getElementById('delcancelbut').disabled = true;
		this.dodelete(this.imbeles.filter((o) => o.selected));
		this.deletephase=0;
		document.getElementById('delprogmsg').innerHTML = this.deletephs[this.deletephase];
		return;
	} else if (list.length > 0) {
		let xhr = new XMLHttpRequest();
		xhr.onload = () => {
			this.deletephase ++;
			document.getElementById('delprogmsg').innerHTML = this.deletephs[this.deletephase % this.deletephs.length];
			const pv = list[0].preview;
			if (pv)
				pv.classList.add('picdeleted');
			list.splice(0,1);
			this.dodelete(list);
			xhr.onerror = undefined;
			xhr.onload = undefined;
			xhr.ontimeout = undefined;
		};
		xhr.onerror = xhr.onload;
		xhr.ontimeout = xhr.onload;
		xhr.open('GET',list[0].url + '?del=1');
		xhr.send();
	} else {
		alert(xl('del.reload'));
		this.delcancel();
	}
}
/* visual browser: cancel the delete */
this.delcancel = () => {
	document.getElementById('delq').style['display'] = 'none';
	document.getElementById('browser').style['display'] = '';
}
/* visual browser: process browser selected */
this.browserprocess = () => {
	if (actnum !== this.allfiles.length) return;
	let selecteds = [];
	for (const i of this.imbeles) {
		if (i.selected) selecteds.push(i.url);
		if (i.preview)
			i.preview.classList.add('picprocd');
	}
	selecteds.sort((a, b) => {
		let ra = a;
		let rb = b;
		while (ra.indexOf("/") > -1)
			ra = ra.substring(ra.indexOf("/") + 1);
		while (rb.indexOf("/") > -1)
			rb = rb.substring(rb.indexOf("/") + 1);
		if (ra < rb) return -1;
		else if (ra === rb) return 0;
		else return 1;
	});
    const addlinkel = document.getElementById('addlink');
	if (addlinkel !== null) addlinkbool = addlinkel.checked;
    this.stepmode = 0;
	this.totnum = selecteds.length;
	this.actnum = 0;
	this.allfiles = selecteds;
	if (this.totnum > 0) {
		this.mappx('process.frombrowsern', totnum);
		document.getElementById('imbdoit').disabled = true;
		document.getElementById('imbvisbrows').disabled = true;
		document.getElementById('droptarget').style['display'] = 'none';
		document.getElementById('infile').disabled = true
		this.handleonex();
		this.topreccheck(false);
	} else {
		this.shownormal();
	}
}
/* translate one string with parameters */
this.xl = (str, base, arg0, arg1, arg2, arg3) => {
	if (undefined === base) base = this.texts;
	if (this.mylang === '00') {
		let res = '[' + str;
		if (undefined !== arg0) {
			res += ',' + arg0;
			if (undefined !== arg1) {
				res += ',' + arg1;
				if (undefined !== arg2) {
					res += ',' + arg2;
					if (undefined !== arg3) {
						res += ',' + arg3;
					}
				}
			}
		}
		return (res + ']');
	}
	const i = str.indexOf('.');
	if (i === -1) {
		let r = base[str][this.mylang];
		if (r.indexOf('$$0') !== -1 && arg0 !== undefined) {
			r = r.substring(0, r.indexOf('$$0')) + arg0 + r.substring(r.indexOf('$$0') + 3);
			if (r.indexOf('$$1') !== -1 && arg1 !== undefined) {
				r = r.substring(0, r.indexOf('$$1')) + arg1 + r.substring(r.indexOf('$$1') + 3);
				if (r.indexOf('$$2') !== -1 && arg2 !== undefined) {
					r = r.substring(0, r.indexOf('$$2')) + arg2 + r.substring(r.indexOf('$$2') + 3);
					if (r.indexOf('$$3') !== -1 && arg3 !== undefined) {
						r = r.substring(0, r.indexOf('$$3')) + arg3 + r.substring(r.indexOf('$$3') + 3);
					}
				}
			}
		}
		return r;
	}
	else {
		const e = base[str.substring(0,i)];
		return this.xl(str.substring(i+1),e, arg0, arg1, arg2, arg3);
	}
}
/* translate everything */
this.xlateall = () => {
	const k = document.querySelectorAll('*[data-myxlkey]');
	for (const e of k) {
		const o = e.attributes.getNamedItem('data-myxloff')?.value;
		const nn = e.attributes.getNamedItem('data-myxlnnn')?.value;
		if (o !== undefined && o !== null && o !== '' && nn !== undefined) {
			e.innerHTML = this.xl(e.attributes.getNamedItem('data-myxlkey').value, undefined,  (nn > 0) ? this.xlargs[Number.parseInt(o,10)]:undefined, (nn > 1) ? this.xlargs[Number.parseInt(o,10)+1]:undefined, (nn > 2) ? this.xlargs[Number.parseInt(o,10)+2]:undefined, (nn > 3) ? this.xlargs[Number.parseInt(o,10)+3]:undefined );
		} else {
			e.innerHTML = this.xl(e.attributes.getNamedItem('data-myxlkey').value);
		}
	}
	const l = document.querySelectorAll('*[data-myvalxlkey]');
	for (const e of l) {
		e.value = this.xl(e.attributes.getNamedItem('data-myvalxlkey').value);
	}
	const m = document.querySelectorAll('*[data-mytitlexlkey]');
	for (const e of m) {
		e.title = this.xl(e.attributes.getNamedItem('data-mytitlexlkey').value);
	}
	document.getElementById('helplink').href = this.xl('main.helplink');
	if (this.debugflag && this.firstflag) {
		for (const el of Object.keys(this.texts))
			this.prxl(el, this.texts[el]);
	}
	this.firstflag = false;
}
/* translate for new language */
this.setlang = () => {
	this.mylang = document.getElementById('langsel').value;
	this.xlateall();
	document.documentElement.lang = this.mylang;
}
/* find language from filename */
this.querylang = () => {
	let found = 0;
	for (const l of this.alllangs) {
		if (window.location.pathname.substring(window.location.pathname.length - 8).toUpperCase().startsWith('_' + l.toUpperCase())) {
			this.mylang = l;
			document.getElementById('langsel').value = l;
			found = 1;
			break;
		}
	}
	if (!found) {
		this.mylang = 'en';
		document.getElementById('langsel').value = 'en';
	}
	if ('00' === this.mylang)
		this.debugflag = true;
	else
		document.documentElement.lang = this.mylang;
	// followed by xlall anyway
}
/* debug */
this.prgr = (gr, indent) => {
	const str = '                ';
	if (undefined === gr.title) return;
	console.log(str.substring(0,2*indent), gr.title, '   ', this.countfiles(gr));
	if (undefined === gr.smembers) return;
	for (const s of gr.smembers) {
		prgr(s, indent + 1);
	}
}
/* print translations */
this.prxl = (key, el) => {
	if (el['de'] && el['en']) {
		let out = key + ';';
		out += '\'' + el['de']  + '\';';
		out += '\'' + el['en']  + '\';';
		console.log(out);
	}
	for (const ne of Object.keys(el).filter((k) => ((k !== 'en') && (k !== 'de')))) {
		this.prxl(key + '.' + ne, el[ne]);
	}
}
/* only debug */
this.dodebug = () => {
	const fr = new FileReader();
	fr.onload = (res) => {
		const dp = new DOMParser();
		const doc = dp.parseFromString(res.target.result,'text/html');
		const sel2 = doc.querySelectorAll('a');
		for (const r of sel2) {
			if (r) {
				let rawname = r.href;
				if (rawname.indexOf('del=') != -1) continue;
				while (rawname.indexOf("/") > -1)
					rawname = rawname.substring(rawname.indexOf("/") + 1);
				if (rawname.substring(rawname.length -4).toUpperCase() === '.RAW') {
					if (rawname < this.earliestraw) this.earliestraw = rawname;
					if (rawname > this.latestraw) this.latestraw = rawname;
					this.rimbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
					this.imbeles.push({
							type: 'RAW',
							url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
							raw: rawname,
							selected: false,
							preview: null,
							entry: null,
							waiting: false,
							error: false,
							processed: false
					});
					const cl = rawname.substring(0,12);
					if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
						this.untypedclasses.push(cl);
					if (this.typedclasses.findIndex((v, i, o) => v === ('RAW' + cl)) === -1)
						this.typedclasses.push('RAW' + cl);
				}
				else if (rawname.substring(rawname.length -4).toUpperCase() === '.JPG') {
					if (rawname < this.earliestjpg) this.earliestjpg = rawname;
					if (rawname > this.latestjpg) this.latestjpg = rawname;
					this.imbpics.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
					this.imbeles.push({
							type: 'JPG',
							url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
							raw: rawname,
							selected: false,
							preview: null,
							entry: null,
							waiting: false,
							error: false,
							processed: false
					});
					const cl = rawname.substring(0,12);
					if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
						this.untypedclasses.push(cl);
					if (this.typedclasses.findIndex((v, i, o) => v === ('JPG' + cl)) === -1)
						this.typedclasses.push('JPG' + cl);
				}
				else {
					if (rawname < this.earliestmov) this.earliestmov = rawname;
					if (rawname > this.latestmov) this.latestmov = rawname;
					this.imbmovies.push('http://192.168.1.254/IMBACK/PHOTO/' + rawname);
					this.imbeles.push({
							type: 'oth',
							url: 'http://192.168.1.254/IMBACK/PHOTO/' + rawname,
							raw: rawname,
							selected: false,
							preview: null,
							entry: null,
							waiting: false,
							error: false,
							processed: false
					});
					const cl = rawname.substring(0,12);
					if (this.untypedclasses.findIndex((v, i, o) => v === cl) === -1)
						this.untypedclasses.push(cl);
					if (this.typedclasses.findIndex((v, i, o) => v === ('oth' + cl)) === -1)
						this.typedclasses.push('oth' + cl);
				}
			}
		}
		document.getElementById('piccnt').innerHTML = '' + this.imbpics.length + ' (';
		if (this.earliestjpg.length > 4) document.getElementById('piccnt').innerHTML += this.earliestjpg.substring(0,16);
		document.getElementById('piccnt').innerHTML += ' - ';
		if (this.latestjpg.length > 4) document.getElementById('piccnt').innerHTML += this.latestjpg.substring(0,16);
		document.getElementById('piccnt').innerHTML += ')';
		document.getElementById('piccnt').removeAttribute('data-myxlkey');
		document.getElementById('rpiccnt').innerHTML = '' + this.rimbpics.length + ' (';
		if (this.earliestraw.length > 4) document.getElementById('rpiccnt').innerHTML += this.earliestraw.substring(0,16);
		document.getElementById('rpiccnt').innerHTML += ' - ';
		if (this.latestraw.length > 4) document.getElementById('rpiccnt').innerHTML += this.latestraw.substring(0,16);
		document.getElementById('rpiccnt').innerHTML += ')';
		document.getElementById('rpiccnt').removeAttribute('data-myxlkey');
		document.getElementById('movcnt').innerHTML = '' + this.imbmovies.length + ' (';
		if (this.earliestmov.length > 4) document.getElementById('movcnt').innerHTML += this.earliestmov.substring(0,16);
		document.getElementById('movcnt').innerHTML += ' - ';
		if (this.latestmov.length > 4) document.getElementById('movcnt').innerHTML += this.latestmov.substring(0,16);
		document.getElementById('movcnt').innerHTML += ')';
		document.getElementById('movcnt').removeAttribute('data-myxlkey');
		document.getElementById('imbdoit').disabled = false;
		document.getElementById('imbvisbrows').disabled = false;
		document.getElementById('onimback').style['display'] = '';
	};
	fr.readAsText(document.getElementById('dbgfsel').files[0]);
}
/* indentation in */
};
function init() {
	imbc = new ImBC();
	imbc.querylang(); imbc.xlateall(); imbc.checkimb();
}
</script>
</head>
<!-- here comes the html itself -->
<body style="font-family: Helvetica, Arial, sans-serif;" onload="init();">

<div style="font-weight:bold;"><span data-myxlkey='main.title'> </span> <span translate="no">V2.9.9_DEVEL</span> - <a target="_new" id="helplink" href="https://shyrodgau.github.io/imbraw2dng/" data-myxlkey='main.help'></a> <select id="langsel" onchange="imbc.setlang()"><option value="de" onclick="imbc.setlang()">DE</option><option value="en" onclick="imbc.setlang()">EN</option></select></div>
<div id="normal" style="margin-top: 0.5em;">
<!-- the normal display -->
<div><input type="checkbox" id="steppreview" checked><label for="steppreview" data-myxlkey="process.singlestep"></label></div>
<div><input type="checkbox" id="addlink"><label for="addlink" data-mytitlexlkey="process.maycostmem" title="T" data-myxlkey="process.addlink"></label></div>
<div  style="margin-top: 0.5em;" data-myxlkey="main.generaladvice"></div>
<!-- connected ! -->
<div id="onimback" style="background-color:#ffffbb;border: 5px solid #ffff88;border-radius: 10px;width:fit-content;padding:1em;display:none;"><div style="font-size:133%;" data-myxlkey="onimback.connected"></div>
<span data-myxlkey="onimback.dlconvert"></span><br>
<input checked type="checkbox" id="rpicfromimb"><label for="rpicfromimb" data-myxlkey="main.types.rawpics"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="rpiccnt" data-myxlkey="main.stillcounting"></span>
<br><input checked type="checkbox" id="picfromimb"><label for="picfromimb" data-myxlkey="main.types.jpgpics"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="piccnt" data-myxlkey="main.stillcounting"></span> 
<br><input checked type="checkbox" id="movfromimb"><label for="movfromimb" data-myxlkey="main.types.other"></label>, <span data-myxlkey="onimback.totalnum"></span> <span id="movcnt" data-myxlkey="main.stillcounting"></span><br>
<span data-myxlkey="onimback.fromtime"></span> <input type="text" maxlength="16" id="imbstartts" inlength="0" placeholder="YYYY_MMDD_hhmmss" pattern="[0-9][0-9][0-9][0-9](_[0-9][0-9][0-9][0-9]_([0-9][0-9]([0-9]([0-9][0-9][0-9])*)*)*)*"> (<span data-myxlkey="onimback.nullforall"></span>) <br>
<input onclick="imbc.imbdoit()" type="button" data-myvalxlkey="onimback.doit" id="imbdoit" disabled><br>
<span data-myxlkey="main.or"></span> <input type="button" data-myvalxlkey="onimback.visual" id="imbvisbrows" onclick="imbc.visbrows()" disabled>.
</div>
<!-- end of connected -->
<div style="font-size:133%;margin-top: 0.5em;" data-myxlkey="main.drophere"></div>
<div id="droptarget" ondrop="imbc.drophandler(event);" ondragenter="imbc.prevdef(event);" ondragover="imbc.prevdef(event);" style="border: 5px solid blue;border-radius: 10px;width:300px; height:70px;background-color: rgba(0,0,255,0.2);"></div><br>
<div  style="font-size:133%;margin-top: 0.5em;"><span data-myxlkey="main.selectraw"></span> <input type="file" accept=".raw,.RAW" id="infile" name="infile" multiple onchange="imbc.fselected()"></div><br>
&nbsp;<br>
<div id="reloadhint" style="display:none;" data-myxlkey="main.reload"><br>&nbsp;</div>
<div id="xmsg" style="display: none; width: fit-content;white-space: pre;"><span style="font-weight:bold;" data-myxlkey="main.log"></span><br>
<div id="outmsg"></div></div>
<div id="reloadhint2" style="display:none;" data-myxlkey="main.reload"><br>&nbsp;</div>
</div>
<!-- normal preview with question -->
<div id="question" style="display:none;background-color:#ddffaa;border: 5px solid #33ff33; border-radius: 10px;width: fit-content;padding:2em;">
<div style="font-weight:bold;" id="qhdr">&nbsp;</div>
<canvas id="preview"></canvas><img style="display:none;max-width:550px; max-height:550px;" id="jpegpreview" onload="imbc.setjpegpv()" onerror="imbc.setpverr()"><div id="previewerr" data-myxlkey="preview.err"></div><div id="previewwait"><span class="blink">.</span><span class="blink2">.</span><span class="blink3">.</span></div><br>
<div id="rotations"><input type="button" id="procthiscw" data-myvalxlkey="preview.rotcw" data-mytitlexlkey="preview.rotcw.tooltip" onclick="imbc.rotcw()" style="padding:0.5em; margin:0.5em;margin-left:2.5em;">
<input type="button" id="procthisccw" data-mytitlexlkey="preview.rotccw.tooltip" data-myvalxlkey="preview.rotccw" onclick="imbc.rotccw()" style="padding:0.5em; margin:0.5em;">
<input type="button" id="procthisud" data-myvalxlkey="preview.rot180" data-mytitlexlkey="preview.rot180.tooltip" onclick="imbc.rot180()" style="padding:0.5em; margin:0.5em;" >
<input type="button" id="procthisrs"data-myvalxlkey="preview.rotreset" data-mytitlexlkey="preview.rotreset.tooltip" value="Reset" onclick="imbc.rot0()" style="padding:0.5em; margin:0.5em;"></div>
<div id="continues"><input type="button" id="procthis" data-myvalxlkey="preview.process" onclick="imbc.procthis()" style="padding:0.5em; margin:0.5em;">
<input type="button" id="skipthis" data-myvalxlkey="preview.skip" value="Skip" onclick="imbc.skipthis()" style="padding:0.5em; margin:0.5em;">&nbsp;
<span id="forrest"><input type="checkbox" id="doforall" style="padding-left:0.5em; margin-left:0.5em;"><label for="doforall" data-myxlkey="preview.forall"></label></span></div>
</div>
<!-- this is the picture browser, generated content appended -->
<div id="browser" style="background-color:#ffccbb;border: 5px solid #ff8833; border-radius: 10px;width: 90%;padding-left:2em;padding-right:2em;padding-top:1em; padding-bottom:1em;display:none;flex-direction:column;">
<div style="margin-bottom:1em;"><span data-myxlkey="main.sort"></span>: <label for="sbytype"><input type="checkbox" id="sbytype" onclick="imbc.buildtree()"><span data-myxlkey="browser.bytype"></span></label> - <label for="solder"><input type="checkbox" id="solder" onclick="imbc.buildtree()"><span data-myxlkey="browser.olderfirst"></span></label>
 - <span data-myxlkey="main.selected"></span>: <span id="brnsel" class="selnumber">?</span> / <span id="brntot">?</span> - <label for="selall" data-mytitlexlkey="browser.selall.tooltip"><input onclick="imbc.topreccheck()" type="checkbox" id="selall"><span data-myxlkey="browser.selall"></span></label> - <input type="button" data-myvalxlkey="browser.procall" onclick="imbc.browserprocess()" id="doselbut"> - <input type="button" data-myvalxlkey="browser.delall" onclick="imbc.browserdelete()" id="delselbut" disabled></div>
</div>
<!-- this is the delete question/progress -->
<div id="delq" style="border: 2px solid red; border-radius: 20px; padding: 20px;display:none;width:fit-content;">
<span data-myxlkey="del.question"></span><br>
<input id="delcancelbut" type="button" data-myvalxlkey="del.question.cancel" onclick="imbc.delcancel()"> - <input id="delokbut" type="button" data-myvalxlkey="del.question.ok" onclick="imbc.dodelete()"><br>
<span data-myxlkey="del.nostatus"></span><br>
<div id="delprogmsg"></div>
</div>
<!-- debug -->
<input type="file" onchange="imbc.dodebug()" accept=".html,.htm" id="dbgfsel" style="display:none;">
<!-- this is invisible -->
<a style="display: none;" id="result">x</a>
</body>
</html>
